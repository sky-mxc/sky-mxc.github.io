<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[错题本:ConstraintLayout 不能正常显示]]></title>
    <url>%2F2019%2F08%2F25%2Fwrong-constraintLayout-no-show%2F</url>
    <content type="text"><![CDATA[理想效果： 实际效果: 原因：因为文件中一个控件的约束属性写错了这个属性是 app:layout_constraintLeft_toLeftOf=&quot;@id/oa_setting_group_tv_add&quot;写成了自己在自己左边了。 1234567891011&lt;TextView android:id=&quot;@+id/oa_setting_group_tv_add&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;@dimen/dp_10&quot; android:text=&quot;新增考勤组&quot; android:textColor=&quot;@color/oa_color&quot; android:textSize=&quot;@dimen/sp_16&quot; app:layout_constraintBottom_toBottomOf=&quot;@id/oa_setting_group_background_add&quot; app:layout_constraintLeft_toLeftOf=&quot;@id/oa_setting_group_tv_add&quot; app:layout_constraintTop_toTopOf=&quot;@id/oa_setting_group_background_add&quot; /&gt; 如何发现：逐个排查 首先将第一个控件放在了另一个已经在使用的布局里，正常显示； 在使用 tools-&gt; XML Action-&gt;validate 检查无果后。 重新建立个文件，逐个控件，逐个属性的写，这时完全不 care 原文件。 因为这次比较仔细，故理想的样子直接就出来了 对照两个文件，发现有一个属性写错了！！！ 如何修复：改回来总结：实时预览！ConstraintLayout 一个控件的疏忽就是满盘皆输。打开预览，实时注意效果。实在太着急最次也要一个控件一预览。否则太难找了。]]></content>
      <categories>
        <category>错题本</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>错题本</tag>
        <tag>ConstraintLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle-日志]]></title>
    <url>%2F2019%2F08%2F24%2Fgradle-logger%2F</url>
    <content type="text"><![CDATA[日志级别Gradle 的日志 和Android 一样也有多个级别。 级别 用于 ERROR 错误消息 QUITE 重要消息 WARNING 警告消息 LIFECYCLE 进度消息 INFO 信息消息 DEBUG 调试消息 要显示指定级别的日志，可以通过日志开关来控制的，在执行的时候加入下面这些开关即可. 开关选项 输出的日志级别 无选项 LIFECYCLE 及其更高级别 -q 或者 –quite QUITE -i 或者 –info INFO -d 或者 –debug DEBUG 12//在执行 build task时的输出的日志会是 QUITE 级别 gradle -q build 如果不想每次都在命令行加入参数来指定,可以在 配置文件(gradle.properties) 中修改,值可以是六种的任意一个，不区分大小写 1org.gradle.logging.level=(quiet,warn,lifecycle,info,debug) 或者在脚本中更改级别 ，project 类 提供了 LoggerManager 来管理 日志 12logging.captureStandardOutput LogLevel.INFOprintln &apos;A message which is logged at INFO level&apos; Task 类也提供了这个 LoggerManager 所以在 任务中也是可以配置的；123456task logInfo &#123; logging.captureStandardOutput LogLevel.INFO doFirst &#123; println &apos;A task message which is logged at INFO level&apos; &#125;&#125; 输出堆栈信息在任务执行出问题的时候，堆栈信息就显得尤为重要了， 然而默认堆栈信息开关是关闭的，只有打开开关才会输出出来。 命令行选项 用于 无选项 没有堆栈信息输出 -s 或者 –stacktrace 输出关键堆栈信息 -S 或者 -full-stacktrace 输出全部堆栈信息 一般使用 -s 或者 –stacktrace 输出关键堆栈，输出全部堆栈信息就太多了，不好定位问题。1gradle build -s 输入自己的日志通常情况下都是使用 print 系列方法，把日子输出到 控制台（它把 Gradle 定向为 QUITE 级别日志） 1println &apos;输出一段日志信息&apos; 除了 print 系列之外，还可以使用内置的 logger 更灵活的控制输出不同级别的日志。 12345678910task log()&#123; doLast&#123; logger.quiet(&apos;quiet 重要消息&apos;) logger.error(&apos;error 错误消息&apos;) logger.lifecycle(&apos;lifecycler 进度消息&apos;) logger.warn(&apos;warn 警告消息&apos;) logger.info(&apos;info 消息 信息&apos;) logger.debug(&apos;debug 调试信息&apos;) &#125;&#125; 新建一个 logger.gradle 添加一个 log Task 运行 log Task 1gradle -b logger.gradle log 如果使用 -d 的话 就是下面这种了。 1gradle -b logger.gradle -d log 更改日志内容可以通过 Gradle.useLogger()) 方法传入一个自定义的日志对象。 这个对象可以是以下几个监听的派生类 BuildListener TaskExecutionGraphListener ProjectEvaluationListener TaskExecutionListener TaskActionListener StandardOutputListener TestListener TestOutputListener DependencyResolutionListener 这里以 任务执行 (TaskExecutionListener ) 为例 1234567891011121314151617181920212223242526272829task test &#123; doLast&#123; logger.quiet &quot;级别：&#123;&#125;&quot;,&quot;quite&quot; logger.error &quot;级别：error&quot; &#125;&#125;//使用指定的日志对象gradle.useLogger(new CustomEventLogger())//自定义日志内容class CustomEventLogger extends BuildAdapter implements TaskExecutionListener &#123; void beforeExecute(Task task)&#123; println &quot;beforeExecute-&gt; $&#123;task.name&#125;&quot; &#125; void afterExecute(Task task,TaskState state)&#123; println &quot;afterExecute -&gt; $&#123;task.name&#125; successed?$&#123;state.failure==null&#125;&quot; &#125; void buildFinished(BuildResult result)&#123; println &quot;build completed&quot; if(result.failure)&#123; result.failure.printStackTrace() &#125; &#125;&#125; 执行 1gradle test 输出如下 1234567&gt; Task :testbeforeExecute-&gt; test级别：quite级别：errorafterExecute -&gt; test succeed?truebuild completed1 actionable task: 1 executed]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle-Groovy语法]]></title>
    <url>%2F2019%2F08%2F18%2Fgroovy-basic%2F</url>
    <content type="text"><![CDATA[Groovy 简介Groovy 是一种基于 JVM 的动态语言，他的语法和 Java 相似，最终也是要编译 .class 在JVM上运行。 Groovy 完全兼容 Java 并且在此基础上添加了很多动态类型和灵活的特性，比如支持闭包，支持DSL，是一门非常灵活的动态脚本语言。 这篇文章是为了能看懂在 Gradle脚本中的代码，知道怎么写。所以不会深入Groovy。 每个 build 脚本配置文件都是一个 Groovy脚本文件。在里面可以写任何符合 Groovy 语法的代码。例如定义类，方法，变量等。又因为Groovy 是完全兼容Java的，故也可以写任何Java代码，是完全兼容的。 DSLDSL（Domain Specific Language) 中文意思是 领域特定语言，专门关注某一领域，在于专而不是全。所以才是领域特定的。 Gradle 的脚本就是基于 Groovy 的DSL，专门解决自动化构建的DSL。我们只需要按照相应的语法，配置相应的 Gradle 脚本就可以达到自动化构建的目的，这也是 DSL 的初衷。 注释单行注释12//这里是注释def name = &quot;佛系编码&quot; 多行注释12/* 这里是多行注释 啦啦啦啦 */ doc 注释1234/** * 这里是 doc 注释 * 啦啦啦啦 */ 数据类型Java中的基本数据类型，对象它都支持；另外还有闭包加强的 List，Map的集合加强的File，Stream等IO类型 类型可以显式声明，也可以用 def 来声明，用 def 声明的类型Groovy将会进行类型推断。 基本数据类型都是和Java 中的一致，就不拿出来说了。下面说一下，对象，字符串，闭包等; 另外：Groovy 中的分号是可以省略的； 字符串使用单引号和双引号都可以定义一个字符串常量。 差别是 单引号只是单纯的字符串，不能使用表达式，运算，求值，正则等。 123456789task character()&#123; doLast&#123; def name = &apos;张三&apos; def address =&quot;北京市&quot; def age = 19 println &quot;单引号双引号都是字符串 name is $&#123;name&#125;; age is $age ; address is $&#123;address&#125;&quot; println &apos;单引号里无法运算表达式例如 name is $&#123;name&#125;&apos; &#125;&#125; 执行 character1gradle character 得到结果如下 12单引号双引号都是字符串 name is 张三; age is 19 ; address is 北京市单引号里无法运算表达式例如 name is $&#123;name&#125; 双引号的字符串可以直接进行表达式计算，规则是一个美元符号紧跟一个花括号: ${expression} ，如果只有一个变量可以省略花括号。例如上面的 $age 集合集合默认是 java.util.ArrayList 类型的12def nums = [1,2,4,5,6]println &quot;nums is $&#123;nums.getClass().getName()&#125; size = $&#123;nums.size()&#125;&quot; 输出结果为1nums is java.util.ArrayList size = 5 也可以显式指定集合类型 使用 as 关键字； 12def nums1 = [0,&quot;23&quot;,4,5,62,false] as LinkedListprintln &quot;nums1 is $&#123;nums1.getClass().getName()&#125;;size = $&#123;nums1.size()&#125;&quot; 输出为 1nums1 is java.util.LinkedList;size = 6 或者在前面显式指定类型 1LinkedList otherLinked = [3, 4, 5] 访问元素元素的访问是通过下标访问的 12println &quot;第三个元素是 $&#123;nums1[2]&#125;,倒数第一个是 $&#123;nums1[-1]&#125;;第一个和倒数第一个：$&#123;nums1[0,-1]&#125;&quot;println &quot;第二个到第四个：$&#123;nums1[1..3]&#125;&quot; 输出为： 12第三个元素是 4,倒数第一个是 false;第一个和倒数第一个：[0, false]第二个到第四个：[23, 4, 5] 遍历元素使用 each 方法遍历集合 参数默认是 it 1234//遍历nums1.each &#123; print &quot;$it, &quot;&#125; 输出为： 10, 23, 4, 5, 62, false, 带有下标的遍历：使用 eachWithIndex 方法 123numList.eachWithIndex &#123; int value ,int index-&gt; println &quot;list[$index] = $value&quot; &#125; 数组数组的定义要明确的指定数组类型 123456789101112String [] strings = [&quot;I&quot;,&quot;&apos;&quot;,&quot;m&quot;,&quot;is&quot;,&quot;a&quot;,&quot;dog&quot;,&quot;.&quot;]println &quot;\n 数组 :$&#123;strings.getClass().getName()&#125;&quot;strings.each&#123; print &quot;$it &quot;&#125;def multi = [5,7,5,8,54,87] as int[]println &quot;\n使用 as 显式指定类型: $&#123;multi.getClass().getName()&#125;&quot;multi.each&#123; print &quot;$it &quot;&#125; 输出是 1234数组 :[Ljava.lang.String;I &apos; m is a dog .使用 as 显式指定类型: [I5 7 5 8 54 87 添加元素使用 List.add() 添加元素 1numList.add(-11) 使用 可以使用 &lt;&lt; 操作符添加一个 1numList &lt;&lt; 13 修改元素1numList[0] = 0 不用担心下标越界；Groovy就自动增加到所需的下标,中间的会设置为 null 123456789101112131415def numList = [0,1,2,3,4,5] as LinkedListnumList.each&#123; print &quot;$it &quot;&#125;println &quot;\n 在 10位置添加一个 11&quot;numList[10] =11println &quot;添加后的：&quot;numList.each&#123; print &quot;$it &quot;&#125; 输出为： 123456&gt; Task :collect10 1 2 3 4 5 在 10位置添加一个 11添加后的：0 1 2 3 4 5 null null null null 11BUILD SUCCESSFUL in 0s 删除元素使用 List.remove() 移除元素 参数可以是 下标，可以是值 12numList.remove 0numList.remove((Object)10) 使用 List.removeLast() 移除最后一个元素 1numList.removeLast() 查找元素使用 List.find() 查找第一个符合条件的元素 12print &quot;\n list.find() 查找第一个符合条件的元素 numList.find &#123; it%2==0&#125;&quot;print numList.find &#123; it%2==0&#125; 使用 List.findAll() 查找所有符合条件的元素 12print &quot;\n list.findAll() 查找所有符合条件的元素 numList.findAll &#123;it % 2 ==0 &#125;&quot;print numList.findAll &#123; it % 2 ==0&#125; 使用 List.any() 查找元素，只要有一个元素符合就返回 true 12print &quot;\n list.any() 只要有一个元素符合条件就返回 true numList.any &#123; it % 2 ==1&#125; &quot;print numList.any &#123; it % 2 ==1&#125; 使用 List.every() 查找元素，必须所有元素都符合条件才会返回 true 12print &quot;\n list.every() 必须所有元素都符合条件才会返回 true numList.every &#123;it % 2 == 0&#125; &quot;print numList.every &#123; it % 2 == 0&#125; 统计元素统计符合条件的元素个数：使用 List.count() 1print numList.count &#123; it % 2 ==0 &#125; 统计最大值：List.max()，最小值：List.min() 12print &quot;\n 最大值是 $&#123;numList.max()&#125; ,最小值是 $&#123;numList.min()&#125;， 最小的绝对值是 &quot;print numList.min &#123; Math.abs it&#125; MapMap 的定义是键值对的方式，使用逗号隔开 1def colors = [red:&apos;#FF0000&apos;,green:&apos;#00FF00&apos;,blue:&apos;#0000FF&apos;] 访问 Map 中的元素有三种方式： map.key map[key] map.get(key) 例如： 123456789task map&#123; doLast&#123; def colors = [red:&apos;#FF0000&apos;,green:&apos;#00FF00&apos;,blue:&apos;#0000FF&apos;] println &quot; map calss is $&#123;colors.getClass().getName()&#125;&quot; println &quot;通过 map.key 的方式访问 colors.red = $&#123;colors.red&#125;&quot; println &quot;通过 map[key] 的方式访问 colors[&apos;red&apos;] = $&#123;colors[&apos;red&apos;]&#125;&quot; println &quot;通过 map.get(key) 的方式访问 colors.get(red) = $&#123;colors.get(&apos;red&apos;)&#125;&quot; &#125;&#125; 输出为 ： 123456789&gt; Task :map map calss is java.util.LinkedHashMap通过 map.key 的方式访问 colors.red = #FF0000通过 map[key] 的方式访问 colors[&apos;red&apos;] = #FF0000通过 map.get(key) 的方式访问 colors.get(red) = #FF0000BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 添加元素123//添加元素colors[&apos;pink&apos;] = &apos;#FF00FF&apos;colors.yellow = &apos;#FFFF00&apos; 修改元素1234//修改元素colors.red = &apos;red&apos;colors[&apos;blue&apos;] = &apos;blue&apos;println &quot;修改后的元素是 colors.red = $&#123;colors.red&#125;,colors.blue = $&#123;colors.blue&#125;&quot; 删除元素12//删除元素colors.remove(&apos;red&apos;) 遍历元素和上面的一样 使用 each 方法 1234//遍历colors.each&#123; println &quot;$&#123;it.key&#125; :$&#123;it.value&#125;&quot;&#125; 查找元素查找的方法 和 上面的都一样，只是 参数换成了 Map.Entry 或者 key,value ;这里只用 find 做一个示例： find 方法 1234567891011121314151617def green = colors.find &#123; key ,value -&gt; if(key.equals(&apos;green&apos;)) &#123; return colors[key] &#125; return null&#125;println &quot;查找结果是 $&#123;green&#125;&quot;def blue = colors.find &#123; Map.Entry entry -&gt; if(entry.key.equals(&apos;blue&apos;))&#123; return entry.value &#125; return null&#125;println &quot;查找的结果是 $&#123;blue&#125;&quot; 方法方法也是使用 def 定义的 12345678910/* * 返回大的那个 */def max(int a ,int b)&#123; if(a&gt;b)&#123; return a &#125;else&#123; return b &#125;&#125; return 是可以省略的Groovy 会把执行过程中的最后一句代码作为返回值 12345678910/* * 返回大的那个 */def max(int a ,int b)&#123; if(a&gt;b)&#123; a &#125;else&#123; b &#125;&#125; 括号是可以省略的；在调用方法时括号是可以省略的；使用 空格间隔开参数即可 1234567891011121314def printMaximum(int a,int b)&#123; if(a&gt;b)&#123; println &quot;The maximum value of $a and $b is $a&quot; &#125;else&#123; println &quot;The maximum value of $a and $b is $b&quot; &#125;&#125;task method &#123; doLast&#123; println &quot;max is $&#123;max(0,1)&#125;&quot; printMaximum 10,20 &#125;&#125; 输出是 123456&gt; Task :methodmax is 1The maximum value of 10 and 20 is 20BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 代码块是可以作为参数传递的代码块就是一段被花括号包围的代码，其实就是闭包； 例如 each 方法 最原始的应该是这样的 1colors.each(&#123;println it&#125;) 格式化后 123colors.each(&#123; println it&#125;) Groovy 规定最后一个参数是闭包,可以将闭包放在方法外面 123colors.each()&#123; println it&#125; 调用时方法的括号是可以省略的 就成了这样 123colors.each &#123; println it&#125; 闭包闭包是 Groovy 的一个重要特性，可以说是 DSL 的基础。 闭包其实就是一段匿名代码块。 闭包在 Groovy 中是 groovy.lang.Closure 类的实例，这使得闭包可以赋值给变量或字段。 定义一个闭包 1def hello = &#123; println &quot;Hello 佛系编码&quot; &#125; 调用这个闭包 1hello.call() 另一种调用方式 直接在后面跟上 () 1hello() 下面模拟一个 each 的执行，定一个方法迭代集合中的元素 12345678910/* * closure 就是 闭包参数 */def customEach(closure)&#123; //迭代元素 for(int i in 1..10)&#123; //在闭包后跟上 () 就是调用了 括号里的参数就是闭包要接收的参数 closure(i) &#125;&#125; 调用这个方法，传入一个闭包打印元素; 如果闭包只有一个参数，那么默认就是 it 1234// 如果只有一个参数 默认就是 itcustomEach &#123; println it&#125; 如果闭包要接收多个参数，那就必须把参数显式的列出来，使用 -&gt; 将参数和主体分开 再次模拟一个 map 的 迭代: 123456789101112def eachMap(closure)&#123; def map1 = [name:&apos;佛系编码&apos;,age:666] map1.each &#123; closure(it.key,it.value) &#125;&#125;·····//如果有多个参数，就必须要把参数列出来，使用 -&gt; 将 参数和主体分开eachMap &#123; key,value -&gt; println &quot;$key:$value&quot;&#125; 闭包委托Groovy 闭包的强大之处在于它支持闭包方法的委托。 Groovy 的闭包有三个重要属性 thisObject 闭包定义所在的类 owner 表示闭包定义所在的对象或闭包（闭包内还是可以定义闭包的），这个是最近原则，下面会做说明 delegate 默认和 owner 一致，可以手动修改。 如果将闭包定义在一个类中，默认三个属性都是相等的； 举个例子： 在 Person 类中 定义了 一个 act 闭包 12345678910111213class Person&#123; private String name public int getAge()&#123; 12 &#125; Closure act =&#123; println &quot;thisObject:$&#123;thisObject.getClass()&#125;&quot; println &quot;owner:$&#123;owner.getClass()&#125;&quot; println &quot;delegate:$&#123;delegate.getClass()&#125;&quot; &#125;&#125; 调用这个闭包，将会有下面的输出 1234567&gt; Task :testthisObject:class Personowner:class Persondelegate:class PersonBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 如果将 闭包定义在一个 闭包里，那么 thisOjbect 就和 其他两个不一样，因为 thisObject 是表示的定义闭包所在的类，而 owner 表示 类或闭包 这次在 一个闭包里再定一个闭包看一下 12345678910111213141516171819202122class Person&#123; private String name public int getAge()&#123; 12 &#125; Closure act =&#123; println &quot;thisObject:$thisObject&quot; println &quot;owner:$owner&quot; println &quot;delegate:$delegate&quot; &#125; Closure eat = &#123; def test = &#123; println &quot;thisObject:$&#123;thisObject.getClass()&#125;&quot; println &quot;owner:$&#123;owner.getClass()&#125;&quot; println &quot;delegate:$&#123;delegate.getClass()&#125;&quot; &#125; test() &#125;&#125; 执行这个 eat 闭包，将会得到以下结果 1234567&gt; Task :testthisObject:class Personowner:class Person$_closure2delegate:class Person$_closure2BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 可以看到 thisObject 和 owner 已经不一样了，因为 thisObject 表示的是 所在的类，而 owner 表示的定义所在的类或闭包（最近原则） 三个属性已经很明白了吧， 委托策略无论什么时候在闭包中访问某属性或调用某方法时，若没有明确的设置对象，那么就会调用一个委托策略。通过这个委托策略来决定如果访问属性或调用方法。 有以下几个策略，可以通过 闭包的属性更改：resolveStrategy Closure.OWNER_FIRST 默认策略，首先在 owner 上寻找属性和方法，找不到则在 delegate 上找。 Closure.DELEGATE_FIRST 和上面的相反，首先在 delegate 上寻找，找不到则在 owner 上找 Closure.OWNER_ONLY 只在 owner 上找，忽略 delegate Closure.DELEGATE_ONLY 只在 delegate 上找 忽略 owner Closure.TO_SELF 高级选项，开发者自己定义策略 下面通过一个嵌套类演示一下 策略更改的实际应用。 定义两个类 Person 和 内部类 Foot ，并且两者都有 name 属性。Person 多一个 age 属性。 12345678910111213141516171819202122232425class Person&#123; private String name public int getAge()&#123; 12 &#125; class Foot &#123; String name Closure walk = &#123; it -&gt; println &quot;name is $name,age is $age ,delegate is $&#123;delegate.getClass()&#125;&quot; //设置 delegate 属性 delegate = it; resolveStrategy = Closure.DELEGATE_FIRST println &quot;修改策略为 Closure.DELEGATE_FIRST delegate 优先&quot; println &quot;name is $name, age is $age ,delegate is $&#123;delegate.getClass()&#125;&quot; &#125; &#125; void walk()&#123; Foot foot = new Foot(name:&apos;脚&apos;); foot.walk(this) &#125;&#125; 调用 Person 的 walk 方法 123Person person = new Person()person.name =&quot;佛系编码&quot;person.walk() 将会得到下面的输出 1234567&gt; Task :testname is 脚,age is 12 ,delegate is class Person$Foot修改策略为 Closure.DELEGATE_FIRST delegate 优先name is 佛系编码, age is 12 ,delegate is class PersonBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 我来解释一下这个输出 第一个name 是 脚 ；这是因为默认策略是 Closure.OWNER_FIRST 是在 owner 寻找属性的；owner 当然是 Foot了。 第二个 name 是 佛系编码;这是因为 策略改为了 Clousre.DELEGATE_FIRST 是优先在 delegate 上寻找的，而又把 delegate 属性修改为了传进去的 Person 实例，他的值在上面已经明确声明为了 佛系编码 。 而 age 只有在 Person 中声明了 getAge() 方法，明确返回了 12.所以即使更改了策略，换了delegate 的值，仍然是 12. 注：三个属性中 只有 delegate 属性可以修改。 在 Gradle 中，我们一般会指定 delegate 为当前的 it,这样在闭包中就可以对 it 进行配置 定义一个 User 类 1234567891011class User&#123; String name int age def dumpUser()&#123; println &quot;name is $name,age is $age .&quot; &#125;&#125; 在构建配置脚本中定义一个方法，传入一个闭包参数用来配置 User 类 将闭包委托策略更改，并设置 delegate 属性 123456def user(Closure&lt;User&gt; closure)&#123; User user = new User() closure.delegate = user closure.resolveStrategy = Closure.DELEGATE_FIRST closure(user)&#125; 在使用的时候就是这样的了，Gradle 中就有很多这种的 DSL 配置，例如我们创建的 task 123456789task configClosure()&#123; doLast&#123; user &#123; name = &apos;佛系编码&apos; age = 0 dumpUser() &#125; &#125;&#125; 输出为 12345&gt; Task :configClosurename is 佛系编码,age is 0 .BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 闭包 API 传送门 类这里只介绍和 Java 中不同的地方. 先看段代码： 123456789101112131415161718task obj&#123; doLast&#123; Person p = new Person() println &quot;没赋值前的 ：$&#123;p.name&#125;&quot; p.name = &apos;佛系编码&apos; println &quot;赋值后的 ：$&#123;p.name&#125;&quot; println &quot;age is $&#123;p.age&#125;&quot; &#125;&#125;class Person&#123; private String name public int getAge()&#123; 12 &#125;&#125; 执行 obj 任务的输出 1234567Task :obj没赋值前的 ：null赋值后的 ：佛系编码age is 12BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 在 Person 类中并没有定义 name 属性的 get/set 方法；却可以设置和修改它的值； 这是因为 Groovy 帮我们搞定了 get/set 方法。 age 属性也没有在 Person 类中定义，只是定义了一个 getAge() 方法却可以使用 age 属性。 但是,因为没有定义 set 方法，所以 age 属性只能访问。 运算符这里只列出来和 Java 不同且常用的运算符 可空运算符对象非空时使用对象本身，对象为空时使用给定值；常用于给定某个可空变量的默认值。 12345678910task operator &#123; doLast&#123; Person person = new Person(); //person.name 为 null 所以会使用 佛系编码 def name = person.name ? person.name:&apos;佛系编码&apos; // getAge 返回 12 不为空 所以使用本身 def age = person.age ?:10 println &quot;name is $name , age is $age&quot; &#125;&#125; 输出 12345&gt; Task :operatorname is 佛系编码 , age is 12BUILD SUCCESSFUL in 0s1 actionable task: 1 executed 安全导航运算符当调用一个对象上的属性或方法时，如果对象是空的，就会抛出空异常，这个使用 ?. 运算符，当对象为空时，表达式的值也是空，就不会抛出异常。 123456task operator &#123; doLast&#123; User user println &quot;user.name is $&#123;user?.name&#125;&quot; &#125;&#125; 输出是 12345&gt; Task :operatoruser.name is nullBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 断言断言是用于验证假设条件是否为真，在Groovy的断言中，如果假设的条件不为真，那么就会抛出java.lang.AssertionError异常。 Groovy断言和Java断言完全不同。Groovy断言是一项语言功能，一直处于开启状态，和JVM的断言功能-ea完全无关。所以它是我们进行单元测试的首选方式。 例如 1assert 1==2 :&quot;1不等于2&quot; 会抛出以下异常 1234567FAILURE: Build failed with an exception.······* What went wrong:Execution failed for task &apos;:operator&apos;.&gt; 1不等于2. Expression: (1 == 2) 当然不给出消息也是可以的 1assert 1==2 那么异常就是这样的。 1234Execution failed for task &apos;:operator&apos;.&gt; assert 1==2 | false 在使用断言时最好是给出一条消息，此消息可以帮助其他人理解和维护你的代码，理清你的意图。 Groovy API 查询方式对于闭包的参数，只能在 API 查询了，没有什么好的办法。 这里把 Groovy 文档地址列出来，方便大家查询相关 API 语法 API 文档 运行须知要使用 gradle 或者 ./gradle 或者 gradlew 命令，必须是要安装Gradle 并设置过环境变量的，当然在Gradle所在的目录也是可以的。 build.gradle 是Gradle 的默认构建脚本文件，在执行 Gradle 命令的时候会默认找在当前目录下的 build.gradle 文件。 也可以通过 -b 参数指定加载执行的文件。 例如 要执行 groovu-basic.build 里的 operator 任务 1gradle -b groovy-basic.gradle operator 如果要执行上面的测试代码，步骤是 新建一个 build.grale 文件 或者是通过 gradle 新建一个项目 看这篇 定义一个任务，添加动作 12345task test&#123; doLast&#123; //这里是代码 &#125;&#125; 粘贴代码 运行任务 1gradle test 附上我的 Gradle 版本]]></content>
      <categories>
        <category>Gradle</category>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle-构建生命周期]]></title>
    <url>%2F2019%2F08%2F10%2Fgradle-lifecycle%2F</url>
    <content type="text"><![CDATA[两个重要的概念项目实际上，一个项目是什么取决于你要用 Gradle 做什么？项目通常代表的是构建内容。 例如在 Android 中，一个 module 就是一个项目； 项目是注册在 setting.gradle 中的 通常一个项目有一个 build.gradle Gradle 构建就是由一个或多个项目组成的。 任务任务 顾名思义就是一个在构建阶段被执行的操作。它是 Gradle 构建的原子工作单位。例如 编译 Java 源代码； 任务是定义在项目的构建脚本中，并且可以彼此依赖。 一个项目就是由一个个任务组成的。 生命周期 每一个 Gradle 构建都会按照相同的顺序经历三个不同的阶段： 初始化Gradle 支持单项目构建和多项目构建。在这个阶段 Gradle 会确认哪些项目将会参与构建。Gradle 会通过 setting.gradle 确定是多项目还是单项目构建。Gradle 会为每个项目创建 Project 实例。 配置在这个阶段执行在初始化阶段中确定的每一个项目的配置脚本，但是并不会执行其中的任务，只会评估任务的依赖性，根据其依赖性创建任务的有向无环图。 Gradle引入了一个称为随需求变配置的特性，该特性使它能够在构建过程中只配置相关和必要的项目。这在大型多项目构建中非常有用，因为它可以大大减少构建时间。 执行在这个阶段，Gradle 会识别在配置阶段创建的任务的有向无环图。并按照他们的依赖顺序开始执行。所有的构建工作都是在这个阶段执行的。如编译源码，生成 .class 文件，复制文件等。 setting.gradle这个文件是由 Gradle 约定命名的，默认名为 setting.gradle ，在初始化阶段被执行。 对于多项目构建，必须在这里声明要参与构建的所有项目。对于单项目构建就是可选的了，可有可无。 Gradle 是如何寻找 setting.gradle 的？ 在当前目录寻找 没有找到的话就去父目录寻找 仍然没有找到就是是单项目构建了 如果找到了就是确定其中的项目，如果当前执行的项目在 setting.gradle 有定义就执行多项目构建，否则就执行单项目构建。 一个脚本的属性访问和方法调用是委托给 Project 类的实例的，类似的 setting.gradle 的属性访问和方法调用是委托给 Settings 类的实例对象的。 单项目构建对于单项目构建，在初始化后的工作流程很简单，构建脚本针对初始化阶段创建的项目对象执行。查找在命令行传入的任务名称相同的任务。如果任务存在则作为一个单独的构建按照命令行传递的顺序执行。 多项目构建多项目构建是在 Gradle 的单个执行过程中构建多个项目的构建。必须把参与构建的项目声明在 setting.gradle 里 项目位置可以把多项目构建看作一个单根的树。每一个项目都是树上的一个节点。一个项目有一个路径表示在树中的位置。通常情况下项目的路径和在文件系统中的位置是一致的，当然了这个路径也是可以配置的。项目树是 setting.gradle 生成的，默认情况下 setting.gradle 的位置就是根项目的位置。但是你可以在 setting.gradle 文件中更改。 构建项目树在 setting.gradle 设置文件中你可以使用一些列的方法配置构建项目树。分层和平面物理布局都支持。 分层布局Groovy1include &apos;project1&apos;, &apos;project2:child&apos;, &apos;project3:child1&apos; Kotlin1include(&quot;project1&quot;, &quot;project2:child&quot;, &quot;project3:child1&quot;) include 方法使用项目路径作为参数，假定项目路径与相对物理文件系统路径相等。例如 “project2:child” 默认对应的是相对于根目录的 “project2/child”。这也意味着包含路径 “services:hotels:api” 将创建3个项目: “services” “services:hotels” “services:hotels:api” 更详细的说明可以 DSL文档) 平面布局Groovy1includeFlat &apos;project3&apos;, &apos;project4&apos; Kotlin1includeFlat(&quot;project3&quot;, &quot;project4&quot;) includeFlat 也是目录名字作为参数。这些目录要和根项目目录同级。这些目录的位置在项目树中是根项目的子项目。 更改项目树的元素在设置文件中创建的多项目树由所谓的项目描述符组成。这些项目符号可以随时更改。可以通过下面这种方式访问描述符 查找项目树的元素 Groovy12println rootProject.nameprintln project(&apos;:projectA&apos;).name Kotlin12println(rootProject.name)println(project(&quot;:projectA&quot;).name) 使用这个描述符你可以一个项目的名字，项目目录和构建文件 更改项目树元素 Groovy123rootProject.name = &apos;main&apos;project(&apos;:projectA&apos;).projectDir = new File(settingsDir, &apos;../my-project-a&apos;)project(&apos;:projectA&apos;).buildFileName = &apos;projectA.gradle&apos; Kotlin123rootProject.name = &quot;main&quot;project(&quot;:projectA&quot;).projectDir = File(settingsDir, &quot;../my-project-a&quot;)project(&quot;:projectA&quot;).buildFileName = &quot;projectA.gradle&quot; 更详细的信息可以查看 ProjectDescriptor 类的 API 文档。 接收生命周期事件构建脚本可以接收生命周期构建进度的通知。 接收这些通知一般是两种形式 实现详细的监听接口 在发送通知时提供一个闭包来执行 项目评估事件可以在项目评估后马上接到事件通知 使用的是 Project.afterEvaluate 方法，传入一个闭包，Gradle会将评估的项目和状态传递进闭包里。Kotlin123afterEvaluate &#123; println(&quot;$&#123;project.getName()&#125; 评估结果：$&#123;state.getExecuted()&#125;&quot;) &#125; Groovy123afterEvaluate&#123; project,state-&gt; println &quot;$project 评估成功否：$&#123;state.failure==null&#125;&quot;&#125; 如果是在多项目构建里，可以在 allprojects 的闭包里使用，这样每个项目的评估事件就都接受到了Groovy12345allprojects&#123; afterEvaluate&#123; project,state-&gt; println &quot;$project 评估成功否：$&#123;state.failure==null&#125;&quot; &#125;&#125; 评估前的事件通知使用 Project.beforeEvaluate 照样是传入一个闭包，Gradle会将要评估的项目传递进闭包里 Groovy12345678910allprojects&#123; afterEvaluate&#123; project,state-&gt; println &quot;$project 评估成功否：$&#123;state.failure==null&#125;&quot; &#125; beforeEvaluate &#123; project -&gt; println &quot;开始评估 $project&quot; &#125;&#125; 这里列出了使用的 api文档。 Project Project.allprojects Project.afterEvaluate Project.beforeEvaluate ProjectState 任务任务被添加到项目Groovy123tasks.whenTaskAdded &#123; task -&gt; println &quot;$task 被添加到项目了。&quot;&#125; Kotlin 1234567tasks.whenTaskAdded &#123; extra[&quot;srcDir&quot;] = &quot;src/main/java&quot;&#125;val a by tasks.registeringprintln(&quot;source dir is $&#123;a.get().extra[&quot;srcDir&quot;]&#125;&quot;) 有向无环图填充完毕使用的是 TaskExecutionGraph.whenReady 方法 Groovy123456gradle.taskGraph.whenReady&#123; graph-&gt; println &quot;任务图准备好了：\n&quot; graph.allTasks.each &#123; print &quot;$it , &quot; &#125;&#125; TaskExecutionGraph 任务执行Groovy1234567891011121314151617181920task oktask broken(dependsOn: ok) &#123; doLast &#123; throw new RuntimeException(&apos;broken&apos;) &#125;&#125;gradle.taskGraph.beforeTask &#123; Task task -&gt; println &quot;executing $task ...&quot;&#125;gradle.taskGraph.afterTask &#123; Task task, TaskState state -&gt; if (state.failure) &#123; println &quot;FAILED&quot; &#125; else &#123; println &quot;done&quot; &#125;&#125; TaskExecutionGraph 这里留一个Gradle API 的查询地址 文档参考 https://docs.gradle.org/current/userguide/build_lifecycle.html https://proandroiddev.com/understanding-gradle-the-build-lifecycle-5118c1da613f]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle—创建简单的项目]]></title>
    <url>%2F2019%2F08%2F04%2Fgradle-basic-project%2F</url>
    <content type="text"><![CDATA[项目 &amp; 任务Gradle 的一切都是基于项目和任务的。 构建由一个或多个项目组成。项目的概念很抽象，它取决于你要用Gradle 做什么 。项目可以是 一个 Jar 库或者一个 web 程序。也可以是一个 zip 压缩包，也可以是将项目部署到生产环境等等； 一个项目是由一个或多个任务组成的；任务是构建工作的原子单位，最小的工作单元。例如：编译字节码，创建 jar 。 Hello World创建一个简单的任务，输出 Hello World!. Groovy 12345task hello&#123; doLast &#123; println &apos;Hello World.&apos; &#125;&#125; Kotlin 12345tasks.register(&quot;hello&quot;)&#123; doLast &#123; println (&quot;Hello World.&quot;) &#125;&#125; 输入命令 运行该任务 1gradle hello 创建一个简单的构建新建一个目录 使用 init 命令创建构建项目 Gradle 现在支持两种–Kotlin DSL 和 Groovy DSL .默认是 基于Groovy的，如果要使用 Kotlin 可以 使用 --dsl kotlin 1gradle init --dsl kotlin 会生成如下目录 其中 .gitigonre 是 git 忽略文件；.gradle 是 gradle 的一些信息。 需要我们关注的是下面这些文件 ├── gradle │ └── wrapper │ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── build.gradle.kts ├── gradlew ├── gradlew.bat └── settings.gradle.kts warpper 是 Gradle Wrapper 使用的目录 gradle-wrapper.jar 是执行 Gradle Wrapper 使用的 gradle-wrapper.properties 是 配置 Gradle Wrapper 属性的 build.gradle.kts 用于配置当前项目的Gradle构建脚本 gradlew 是 Unix 机器上的 执行脚本 gradlew.bat 是 window 上的执行脚本 settings.gradle.kts 是 用于配置Gradle构建的Gradle设置脚本 创建任务Gradle提供了通过Groovy或基于kotlin的DSL创建和配置任务的api。项目包含一组任务，每个任务执行一些基本操作。 Gradle提供了一个任务库，我们可以在自己的项目中配置这些任务。例如，有一个核心类型的 Copy 任务，它可以复制文件。下面我们就配置这个 任务来使用一下。 创建一个目录 src在 src 下创建一个文件名称任意，例如 myFile.txt。添加任意内容，例如 Hello World!在 配置脚本（build.gradle.kts） 添加 一个 Copy 类型的 copy 任务，从 src 目录复制到 dest 目录 Gradle 在执行时会自动创建 dest 目录。 Kotlin 1234567tasks.register&lt;Copy&gt;(&quot;copy&quot;)&#123; description = &quot;Copies sources to the dest directory&quot; group = &quot;Custom&quot; from(&quot;src&quot;) into(&quot;dest&quot;)&#125; Groovy 1234task copy(type: Copy, group: &quot;Custom&quot;, description: &quot;Copies sources to the dest directory&quot;) &#123; from &quot;src&quot; into &quot;dest&quot;&#125; description 和 group 都是可选的，可以随便你定义；也是可以省略的； 执行 copy 任务 1gradle copy 检查里面的 myFile.txt 是否复制完成。 使用插件Gradle 提供了大量的插件，在 Gradle 插件站 可以查到 今天使用 一个 base 插件 结合它的核心类型 Zip 任务，实现打包压缩包的任务。 使用 base 插件 Kotlin 12345plugins &#123; id(&quot;base&quot;)&#125;... rest of the build file ... Groovy12345plugins &#123; id &quot;base&quot;&#125;... rest of the build file ... 创建一个 zip 任务，扩展自 核心类型 Zip Kotlin1234567tasks.create&lt;Zip&gt;(&quot;zip&quot;) &#123; description = &quot;Archives sources in a zip file&quot; group = &quot;Archive&quot; from(&quot;src&quot;) setArchiveName(&quot;basic-demo-1.0.zip&quot;)&#125; Groovy1234task zip(type: Zip, group: &quot;Archive&quot;, description: &quot;Archives sources in a zip file&quot;) &#123; from &quot;src&quot; setArchiveName &quot;basic-demo-1.0.zip&quot;&#125; 执行 zip 1gradle zip 至此，一个简单的构建完成了。 分析构建过程Gradle 提供了一个基于 web的构建视图——构建扫描 在执行时 使用 –scan 选项或者明确使用构建扫描插件都可以免费的在 https://scans.gradle.com 创建一个扫描视图分析 1gradle zip --scan 在同一服务条款后会直接发送到 构建扫描的平台，复制下面的连接打开即可。 打开之后会有详细的项目构建分析]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gardle 是什么]]></title>
    <url>%2F2019%2F08%2F04%2FWhatIsGradle%2F</url>
    <content type="text"><![CDATA[写在前面的话，最近在系统的学习Gradle,本来想写一篇关于 Gradle 的介绍。但在官网发现了这篇关于 Gradle 的介绍，已经介绍的很好了，我就很直接翻译过来了。原文地址 https://docs.gradle.org/current/userguide/what_is_gradle.html Gradle 的几个优点Gradle 是开源的自动化构建工具，它的设计足够灵活，可以构建几乎任何软件。 它有以下几个显著的优点： 高性能Gradle 只运行那些输入和输出有改变的任务，从而避免无效的工作。另外，还可以通过缓存开关重用之前的任务输出（其他的机器上的缓存也是可以的）。Gradle还实现了许多其他优化，开发团队会持续不断地改进Gradle的性能。 基于 JVMGradle 是运行在 JDK上的，必须安装 JDK 才能运行。因为是运行在 JDK 上，这对于使用 Java 的用户是个额外的好处，可以在构建脚本中使用标准的 Java API，例如 自定义任务和插件，另外，因为是基于JDK的，它可以很好的跨平台运行。Gradle 并不限于构建JVM项目，甚至还附带了对于构建本地项目的支持。 约定Gradle 借鉴 Mavean 的做法，通过实现约定，使常见类型的项目(比如Java项目)易于构建。使用适当的插件可以很容易的为许多项目生成构建脚本。约定并没有什么限制，可以覆盖原有的约定，添加自定义任务等来实现自己的构建模型。 扩展性Gradle有很好的扩展性，可以添加定义自己的任务，覆盖已有的任务类型甚至定义自己的构建模型。Android 支持插件就是个很好的例子，在原有的基础上 增加了 flavor 和 buildType 约定。 IDE 支持常见的几个主流 IDE 都支持导入 Gradle项目，并可以与之交互，例如 Android studio,Eclipse ， IntelliJ IDEA，NetBeans等。Gradle 也有将项目文件加载进 Visual studio 的解决方案。 Insight构建扫描 提供了构建运行的大量信息，可以使用它去定位构建问题。它可以帮你定位构建性能问题。也可以把它分享给其他人，这样在交流问题的时候就很有用了。更详细的构建扫描可以查看这个文档 https://scans.gradle.com/?_ga=2.3508848.1142716506.1563790305-874993899.1553652374 Gradle 的五个重要概念Gradle 是一个灵活而强大的工具，在刚使用的时候很容易望而生畏。理解下面几个核心原则后就会觉得Gradle还是很好理解的，这会帮助你更好的使用Gradle。 Gradle 是一个通用构建工具因为Gradle 不对要做的构建或者如何构建做任何设想，所以Gradle几乎可以构建任务软件。 目前最大的限制就是依赖管理只支持 Maven 和 lvy 的编译库和文件。虽然有这样的限制，但是在用的时候也不麻烦，对常见类型的项目都是很容易构建的-例如 Java编译库，通过添加一层约定和插件预构建功能，可以将自己的约定和功能封装成一个插件，当然也可以发布这个插件。 Gradle 的核心是基于任务Gradle 将其构建建模为任务（工作单元）的有向无环图。意思是构建实际上是配置一组任务，并根据他们的依赖性创建一个有向无环图。一旦图创建完成，Gradle 将确定哪些任务以何种顺序运行，然后执行它们。下面是两个任务图，一个是简单的，一个是很详细的，任务的依赖关系通过箭头表示。 几乎所有的构建过程都可以建模为任务图,这也是Gradle如此灵活的原因之一。任务图可以通过插件和你自己的脚本定义,关于任务依赖性可以看文档 https://docs.gradle.org/current/userguide/tutorial_using_tasks.html#sec:task_dependencies 任务由三部分构成 操作 ——做一些工作，例如复制文件或者编译源码 输入 ——值，行为能够操作的值，文件或者目录。 输出 ——行为修改或产生的值，文件或目录 实际上根据现实情况以上都是可选的，例如在Gradle 的生命周期里任务就有的什么也没做，只是将多个任务组合起来。另外 Gradle 的增量编译是很强大可靠的，为了快速编译除非真的需要执行 clean 任务之外没必要执行 clean 操作。 你可以选择运行哪些任务。通过指定执行所需任务来节省时间，但也仅此而已。如果你想运行单元测试，就应该执行 test任务。如果您想打包应用程序，大多数构建都有相应的 assemble 任务。 最后一件事:Gradle的增量构建支持是健壮和可靠的，所以除非您真的想执行一个clean任务，否则通过避免clean任务来保持构建的快速运行 Gradle有几个固定的构建阶段理解Gradle在三个阶段评估和执行构建脚本是很重要的： 初始化 创建构建环境并确定哪些项目参与构建 配置为构建构造和配置任务图，根据用户想要运行的任务确定以何种顺序执行哪些任务。 执行 运行配置阶段结束时选择的任务。 这些阶段就构成了 Gradle 的生命周期。 与Apache Maven术语的比较：Gradle的构建阶段不像Maven的阶段。Maven的构建阶段将构建分为多个阶段。它们的作用类似于Gradle的任务图，尽管不那么灵活。Maven的构建生命周期概念与Gradle的生命周期任务大致相似。 好的设计构建脚本主要由声明式配置而非命令逻辑组成。在配置阶段可以理解地评估该配置。即便如此，许多此类构建还具有任务操作 - 例如通过doLast {}和doFirst {}块 - 在执行阶段进行评估。这很重要，因为在配置阶段评估的代码不会看到在执行阶段发生的更改。 配置阶段另一个重要的方面是每次构建都会对其中涉及的所有内容做评估。这也是为什么应该在配置阶段避免多余的工作。构建扫描可以帮助你识别这样的事情。 Gradle 的扩展方式如果Gradle 附带的构建逻辑无法满足我们的构建需求，而往往通常是这样。大部分的构建都有特定的需求，需要我们添加自己的构建逻辑。 Gradle 提供了以下几个主要方式去扩展它。 自定义任务类型 当 Gradle 本身的任务无法满足你的时候，你可以编写自己的任务类型。最好将编写的任务源文件放在 buildSrc 目录或者打包一个插件，然后你就可以像使用其他的Gradle 任务那样使用了。参考 https://docs.gradle.org/current/userguide/custom_tasks.html 自定义任务操作 你可以将自己的构建逻辑附加在任务的 开始之前 Task.doFirst() 和 结束之后 Task.doLast() 的方法里。 项目和任务的额外属性 Gradle 允许你为项目或者任务添加自己的属性，你可以在自定义行为或者其他构建逻辑中使用。额外的属性甚至可以应用于你没有显式创建的任务，比如由Gradle的核心插件创建的任务。 自定义约定 约定是一种简化构建的强大方法，这样用户就可以更容易地理解和使用它们。这可以在使用标准项目结构和命名约定(如Java构建)的构建中看到。 你可以编写自己的插件来提供约定——它们只需要为构建的相关方面配置默认值。 自定义模型 Gradle允许你引进除任务，文件和依赖配置之外的概念。可以在大多数语言插件中看到这一点，它们将源集的概念添加到构建中。对构建过程进行适当的建模可以极大地提高构建的易用性和效率。 脚本对API进行操作 构建脚本其实就是可执行代码。好的脚本描述了构建软件需要哪些步骤，而不是这些步骤应该怎么工作。那是定制任务和插件应该做的。 有一个常见的误解是Gradle的强大和灵活是因为它的脚本是代码，其实并不是。提供这种的能力的是底层模型和API。就像我们在实践中建议的那样，你不应该放太多命令式逻辑在脚本里。然而，将构建脚本视为可执行代码有一个方面是有用的:理解构建脚本的语法如何映射到Gradle的API。由Groovy DSL引用和 Javadocs组成的API文档列出了方法和属性，并引用了闭包和操作。这些在构建脚本上下文中意味着什么? 查看Groovy构建脚本入门，了解这个问题的答案，以便能够有效地使用API文档。 https://docs.gradle.org/current/userguide/groovy_build_script_primer.html#groovy_build_script_primer 因为Gradle运行在 JVM上，所以脚本中也可以使用标准的Java API，Groovy 脚本可以使用 Groovy API，Kotlin 脚本可以使用 Kotlin API。]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2使用攻略-基础部分]]></title>
    <url>%2F2018%2F09%2F26%2FDagger2-basic%2F</url>
    <content type="text"><![CDATA[在这篇文章中，我会介绍 什么是依赖注入，Dagger2是什么，解决什么问题以及基础注解的使用 依赖注入什么是 依赖。举个例子 有一个 A 类 它里面定了一个 B 类型的 属性 b; 这里 A 就依赖了 B； 12345678910public class A&#123; public A()&#123; b = new B(); b.print(); &#125; private B b;&#125; 这就意味着 A 离开 B 不能单独运行，也就是说 A 在哪里工作，B就会跟到哪里，A 无法离开 B 被复用。 这种情况下 A 就是 依赖者，B就是依赖。依赖者依赖于它的依赖。 两个相互使用的类称为耦合；耦合有强有弱。耦合总是有方向性的。可能 A 依赖 B，但 B 不一定依赖 A。 依赖类型 类 / 接口 依赖 属性 / 方法 依赖 间接 / 直接 依赖 硬编码依赖的不好在依赖者内部构建或者由依赖者寻找依赖这种就称为 硬编码依赖 降低复用性 不好测试 强耦合 增加维护成本 关于 什么是依赖，更详细的硬编码依赖的缺点这部分，更详细的可以参考这篇文章，我就是从篇文章学习来的。 https://medium.com/@harivigneshjayapalan/dagger-2-for-android-beginners-introduction-be6580cb3edb 什么是依赖注入依赖注入：一个对象提供另一个对象的依赖的技术； 依赖是个能被使用的对象（一个服务）；注入是将依赖传递给要使用它的对象（客户端 / 依赖者）。 服务作为客户端的一部分。将服务传递给客户端而不是客户端构建或者寻找服务，这是模式（依赖注入）的基本要求。 换句话说： 依赖作为依赖者的一部分。将依赖传递给依赖者而不是由依赖者构建或者寻找依赖，这是依赖注入的基本要求。 也就是说 依赖从来原来的由依赖者构建，改为现在由外部注入，也可以称为 控制反转。 这样的好处是很明显的，提高可测试性，解偶，降低维护成本等等。 更详细的解释 可以看一下这篇文章，解释的超级棒，如果你看过权力的游戏，就更棒了。 https://medium.com/@harivigneshjayapalan/dagger-2-for-android-beginners-di-part-i-f5cc4e5ad878 Dagger2 就是 Android 平台的一个依赖注入框架，它现在由 Google 维护开发。 Dagger2 是编译时框架，会在编译时根据你的注解配置生成需要的代码。 下面是我对 Dagger2 中的常用注解的理解。理解了这些注解的意思和作用，基本就学会了 Dagger2 的基本用法了。 常用注解@Inject这个注解有两个作用： 修饰需要注入的属性，Dagger2 会自动注入 修饰被注入的类的构造方法上；Dagger2 会在需要的时候通过这个注解找到构造函数自动构造对象注入 12345678910111213public class MainActivity extends AppCompatActivity &#123; @Inject DBManager dbManager;&#125;public class DBManager &#123; @Inject public DBManager()&#123;&#125;&#125; @Component这个注解的作用 是连接提供依赖和注入依赖的。相当与一个注射器的角色，将依赖注入到需要的地方。 刚刚通过上面的 @Inject 注解 了 提供依赖的构造方法 和 需要注入的属性，而这样还是不够的，需要使用 @Comnponent 连接起来。 创建一个接口，并定义一个方法，定义要往哪里注入；在编译时期 Dagger2 就会自动生成这个接口的实现类 并以 Dagger 开头。 还可以定义 向外提供实例的方法；Dagger2 都会在编译时期生成相应的代码。 下面是 示例12345678910111213141516171819202122232425@Component()public interface MainComponent &#123; void inject(MainActivity mainActivity); DBManager getDBManager();&#125;// 在需要被注入的类中注入 例如：public class MainActivity extends AppCompatActivity &#123; @Inject DBManager dbManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 注入 DaggerMainComponent.create().inject(this); &#125;&#125; @Component 有两个属性 modules and dependencies ； modules 的作用是引用 Module 的，下面 @Module 会继续说 dependencies 的作用是 引用其他 Component 使用的，相当于 把其他的 Component 当作组件一样引用过来； @SubComponent顾名思义 就是 Comnponent 的儿子，它也表示一个注射器的角色，不过它可以继承 Component的全部 属性。 Dagger2 不会生成 Dagger开头的 DaggerSubComponent 这种类，所以，SubComponent 需要在 Component 注册和维护。这样的也好统一管理维护，Dagger2 会在生成 Component的时候自动实现生成在内定义的方法。 举个例子 我的 ApplicationComponent 是个全局单例的，有 NetModule， APPModule,等等很多全局性依赖，如果我的 Activity 的注射器 使用 @SubComnponent ，那么就可以使用Application的全部依赖。 1234567891011121314151617181920212223242526272829@ActivityScoped@Subcomponent(modules = MainModule.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125;@APPScoped@Component(modules = &#123;APPModule.class, APIModule.class&#125; )public interface APPComponent &#123; MainComponent plus(MainModule module); SecondComponent plus(SecondModule module); &#125;//注入 DaggerAPPComponent.builder() .aPPModule(new APPModule(getApplication())) .build() .plus(new SecondModule()) .inject(this); 当然还有另外一种方法不用 @SubComponent，使用 Component 并使用 denpendencies 引用上 ApplicationComponent 这样就相当于将 ApplicationComponent 组合进来。 @Module &amp;&amp; @Provides@Module 这个注解用来标注提供依赖的工厂。对的，工厂，我是这么理解的。 @Provides 这个注解用在提供定义提供依赖的方法上，表示向外提供依赖。方法的返回类型就是提供的依赖类型。 前面提到的 @Inject 可以在注解在构造函数以用来提供依赖；而在 @Inject 不能满足需要的时候这个就派上用场了。 例如 我注入一个 字符串，数字或一个 第三方依赖的对象 例如 Retrofit ,@Inject 已经满足不了啦。 这个时候可以创建一个类 专门用来提供这些依赖，并使用 @Module 注解，然后在 Component 的属性 modules 引用上就可以使用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 需要注入的 Activitypublic class ThirdActivity extends AppCompatActivity &#123; @Inject String name; @Inject int age; @Inject OkHttpClient client; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); DaggerThirdComponent.create().inject(this); Log.e(ThirdActivity.class.getSimpleName(), "onCreate: name-"+name+";age-"+age+";client-"+client); &#125;&#125;// 提供依赖的 工厂@Modulepublic class ThirdModule &#123; @Provides public String provideName()&#123; return "skymxc"; &#125; @Provides public int provideAge()&#123; return 24; &#125; @Provides public OkHttpClient provideOkHttpClient()&#123; OkHttpClient client = new OkHttpClient.Builder().build(); return client; &#125;&#125;// 连接 依赖和注入方 ,在这里引用 依赖提供方。@Component(modules = ThirdModule.class)public interface ThirdComponent &#123; void inject(ThirdActivity activity);&#125; @Named在依赖迷失时给出方向。 解释一下 依赖迷失： 依旧是上面那个例子，现在 都是根据返回值类型来注入的，现在都是不同的类型所以还没有出现迷失的情况；现在我如果要加上 地址 属性；如下 123456789101112131415161718192021222324252627// activity内 @Inject String name; @Inject int age; @Inject OkHttpClient client; @Inject String address; // module 中 @Provides public String provideName()&#123; return "skymxc"; &#125; @Provides public int provideAge()&#123; return 24; &#125; public String provideAddress()&#123; return "北京"; &#125; 这个时候 在 module 中 有两个返回 String 类型的 方法，Dagger2 这个时候就不知道注入哪一个了，所以就会出现 依赖迷失 的情况； 123错误: [Dagger/DuplicateBindings] java.lang.String is bound multiple times:@Provides String com.skymxc.example.dagger2.di.module.ThirdModule.provideAddress()@Provides String com.skymxc.example.dagger2.di.module.ThirdModule.provideName() 简单的解决方法就是在 属性和提供依赖上 加上 @Named 注解 123456789101112131415161718192021222324@Named("name")@Providespublic String provideName()&#123; return "skymxc";&#125; @Provides@Named("address")public String provideAddress()&#123; return "北京";&#125;// 在 属性上也加上 @Named("name")@Inject String name;@Named("address")@Inject String address; 这样就可以解决了 依赖迷失。 @Qualifier@Named 的元注解，解决依赖迷失的大 Boss；看一下 @Named 的源码,@Named 就是被 @Qualifier 注解的。 12345678@Qualifier@Documented@Retention(RUNTIME)public @interface Named &#123; /** The name. */ String value() default "";&#125; 如果怕通过 @Named 写字符串的方式容易出错就可以通过 @Qualifier 自定义注解来实现。 下面举个例子，再加一个 身高属性。定义两个注解来区分 @Age and @Height. 1234567891011121314151617181920212223242526272829303132@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface Height &#123;&#125;@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface Age &#123;&#125;//在 module 和 属性上使用 @Age @Provides public int provideAge()&#123; return 24; &#125; @Provides @Height public int provideHeight()&#123; return 175; &#125; @Age @Inject int age; @Height @Inject int height; @Singleton 配合 @Component 实现 范围内单例 @Singleton 必须和 @Component 配合才能实现单例，而且只能保证在 @Component 范围内单例，如果要实现全局单例，就必须要保证 @Component 的实例在全局范围内只有一个，类似 Application 。 举个例子，我要 DBManager 在全局单例，需要以下几个步骤 在 DBManger 上使用 @Singleton 或者 在 @Provides 修饰的方法上加。 然后在 AppComponent 也加上（） 在 Application 中 获取 AppComponent 实例，让其全局唯一。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 1.DBManager 标注 @Singleton@Singletonpublic class DBManager &#123; @Inject public DBManager()&#123;&#125;&#125;// 2.@Singleton@Component(modules = &#123;APPModule.class, APIModule.class&#125;)public interface APPComponent &#123; MainComponent plus(MainModule module); SecondComponent plus(SecondModule module);//可有可无 为了测试 DBManager getDBManager();&#125;//3. 在 Application 中获取 实例，并保证唯一实例public class MApplication extends Application &#123; private APPComponent appComponent; @Override public void onCreate() &#123; super.onCreate(); appComponent = DaggerAPPComponent.builder() .aPPModule(new APPModule(this)) .build(); &#125; public APPComponent getAppComponent() &#123; return appComponent; &#125;&#125;// 测试，在 MainActivity 注入两个。 public class MainActivity extends AppCompatActivity &#123; @Inject DBManager dbManager; @Inject DBManager dbManager1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //使用 Application 获取 AppComponent ((MApplication)getApplication()).getAppComponent() .plus(new MainModule()) .inject(this); Log.e(MainActivity.class.getSimpleName(), "onCreate: appdb--&gt;"+((MApplication)getApplication()).getAppComponent().getDBManager().hashCode()); //是否是全局范围内单例 if (dbManager==dbManager1) &#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager-sintleton-&gt;"+dbManager.hashCode()); &#125;else&#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager:"+dbManager.hashCode()); Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager1:"+dbManager1.hashCode()); &#125; &#125;&#125;// 在 SecondActivity 注入两个看看是否和 Main 中的是一个实例public class SecondActivity extends AppCompatActivity &#123; @Inject DBManager dbManager; @Inject DBManager dbManager1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); ((MApplication)getApplication()).getAppComponent() .plus(new SecondModule()) .inject(this); if (dbManager==dbManager1) &#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager-singleton-&gt;"+dbManager.hashCode()); &#125;else&#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager:"+dbManager.hashCode()); Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager1:"+dbManager1.hashCode()); &#125; &#125;&#125; 测试结果必须是全局唯一单例，看一下 log 1234E/MainActivity: onCreate: appdb--&gt;192114699 onCreate: dbmanager-sintleton-&gt;192114699 E/SecondActivity: onCreate: dbmanager-singleton-&gt;192114699 @Singleton 的作用域 始终是跟随所在的 Component 的实例的，如果超出它的范围就无法保证单例。 就拿上个例子举例，如果每次 在 Activity 注入的时候 不从 Application 获取实例而是每次都是使用 DaggerAppComponent 创建一个新的 实例 ，那么就无法保证两个 Activity 内的 DBManager 都是一个实例了，因为每个 Activity 都是获取新的 AppComponent 的实例，它的作用范围只能在单个实例内。 下面我实现一个 只在 Activity 范围实现单例的 例子，就是把上面的代码改改，在Activity注入的时候 创建新的 Component 实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SecondActivity extends AppCompatActivity &#123; @Inject DBManager dbManager; @Inject DBManager dbManager1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); // ((MApplication)getApplication()).getAppComponent() // .plus(new SecondModule()) // .inject(this); // 获取新实例 DaggerAPPComponent.builder().aPPModule(new APPModule(getApplication())).build().plus(new MainModule()).inject(this); if (dbManager==dbManager1) &#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager-singleton-&gt;"+dbManager.hashCode()); &#125;else&#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager:"+dbManager.hashCode()); Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager1:"+dbManager1.hashCode()); &#125; &#125;&#125;public class MainActivity extends AppCompatActivity &#123; @Inject DBManager dbManager; @Inject DBManager dbManager1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 获取新实例 DaggerAPPComponent.builder().aPPModule(new APPModule(getApplication())).build().plus(new MainModule()).inject(this); if (dbManager==dbManager1) &#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager-sintleton-&gt;"+dbManager.hashCode()); &#125;else&#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager:"+dbManager.hashCode()); Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager1:"+dbManager1.hashCode()); &#125; &#125;&#125;// log 09-23 00:02:52.937 E/DBHelper: DBHelper: 09-23 00:02:52.937 E/MainActivity: onCreate: dbmanager-sintleton-&gt;11528970909-23 00:02:57.097 E/DBHelper: DBHelper: 09-23 00:02:57.097 E/SecondActivity: onCreate: dbmanager-singleton-&gt;64826129 总结 ： Dagger2 实现单例要 @Singleton 和 @Component || @SubComponent 配合使用，只能实现范围内(实例内)单例，所以范围要控制好。只要范围控制好，随意 Activity 或者 Application 范围。 @Scope作用域 上面说到的 @Singleton 就是它的默认实现，也是唯一一个默认实现。 看一下 @Singleton 的源码 123456789/** * Identifies a type that the injector only instantiates once. Not inherited. * * @see javax.inject.Scope @Scope */@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; @Singleton 能够实现范围内单例 主要是 @Scope 在起作用。默认实现叫 Singleton 也是为了更好的理解。 我们可以根据自己的情况，自定义我们自己的依赖作用域，就像我们上面说的 跟随 Application 生命周期的，跟随 Activity 生命周期的，或者 User 生命周期的等等。 举个例子 我们定义俩个 AppScoped, ActivityScoped. 分别让我们的依赖实现 全局单例和Activity内单例 123456789101112131415161718/** * APP全局单例 * 此注解使用的 Component 要全局范围内唯一 ，不然无法实现全局单例 */@Scope@Retention(RetentionPolicy.RUNTIME)public @interface APPScoped &#123;&#125;/** * activity 内单例 * 使用 此注解的Component 生命周期要跟随 Activity 的生命周期。 */@Scope@Retention(RetentionPolicy.RUNTIME)public @interface ActivityScoped &#123;&#125; 创建一个类 SingletonObj 让其在 Activity范围内 单例, 让 DBManager 全局单例 12345678910111213141516171819@ActivityScopedpublic class SingletonObj &#123; @Inject public SingletonObj()&#123;&#125;&#125;/** * */@APPScopedpublic class DBManager &#123; @Inject DBHelper helper; @Inject public DBManager()&#123;&#125;&#125; 定义 Component ，注意 AppScoped , ActivityScoped 的位置 12345678910@APPScoped@Component(modules = &#123; APIModule.class,APPModule.class&#125;)public interface APPComponent &#123; MainComponent plus(MainModule module); SecondComponent plus(SecondModule module); DBManager getDBManager();&#125; 123456@ActivityScoped@Subcomponent(modules = MainModule.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 12345@ActivityScoped@Subcomponent(modules = SecondModule.class)public interface SecondComponent &#123; void inject(SecondActivity activity);&#125; 获取 Component 并开始注入 在 Application 获取 AppComponent 的实例 ，并保持唯一。1234567891011121314151617public class MApplication extends Application &#123; private APPComponent appComponent; @Override public void onCreate() &#123; super.onCreate(); appComponent = DaggerAPPComponent.builder() .aPPModule(new APPModule(this)) .build(); &#125; public APPComponent getAppComponent() &#123; return appComponent; &#125;&#125; 在 MainActivity 获取到 MainComponent 的实例 并注入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Inject DBManager dbManager; @Inject DBManager dbManager1; @Inject SingletonObj mainSingleton; @Inject SingletonObj mainSingleton1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.bt_to_second).setOnClickListener(this); findViewById(R.id.bt_to_third).setOnClickListener(this); ((MApplication)getApplication()).getAppComponent() .plus(new MainModule()) .inject(this); Log.e(MainActivity.class.getSimpleName(), "onCreate: appdb--&gt;"+((MApplication)getApplication()).getAppComponent().getDBManager().hashCode()); //查看 是否和 second的一致，是否是全局范围内单例 if (dbManager==dbManager1) &#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager-sintleton-&gt;"+dbManager.hashCode()); &#125;else&#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager:"+dbManager.hashCode()); Log.e(MainActivity.class.getSimpleName(), "onCreate: dbmanager1:"+dbManager1.hashCode()); &#125; //主要看 这个 和 second的是否一致，是否是activity范围内单例。 if (mainSingleton==mainSingleton1)&#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: main-singleton-&gt;"+mainSingleton.hashCode()); &#125;else&#123; Log.e(MainActivity.class.getSimpleName(), "onCreate: main:"+mainSingleton.hashCode()); Log.e(MainActivity.class.getSimpleName(), "onCreate: main1:"+mainSingleton1.hashCode()); &#125; &#125; &#125; 在 SecondActivity 获取到 SecondComponent 的实例 并注入 ，这里就可以看出来 是否是 范围内单例。 12345678910111213141516171819202122232425262728293031323334353637383940public class SecondActivity extends AppCompatActivity &#123; @Inject DBManager dbManager; @Inject DBManager dbManager1; @Inject SingletonObj mainSingleton; @Inject SingletonObj mainSingleton1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); ((MApplication)getApplication()).getAppComponent() .plus(new SecondModule()) .inject(this); if (dbManager==dbManager1) &#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager-singleton-&gt;"+dbManager.hashCode()); &#125;else&#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager:"+dbManager.hashCode()); Log.e(SecondActivity.class.getSimpleName(), "onCreate: dbmanager1:"+dbManager1.hashCode()); &#125; if (mainSingleton==mainSingleton1)&#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: main-singleton&gt;"+mainSingleton.hashCode()); &#125;else&#123; Log.e(SecondActivity.class.getSimpleName(), "onCreate: main:"+mainSingleton.hashCode()); Log.e(SecondActivity.class.getSimpleName(), "onCreate: main1:"+mainSingleton1.hashCode()); &#125; &#125;&#125; log 可以看出 范围内单例 123456E/MainActivity: onCreate: appdb--&gt;229426894 onCreate: dbmanager-sintleton-&gt;229426894 onCreate: main-singleton-&gt;142055919 E/SecondActivity: onCreate: dbmanager-singleton-&gt;229426894 onCreate: main-singleton&gt;241744847 总结 ：我们可以通过 @Scope 随意自定义我们自己的作用域，当然不是说我们定义了 ActivityScoped 他就能保证 Activity内单例了，要配合 Component 范围并用对位置。 这些Demo 的代码 我放在了 Github 基础部分就先介绍这些吧，接下来我会继续 Dagger2-Android 的分享。 参考资料 https://google.github.io/dagger/ https://medium.com/@harivigneshjayapalan/dagger-2-for-android-beginners-introduction-be6580cb3edb https://proandroiddev.com/how-to-dagger-2-with-android-part-1-18b5b941453f https://blog.csdn.net/briblue/article/details/75578459 https://juejin.im/entry/593cee56ac502e006b3dc9c2 https://medium.com/@harivigneshjayapalan/dagger-2-for-android-beginners-dagger-2-part-i-f2de5564ab25]]></content>
      <categories>
        <category>Android</category>
        <category>Dagger2</category>
      </categories>
      <tags>
        <tag>Dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程基础操作]]></title>
    <url>%2F2018%2F06%2F24%2Fthread-basic%2F</url>
    <content type="text"><![CDATA[进程和线程的概念 进程 比较好理解,打开Windows 的任务管理器进程页里的一个个 exe 就可以理解为一个进程。 线程可以理解是在进程中独立运行的子任务 ，具体见百度百科 https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B 使用线程创建一个线程主要有两种方式 继承 Thread 类 实现 Runnable 接口 Note: Thread 类其实是实现了 Runnable 接口的。使用继承 Thread 的方式创建线程时，最大的局限就是不支持多继承，因为 Java 是单根继承，为了支持多继承，完全可以实现 Runnable 接口的方法。两种方式在工作时的性质是一样的，没有本质的区别。 继承 Thread 的方式123456789101112public class MyThreadWithThread extends Thread &#123; public MyThreadWithThread() &#123; super(); setName(this.getClass().getSimpleName()); &#125; @Override public void run() &#123; System.out.println("--&gt;"+this.getName()); &#125;&#125; 实现 Runnable 的方式1234567public class MyThreadWithRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("---&gt;"+this.getClass().getSimpleName()); &#125;&#125; 启动线程1234567891011public class Test &#123; public static void main(String[] args)&#123; MyThreadWithThread threadWithThread = new MyThreadWithThread(); MyThreadWithRunnable threadWithRunnable = new MyThreadWithRunnable(); Thread thread = new Thread(threadWithRunnable); System.out.println("---begin"); thread.start(); threadWithThread.start(); System.out.println("---stop"); &#125;&#125; Note: 如果多次调用 start() 方法 会出现异常 Exception in thread &quot;main&quot; java.lang.IllegalThreadStateExceptionConsole 1234---begin---stop--&gt;MyThreadWithThread---&gt;MyThreadWithRunnable 通过结果可以看到 代码的结果和代码的顺序是不一样的。 使用多线程时，代码的运行结果与代码执行顺序或者调用顺序是无关的。 线程是一个子任务，CPU 以不确定的方式，或者说以随机的时间来调用线程中的 run 方法。 数据共享和非线程安全线程共享数据的情况就是多个线程访问同一个变量。多个线程在访问同一个变量的时候会出现非线程安全问题。 非线程安全主要是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。 可以通过给代码上锁的方式解决这个问题。在方法上加上 synchronized 关键字。 当一个线程调用一个方法前会先判断这个方法有没有上锁，如果上锁了说明有其他线程正在调用此方法。必须等其他线程对run()方法调用结束后才能执行run()。在等待的同时线程会不断尝试去拿这个锁，而且是多个线程同时去拿，谁拿到谁 执行。这样就实现了排队调用run()方法。 synchronized 可以在任意对象及方法上枷锁，而加锁的这段代码成为“互斥区”或者“临界区”。 常用方法 Thread.currentThread() 当前代码运行所在的线程 getName() 当前线程的名字 isAlive() 测试当前线程是否处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就是认为线程是“存活”的。 sleep() 作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个正在执行的线程就是 “Thread.currentThread()” 返回的线程 getId() 作用是放回线程唯一id 停止线程停止线程意味着在线程处理完任务之前停掉正在做的操作，也就是放弃当前的操作。停止一个线程可以使用 Thread.stop()方法，但最好不用它，虽然它可以停止一个正在运行的线程，但是这个方法是不安全的，而且已经被废弃。 大多数停止一个线程的操作使用 Thread.interrupt()方法，尽管方法的名称是“停止，终止”的意思，当这个方法不会终止一个正在运行的线程，还需要加入一个判断才能完成线程的停止。 Java中有三种方法可以停止正在运行的线程 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止 使用 stop 方法强行终止线程，但是不推荐使用，因为 stop 和 suspend 及 resume 一样，都是作废过期的方法，使用它们产生不可预料的后果 使用 interrupt 停止线程 判断线程是否停止 Thread.interrupted()（静态方法） 作用是测试当前线程是否已经中断 执行后将停止状态清除为false isInterrupted() 作用是测试线程是否已经中断。执行后不会清除状态标志。 先看一下 Thread.interrupted() 1234567891011121314151617181920/** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #isInterrupted() * @revised 6.0 */public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125; 测试当前线程是否已经中断。 线程的 中断状态 通过此方法清除。换句话说就是，这个方法入如果连续两次调用，第二次将会返回 false（在第一次调用已清除了其中断状态后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外） 线程中断被忽略是因为没有在存活的时候中断，这个方法将会返回 false 如果当前线程已经被中断了 将会返回 true 再看一下 isInterrupted 12345678910111213141516/** * Tests whether this thread has been interrupted. The &lt;i&gt;interrupted * status&lt;/i&gt; of the thread is unaffected by this method. * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #interrupted() * @revised 6.0 */public boolean isInterrupted() &#123; return isInterrupted(false);&#125; 测试该线程是否已经中断。线程的中断状态不受此方法影响。 可以看到两个方法的源码都是调用了 isInterrupted() 不同的是 interrupted() 是先调用 currentThread()获取到当前代码运行所在的线程。然后让当前线程调用isInterrupted()。而 isInterrupted 这是直接调用，所以判断的是这个实例线程的状态。 再看一下 isInterrupted() 123456/** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */private native boolean isInterrupted(boolean ClearInterrupted); 测试某些线程是否被中断。中断状态根据传递的ClearInterrupted的值决定重置或不重置。 Thread.interrupted() 传入了 false 所以会重置中断状态。 异常法停止这里的所谓异常法停止就是对你想中断的线程调用interrupt()打上中断标识。在你执行操作的线程中一定要在某个地方检测 中断状态 如果中断状态为 true 了就停止操作。 12345678910111213141516171819202122232425public class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName()+"---》begin"); for (int i=0;i&lt;500000;i++)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); if (this.isInterrupted())&#123; System.out.println("检测到当前线程实例中断标志("+this.getName()+")--&gt;"+this.isInterrupted()); throw new InterruptedException(); &#125; &#125; System.out.println("for循环后执行-当前线程实例（"+this.getName()+"）中断标识-&gt;"+this.isInterrupted()+";当前代码运行线程("+Thread.currentThread().getName()+")中断标志--》"+Thread.interrupted()); System.out.println(Thread.currentThread().getName()+"----end---&gt;"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println("异常法中断--》"+e.getMessage()); &#125; &#125;&#125; 测试 12345678910111213public class Test &#123; public static void main(String[]args) throws InterruptedException &#123; MyThread myThread =new MyThread("myThread"); myThread.start(); Thread.sleep(50); System.out.println("中断myThread"); myThread.interrupt(); Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+" ====end---&gt;"+myThread.isInterrupted()); &#125; Console 12345678910111213141516171819202122.....myThread--&gt;7665myThread--&gt;7666myThread--&gt;7667myThread--&gt;7668myThread--&gt;7669myThread--&gt;7670myThread--&gt;7671myThread--&gt;7672myThread--&gt;7673myThread--&gt;7674myThread--&gt;7675myThread--&gt;7676中断myThreadmyThread--&gt;7677检测到当前线程实例中断标志(myThread)--&gt;true异常法中断--》nulljava.lang.InterruptedException at com.skymxc.example.multithreading.stop.MyThread.run(MyThread.java:17)main ====end---&gt;falseProcess finished with exit code 0 当然，这里是用的抛出异常的方法强行中断。也可使用 break 然后继续一个收尾工作。 关于 stop（）方法 参考这篇文章 https://blog.csdn.net/jiangwei0910410003/article/details/19900007 暂停线程暂停线程意味着还可以恢复线程的执行，在 Java 中使用 suspend() 暂停线程的执行，使用 ressume() 恢复线程的执行。 用一个例子看看这两个方法怎么用 123456789101112131415161718192021222324252627282930public class CountThread extends Thread &#123; public CountThread() &#123; super("countThread"); &#125; private int i; public int getI() &#123; return i; &#125; public void setI(int i) &#123; this.i = i; &#125; @Override public void run() &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss.SSS"); while (true)&#123; i++;// System.out.println(dateFormat.format(new Date())+"---&gt;"+i++); if (this.isInterrupted())&#123; break; &#125; &#125; System.out.println(dateFormat.format(new Date())+"---停止--》"+this.getName()); &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132public class SuspendTest &#123; public static void main(String[]args) throws InterruptedException &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss.SSS"); CountThread countThread = new CountThread(); countThread.start(); Thread.sleep(1000); //阶段 A 1000ms 后 countThread.suspend(); System.out.println( dateFormat.format(new Date())+"--A-&gt;"+countThread.getI()+";isInterrupted--&gt;"+countThread.isInterrupted()); Thread.sleep(1000); //阶段B 1000ms 后 System.out.println( dateFormat.format(new Date())+"--B-&gt;"+countThread.getI()+";isInterrupted--&gt;"+countThread.isInterrupted()); countThread.resume(); Thread.sleep(1000); //阶段C countThread.suspend(); System.out.println( dateFormat.format(new Date())+"--C-&gt;"+countThread.getI()+";isInterrupted--&gt;"+countThread.isInterrupted()); Thread.sleep(1000); countThread.resume(); Thread.sleep(1000); countThread.interrupt(); //阶段D Thread.sleep(1000); System.out.println( dateFormat.format(new Date())+"--D-&gt;"+countThread.getI()+";isInterrupted--&gt;"+countThread.isInterrupted()); &#125;&#125; Console 123456717:48:11.934--A-&gt;516318612;isInterrupted--&gt;false17:48:12.935--B-&gt;516318612;isInterrupted--&gt;false17:48:13.935--C-&gt;1043644966;isInterrupted--&gt;false17:48:15.935---停止--》countThread17:48:16.935--D-&gt;1565065219;isInterrupted--&gt;falseProcess finished with exit code 0 确实达到了暂停和恢复的目的。 suspend()和 resmue() 的缺点—-独占如果你在上面的 CountThread 中打印 i 你就会发现一个问题 在main 线程的 打印都没出来，而且程序已知在运行，没有结束，也没有log。 先看一下 println() 的实现 12345678910111213/** * Prints a String and then terminate the line. This method behaves as * though it invokes &lt;code&gt;&#123;@link #print(String)&#125;&lt;/code&gt; and then * &lt;code&gt;&#123;@link #println()&#125;&lt;/code&gt;. * * @param x The &lt;code&gt;String&lt;/code&gt; to be printed. */ public void println(String x) &#123; synchronized (this) &#123; print(x); newLine(); &#125; &#125; 可以看到方法里 使用 synchronized 锁住了当前对象。 在例子中我们让 countThread 暂停，虽然它确实暂停了，但是没有释放锁，且一直在占着，这样的结果就是我们在main 线程的 打印一直在等锁，且一直等不到。 虽然 suspend()方法 已经被废弃，但是了解它为什么被废弃还是很有意义的。 suspend()和 resmue() 的缺点—-不同步因为它的独占 所以无法使用 synchronized ，也就无法保证数据同步 priority 线程的优先级优先级较高的线程得到的CPU资源较多，也就是CPU优先执行级别较高的线程对象中的任务。 使用 setPriority() 方法设置线程优先级 12345678910111213public final void setPriority(int newPriority) &#123; ThreadGroup g; checkAccess(); if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123; throw new IllegalArgumentException(); &#125; if((g = getThreadGroup()) != null) &#123; if (newPriority &gt; g.getMaxPriority()) &#123; newPriority = g.getMaxPriority(); &#125; setPriority0(priority = newPriority); &#125; &#125; 优先级 分为 1 ~ 10 这10个等级。如果不在范围内就会抛出异常。 JDK预设了三个优先级的值：1234567891011121314/** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 线程优先级的继承特性在 Java 中，线程的优先级具有继承性，例如A线程启动B线程，则B线程的优先级与A是一样的。 优先级具有规则性 CPU会尽量将执行资源让给优先级较高的线程。 优先级具有随机性 虽然CPU会尽量让优先级高的线程得到更多的资源，优先级高的线程不一定每一次都先执行完 run() 方法中的任务，不要把优先级和执行顺序及结果挂钩。 end]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proguard 常用规则]]></title>
    <url>%2F2018%2F06%2F03%2FProguard%2F</url>
    <content type="text"><![CDATA[为了决定哪些代码要被保留哪些代码要出丢弃和混淆，必须指定入口点。这些入口点通常是 main方法，activity，service等。 在压缩阶段，Proguard从这些入口点开始递归确定哪些类或类成员要被使用，其余的都会被丢弃。 在优化阶段，ProGuard进一步优化代码。在其他优化中，可以将不是入口点的类和方法设为私有，静态或最终，可以删除未使用的参数，并且可以内联一些方法。 在混淆阶段，ProGuard会重新命名不属于入口点的类和类成员。在整个过程中，保持入口点确保它们仍然可以通过其原始名称访问。 检查 Proguard结果为了避免引入 bug 我们有必要对 结果进行检查。 在Android中，开启了混淆构建会在 /build/outputs/mapping/ 目录下会输出以下文件： dump.txt 描述APK文件中所有类的内部结构 mapping.txt 提供混淆前后类、方法、类成员等的对照表 seeds.txt 列出没有被混淆的类和成员 usage.txt 列出被移除的代码 我们可以根据 seeds.txt 文件检查未被混淆的类和成员中是否已包含所有期望保留的，再根据 usage.txt 文件查看是否有被误移除的代码。 过滤器 ProGuard为配置的许多不同方面提供了过滤器选项：文件名称，目录，类别，软件包，属性，优化等。 过滤器是可以包含通配符的逗号分隔名称列表。只有与列表中的项目匹配的名称才会通过过滤器。受支持的通配符取决于使用过滤器的名称类型，但以下通配符是通用的： ? 匹配名称中的任何单个字符。 * 匹配不包含包分隔符或目录分隔符的名称的任何部分 ** 匹配名称的任何部分，可能包含任意数量的包分隔符或目录分隔符。 此外，名称前可以加上否定感叹号’！’排除名称与进一步尝试匹配后续名称。 因此，如果名称与过滤器中的某个项目相匹配，则会立即接受或拒绝该项目，具体取决于项目是否具有否定符。 如果名称与项目不匹配，则会针对下一个项目进行测试，依此类推。 它如果与任何项目不匹配，则根据最后一项是否具有否定符而被接受或拒绝。 如，”!foobar，*.bar” 匹配除了foobar之外的所有以bar结尾的名称。 下面以过滤文件具体举例。 文件过滤器 像通用过滤器一样，文件过滤器是逗号分隔的文件名列表，可以包含通配符。只有具有匹配文件名的文件被读取（在输入的情况下），或者被写入（在输出的情况下）。支持以下通配符： ? 匹配文件名字中的任何单个字符 * 匹配不包含目录分隔符的文件名的任何部分。 ** 匹配文件名的任何部分，可以包含任意数目的目录分隔符。 例如 “java/**.class ,javax/**.class” 可以匹配 java和javax目录下所有的 class 文件。 此外，文件名前面可能带有感叹号’！’将文件名排除在与后续文件名匹配上。 例如 “!**.gif,images/**“ 匹配images目录下所有除了 gif 的文件 关于更详细的用法 可以查看官方文档 https://www.guardsquare.com/en/proguard/manual/examples#filtering keep-keep [,modifier,…] class specification 指定类和类成员（字段，方法）作为入口点被保留。 例如，为了保留一个程序，你要指定Main方法和类。为了保留一个库，你应该指定所有被公开访问的元素。 保留 main 类和 main 方法 12345678910111213141516171819202122-keep public class com.example.MyMain &#123; public static void main(java.lang.String[]); &#125;``` - 保留所有被公开访问的元素```proguard-keep public class * &#123; public protected *; &#125; Note:如果你只保留了类，没有保留类成员，那么你的类成员将不会被保留 例如 有一个实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Product implements Serializable &#123; public static final int A = 1; public static final int B = 2; private String name; private String url; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125;&#125; 规则配置如下 1234# 保留 Product类-keep class cn.sintoon.camera.Product usage.txt文件中有以下内容 ，可以看到 类中的成员全部被移除了 123456789101112131415161718cn.sintoon.camera.Product: public static final int A public static final int B private java.lang.String name private java.lang.String url 16:16:public java.lang.String getName() 20:21:public void setName(java.lang.String) 24:24:public java.lang.String getUrl() 28:29:public void setUrl(java.lang.String) -keepclassmembers [,modifier,…] class specification 指定要保留的类成员，前提是它们的类也被保留了。 例如，你想保留实现了 Serializable 接口的类中的所有 serializable 方法和字段。 1234567891011121314-keepclassmembers class * implements java.io.Serializable &#123; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); &#125; Note: 注意字段类型带上包名; String 类型为 java.lang.String;另外，如果只保留了类成员没有保留类跟没有保留一样 还是拿上面那个例子，改一下规则 12345678910-keepclassmembers class * implements java.io.Serializable&#123; private String name; public String getName(); public static final int A;&#125; 再看 usage.txt 类都被移除了，保留字段没毛线用。 12cn.sintoon.camera.Product -keepclasseswithmembers [,modifier,…] class specification 指定要保留的类和类成员，条件是所有指定的类成员都在。 例如，你要保留程序中所有的主程序，不用显示的列出。 123456-keepclasseswithmembers public class * &#123; public static void main(java.lang.String[]); &#125; 还是用上面那个例子，保留住类和所有的类成员 1234567891011121314151617181920-keepclasseswithmembers class cn.sintoon.camera.Product&#123; public static final int A; public static final int B; private java.lang.String name; private java.lang.String url; public java.lang.String getName(); public void setName(java.lang.String); public java.lang.String getUrl(); public void setUrl(java.lang.String);&#125; 看 seeds.text 中就会出现这个类和类成员 123456789101112131415161718cn.sintoon.camera.Productcn.sintoon.camera.Product: int Acn.sintoon.camera.Product: int Bcn.sintoon.camera.Product: java.lang.String namecn.sintoon.camera.Product: java.lang.String urlcn.sintoon.camera.Product: java.lang.String getName()cn.sintoon.camera.Product: void setName(java.lang.String)cn.sintoon.camera.Product: java.lang.String getUrl()cn.sintoon.camera.Product: void setUrl(java.lang.String) Note:一定要注意指定的类成员必须存在，如果不存在的话，这个规则相当于没有配，一点作用没有 -if class specification 指定必须存在的类和类成员来激活后续 keep 规则（-keep，-keepclassmembers，…）。条件和随后的 keep 规则可以共享通配符和对通配符的引用。 例如，你可以保留类，条件是你的项目中存在具有相关名称的类，就像使用 Dagger 和 Butterknife 等。 如果你的Android应用程序包含用于依赖注入的Dagger，则需要几行配置，因为Dagger严重依赖反射在运行时将代码绑定在一起。需要保留注释的类成员，生成的类和实用程序类 123456789101112131415161718192021222324252627282930313233343536-keepclassmembers,allowobfuscation class * &#123; @dagger.** *; &#125; -keep class **$$ModuleAdapter -keep class **$$InjectAdapter -keep class **$$StaticInjection-if class **$$ModuleAdapter-keep class &lt;1&gt;-if class **$$InjectAdapter-keep class &lt;1&gt;-if class **$$StaticInjection-keep class &lt;1&gt; -keepnames class dagger.Lazy 这个 规则 我在 studio 中测试 没有被识别 12java.io.IOException: proguard.ParseException: Unknown option &apos;-if&apos; -keepnames class specification -keep,allowshrinking class specification的简写 指定要保留名称的类成员和类成员（如果它们在压缩阶段未被删除）。 例如，你可能希望保留实现 Serializable 接口的类的所有类名，以便处理后的代码与任何原始序列化的类保持兼容。 完全不用的类仍然可以删除。只有在混淆时才适用。 12-keepnames class * implements java.io.Serializable Note: 前提是在压缩阶段没有被删除掉，这里相当于使用了修饰符 allowshrinking -keepclassmembernames class specification-keepclassmembers,allowshrinking class specification 的简写 指定要保留名称的类成员（如果它们在压缩阶段未被删除）。 例如，在处理由JDK 1.2或更早版本编译的库时，您可能希望保留合成类$方法的名称。 所以当处理使用处理过的库的应用程序时，混淆器可以再次检测到它（尽管ProGuard本身不需要这个）。 只有在混淆时才适用。 12345678-keepclassmembernames class * &#123; java.lang.Class class$(java.lang.String); java.lang.Class class$(java.lang.String, boolean); &#125; Note: 前提是在压缩阶段没有被删除掉，这里相当于使用了修饰符 allowshrinking -keepclasseswithmembernames class specification-keepclasseswithmembers,allowshrinking class specification 的简写 指定要保留名称的类和类成员，条件是所有指定的类成员都存在于收缩阶段之后。 例如，可能希望保留所有本机方法名称和类别的名称，以便处理的代码仍可以与本机库代码链接。完全没有使用的本地方法仍然可以被删除。 如果使用了一个类文件，但它的本地方法都不是，它的名字仍然会被混淆。只有在混淆时才适用。 123456-keepclasseswithmembernames,includedescriptorclasses class * &#123; native &lt;methods&gt;; &#125; Note: 前提是在压缩阶段没有被删除掉，这里相当于使用了修饰符 allowshrinking -printseeds [filename] 指定详尽列出由各种-keep选项匹配的类和类成员。列表打印到标准输出或给定文件。该列表可用于验证是否真的找到了预期的类成员，尤其是在使用通配符的情况下。 例如，您可能想要列出您保存的所有应用程序或所有小程序。 参考上面说的 seeds.txt -whyareyoukeeping class specification 指定打印详细信息，说明为什么给定的类和类成员正在压缩步骤中。 如果想知道为什么某些给定元素出现在输出中，这会很有用。 一般来说，可能有很多不同的原因。 此选项为每个指定的类和类成员打印最短的方法链到指定的种子或入口点。 在当前的实施中，打印出的最短链有时可能包含循环扣除 - 这些并不反映实际收缩过程。 如果指定了 -verbose 选项，则跟踪包括完整的字段和方法签名。只适用于压缩。 压缩规则-dontshrink 指定不被压缩的类文件。 默认情况下压缩是开启的，除了用各种用 keep 选项直接或间接用到的类或类成员，其他的都会被移除。 压缩步骤通常在优化之后，因为某些优化可能会打开已经删除的类或类成员。 -printusage [filename] 指定列出移除的死代码。该列表打印到标准输出或给定文件。 参考上面说的 usage.txt 例如，您可以列出应用程序的未使用代码。只适用于压缩。 优化规则-dontoptimize 指定不优化输入类文件。默认情况下，优化已启用;所有方法都在字节码级别进行了优化 -optimizationpasses n 指定要执行的优化传递的数量。 默认情况下，执行一次传递。多次通行可能会导致进一步的改进。如果在优化后没有找到改进，则优化结束。只适用于优化。 混淆规则-dontobfuscate 指定不混淆输入的类文件。 默认情况下，混淆是开启的，类和类成员会被改成新的短随机名称，除了各种-keep选项列出的名称外。 内部属性对于调试很有用，例如源文件名，变量名和行号被删除。 -printmapping [filename] 指定将旧名称映射到已重命名的类和类成员的新名称的映射。映射打印到标准输出或给定文件。 例如，它是后续增量混淆所必需的，或者如果想再次理解混淆的堆栈跟踪。只有在混淆时才适用。 参考 上面说的 mapping.txt。 -useuniqueclassmembernames 指定将相同的混淆名称分配给具有相同名称的类成员，并将不同混淆名称分配给名称不同的类成员（对于每个给定的类成员签名）。 没有这个选项，更多的类成员可以被映射到相同的短名称，比如’a’，’b’等等。 这个选项因此稍微增加了结果代码的大小，但是它确保了保存的混淆名称映射总是可以在随后的增量混淆步骤中受到尊重。 例如，考虑两个不同的接口，它们包含具有相同名称和签名的方法。如果没有此选项，这些方法可能会在第一个混淆步骤中获取不同的混淆名称。 如果添加了包含实现两个接口的类的补丁程序，则ProGuard必须在增量混淆步骤中为这两种方法强制执行相同的方法名称。 原始模糊代码已更改，以保持结果代码的一致性。在最初的混淆步骤中使用此选项，这种重命名将永远不是必需的。 该选项仅适用于混淆。 实际上，如果计划执行增量混淆，则可能希望完全避免压缩和优化，因为这些步骤可能会删除或修改部分代码，这些代码对于以后的添加至关重要。 -dontusemixedcaseclassnames 指定在混淆时不生成混合大小写的类名。 默认情况下，混淆的类名可以包含大写字符和小写字符的混合。 创建的这个完全可接受和可用的jars 只有在不区分大小写的文件系统（比如Windows）的平台上解压缩jar时，解压缩工具可能会让类似命名的类文件相互覆盖。 解压缩后自毁的代码！真正想在Windows上解压他们的jar的开发人员可以使用这个选项来关闭这种行为。 混淆的jars会因此变得稍大。 只有在混淆时才适用。 -keeppackagenames [package_filter] 指定不混淆给定的软件包名称。 可选过滤器是包名称的逗号分隔列表。包名可以包含？，和*通配符，并且它们可以在！否定器。只有在混淆时才适用。 -flattenpackagehierarchy [package_name] 指定将所有重命名的软件包重新打包，方法是将它们移动到单个给定的父软件包中。如果没有参数或空字符串（’’），程序包将移动到根程序包中。 该选项是进一步混淆软件包名称的一个示例。它可以使处理后的代码更小，更难理解。 只有在混淆时才适用。 -repackageclasses [package_name] 指定将所有重命名的类文件重新打包，方法是将它们移动到单个给定的包中。没有参数或者使用空字符串（’’），该软件包将被完全删除。 该选项将覆盖 -flattenpackagehierarchy 选项。 这是进一步模糊软件包名称的另一个例子。 它可以使处理后的代码更小，更难理解。 其不推荐使用的名称是-defaultpackage。 只有在混淆时才适用。 警告：如果在别处移动它们，则在其包目录中查找资源文件的类将不再正常工作。如有疑问，请不要使用此选项，以免触及包装。 -keepattributes [attribute_filter] 指定要保留的任何可选属性。这些属性可以用一个或多个-keepattributes指令来指定。 可选过滤器是Java虚拟机和ProGuard支持的属性名称的逗号分隔列表。 属性名称可以包含？，*和**通配符，并且可以在之前加上！否定器。 例如，在处理库时，您至少应保留Exceptions，InnerClasses和Signature属性。 您还应该保留SourceFile和LineNumberTable属性以生成有用的混淆堆栈跟踪。 最后，如果你的代码依赖于它们，你可能需要保留注释。 只有在混淆时才适用。 12345678910111213141516# 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses# 避免混淆泛型-keepattributes Signature# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable -keepparameternames 指定保留所保存方法的参数名称和类型。 该选项实际上保留了调试属性LocalVariableTable和LocalVariableTypeTable的修剪版本。 处理库时它可能很有用。 一些IDE可以使用这些信息来帮助使用该库的开发人员， 例如工具提示或自动完成。 只有在混淆时才适用。 -renamesourcefileattribute [string] 指定要放入类文件的SourceFile属性（和SourceDir属性）中的常量字符串。请注意，该属性必须首先出现，所以它也必须使用-keepattributes指令明确保留。 例如，您可能希望让处理过的库和应用程序生成有用的混淆堆栈跟踪。 只有在混淆时才适用 预校验 规则-dontpreverify 指定不预先验证已处理的类文件。 默认情况下，如果类文件针对Java Micro Edition或Java 6或更高版本，则会对其进行预验证。 对于Java Micro Edition，需要进行预验证，因此如果指定此选项，则需要在处理的代码上运行外部预验证程序。 对于Java 6，预验证是可选的，但从Java 7开始，它是必需的。 只有在最终对Android时，它才不是必需的，因此您可以将其关闭以缩短处理时间。 -android 指定已处理的类文件针对Android平台。然后ProGuard确保一些功能与Android兼容。 例如，如果您正在处理Android应用程序，则应该指定此选项。 一般规则-verbose 指定在处理期间写出更多信息。如果程序以异常终止，则此选项将打印出整个堆栈跟踪，而不仅仅是异常消息。 -dontnote [class_filter] 指定不打印有关配置中可能的错误或遗漏的注释， 例如类名中的拼写错误或缺少可能有用的选项。 可选的过滤器是一个正则表达式; ProGuard不打印有关匹配名称的类的注释。 -dontwarn [class_filter] 指定不警告有关未解决的引用和其他重要问题。 可选的过滤器是一个正则表达式; ProGuard不打印关于具有匹配名称的类的警告。忽略警告可能是危险的。 例如，如果处理确实需要未解决的类或类成员，则处理后的代码将无法正常工作。 只有在你知道自己在做什么的情况下才使用此选项！ -ignorewarnings 指定打印任何关于未解决的引用和其他重要问题的警告，但在任何情况下都继续处理，忽略警告。 忽略警告可能是危险的。 例如，如果处理确实需要未解决的类或类成员，则处理后的代码将无法正常工作。 只有在知道自己在做什么的情况下才使用此选项！ -printconfiguration [filename] 指定使用包含的文件和替换的变量写出已解析的整个配置。结构打印到标准输出或给定文件。 这对于调试配置或将XML配置转换为更易读的格式有时会很有用。 -dump [filename] 指定在任何处理后写出类文件的内部结构。结构打印到标准输出或给定文件。 例如，可能希望写出给定jar文件的内容，而不进行处理。 参考上面说的 dump.txt。 -addconfigurationdebugging 指定用调试语句来处理已处理的代码，这些语句显示缺少ProGuard配置的建议。 如果处理后的代码崩溃，那么在运行时获得实用提示可能非常有用，因为它仍然缺少一些反射配置。 例如，代码可能是使用GSON库序列化类，可能需要一些配置。通常可以将控制台的建议复制/粘贴到配置文件中。 警告：不要在发行版本中使用此选项，因为它将混淆信息添加到已处理的代码中。 keep 规则修饰符includedescriptorclasses 指定-keep选项所保存的方法和字段的类型描述符中的任何类也应保存。 在保留方法名称时，这通常很有用，以确保方法的参数类型不会重命名。他们的签名保持完全不变，并与本地库兼容。 includecode 指定保持-keep选项所保存的字段的方法的代码属性也应该保留，即可能未被优化或模糊处理。这对于已优化或混淆的类通常很有用，以确保在优化期间未修改其代码。 allowshrinking 指定-keep选项中指定的入口点可能会压缩，即使必须另外保留它们。 也就是说，可以在压缩步骤中删除入口点，但如果它们是必需的，则它们可能未被优化或混淆。 allowoptimization 指定-keep选项中指定的入口点可能会被优化，即使它们必须另外保存。 也就是说，入口点可能会在优化步骤中被更改，但它们可能不会被删除或混淆。 此修饰符仅用于实现不寻常的要求。 allowobfuscation 指定在-keep选项中指定的入口点可能会被混淆，即使它们必须另外保存。 也就是说，入口点可能在混淆步骤中被重命名，但它们可能不会被删除或优化。 此修饰符仅用于实现不寻常的要求。 keep 规则总结压缩和混淆的各种-keep选项起初看起来有点混乱，但实际上它们背后有一个模式。 下表总结了它们之间的关系： |保留|被删除或重命名|被重命名| |:—-:|:—-:|:—–:| | 类和类成员 | -keep| -keepnames | |只有类成员|-keepclassmembers|-keepclassmembernames| |类和类成员，入股成员存在|-keepclasseswithmembers|-keepclasseswithmembernames| 如果指定了一个没有类成员的类，ProGuard只保留该类及其无参数的构造函数作为入口点。它可能仍会删除，优化或混淆其他班级成员。 如果指定了一个方法，则ProGuard仅将该方法作为入口点进行保存。其代码可能仍会进行优化和调整。 类规范 类规范是类和类成员（字段和方法）的模板。它用于各种-keep选项和-assumenosideeffects选项中。相应的选项仅适用于与模板匹配的类和类成员。 模板的设计看起来非常类似于Java，并为通配符进行了一些扩展。为了理解语法，你应该看看这些例子，但这是对一个完整的正式定义的尝试： 123456789101112131415161718192021222324[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname [extends|implements [@annotationtype] classname][&#123; [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; | (fieldtype fieldname); [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; | &lt;init&gt;(argumenttype,...) | classname(argumenttype,...) | (returntype methodname(argumenttype,...)); [@annotationtype] [[!]public|private|protected|static ... ] *; ...&#125;] 方括号 “[]” 表示其内容是可选的。 省略号点“…”表示可以指定任意数量的前述项目。 垂直条“|”划定了两种选择。 非粗体括号“（）”只是将属于规范的部分组合在一起。 缩进尝试澄清预期的含义，但在实际配置文件中，空白是不相关的。 class关键字指的是任何接口或类。interface 关键字限制匹配接口类。 enum关键字限制匹配枚举类。在 interface 或 enum 关键字前加上！将匹配限制为不是接口或枚举的类。 每一个类名字都必须是完全限定名，例如 java.lang.String 内部类用美元符号“$”分隔，例如java.lang.Thread$State。类名可以被指定为包含以下通配符的正则表达式： ? 匹配类名称中的任何单个字符，但不匹配包分隔符。例如 “com.example.Test?” 可以匹配 “com.example.Test1” 和 “com.example.Test2” 但不能匹配 “com.example.Test12” * 匹配不包含包分隔符的类名的任何部分。例如 “com.example.*Test*“ 能够匹配 “com.example.MyTest” 和 “com.example.MyTestProduct” 但不能匹配 “com.example.mxc.MyTest” 或者 “com.example.*“ 能够匹配 “com.example” 但不能匹配 “com.example.mxc” ** 匹配类名称的任何部分，可能包含任意数量的包分隔符。例如，”**.Testz” 匹配除根包以外的所有包中的所有Test类。或者，”com.example.**“ 匹配 “com.example” 中的所有类及其子包。 &lt;n&gt; 在相同的选项中匹配第n个匹配的通配符。例如，”com.example.*Foo&lt;1&gt;” 匹配”com.example.BarFooBar”。 为了获得更多的灵活性，类名实际上可以是逗号分隔的类名列表，可以加!。这个符号看起来不是很像java，所以应该适度使用。 为了方便和向后兼容，类名*指任何类，而不考虑它的包。 extends 和 implements 通常用来限制使用通配符的类。目前他们是一样的。他们的意思是 只有继承或实现了给定类的类才有资格。给定的类本身不包含在这个集合中。如果需要，应该在单独的选项中指定。 @ 可用于将类和类成员限制为使用指定的注释类型进行注释的类。annotationtype 就像类名一样被指定。 除了方法参数列表不包含参数名称外，字段和方法在Java中的定义非常类似（就像在javadoc和javap等其他工具中一样）。这些规范还可以包含以下通配符通配符： |通配符|意义| |:—|:—:| |&lt;init&gt;|匹配任何构造方法| |&lt;fields&gt;|匹配任何字段| |&lt;methods&gt;|匹配任何方法| |*|匹配任何方法和字段| 请注意，上述通配符没有返回类型。只有&lt;init&gt;通配符才有一个参数列表。 字段和方法也可以使用正则表达式来指定。名称可以包含以下通配符： |通配符|意义| |:—|:—| |?|匹配方法名的任何单个字符| |*|匹配方法名的任何部分| |&lt;n&gt;|在相同的选项中匹配第n个匹配的通配符| 类型可以包含以下通配符 |通配符|意义| |:—|:—| |%|匹配任何原始类型（boolean,int 等，不包含 void）| |?|匹配类名中的单个字符| |*|匹配类名中的任何部分但不包含包分隔符| |**|匹配类名中的任何部分，可以包含任意包分割符| |***|匹配任何类型（原始类型或者非原始类型，数组或者非数组）| |—|匹配任何类型的任意数量的参数| |&lt;i&gt;|在相同的选项中匹配第n个匹配的通配符。| 请注意，？，*和**通配符永远不会匹配基本类型。而且，只有***通配符才能匹配任何维度的数组类型。例如，“** get *（）”匹配“java.lang.Object getObject（）”，但不匹配“float getFloat（）”和“java.lang.Object [] getObjects（）”。 也可以使用短类名（无包）或使用完整的类名来指定构造函数。和Java语言一样，构造函数规范有一个参数列表，但没有返回类型。 类访问修饰符和类成员访问修饰符通常用于限制通配类和类成员。它们指定必须为成员设置相应的访问标志以匹配。前面加 “!” 决定相应的访问标志应该被取消设置。 允许组合多个标志（例如，public static）。这意味着必须设置两个访问标志（例如 public static ），除非它们有冲突，在这种情况下，至少必须设置其中一个（例如至少public或 protected）。 ProGuard支持可能由编译器设置的其他修饰符synthetic，bridge和varargs。 参考资料 https://www.guardsquare.com/en/proguard/manual/introduction https://www.diycode.cc/topics/380]]></content>
      <categories>
        <category>Proguard</category>
      </categories>
      <tags>
        <tag>Proguard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建管理通知渠道]]></title>
    <url>%2F2018%2F04%2F27%2FCreateAndManageNotificationChannel%2F</url>
    <content type="text"><![CDATA[创建 和管理 通知渠道从Android8.0（API26）开始，所有的通知必须分配一个渠道。每一个渠道，你都可以设置渠道中所有通知的视觉和听觉行为。然后，用户能够随意修改这些设置来决定通知的行为。 视频说明https://youtu.be/zGIw4MIJn5o 用户能够设置每个App的通知渠道行为 在用户界面渠道显示为 “类别” 渠道创建后就不能更改通知行为了，用户能够完全控制通知的行为，但我们还是可以更改说明和渠道名称 我们可以为每个不同类型的通知创建一个渠道； 如果 target&gt;=26 就必须使用渠道。如果target是在26以下，但是运行在了26及以上了，不要怕，还是会和往常一样，不会抛出异常。 如果 target&gt;=26； 在26及以上运行的时候没有指定一个渠道，通知是不会发出的，系统会记录此错误。可以在logcat看到 Android O 有一个新的开发者设置，当发送了没有指定渠道的通知时显示一个toast。 Settings &gt; Developer options and enable Show notification channel warnings 创建 通知渠道创建渠道有三个步骤 使用一个唯一ID，一个用户可见的渠道名称和一个渠道重要性 三个参数构造一个NotificationChannel实例 （可选）设置渠道描述 通过 setDescription(); 通过NotificationManager 的 createNotificationChannel()创建渠道 Note: 确保创建代码运行在Android O及以上，因为渠道的API没有在support library中 1234567891011121314if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; // Create the NotificationChannel CharSequence name = getString(R.string.channel_name); String description = getString(R.string.channel_description); int importance = NotificationManager.IMPORTANCE_DEFAULT; NotificationChannel mChannel = new NotificationChannel(CHANNEL_ID, name, importance); mChannel.setDescription(description); // Register the channel with the system; you can&apos;t change the importance // or other notification behaviors after this NotificationManager notificationManager = (NotificationManager) getSystemService( NOTIFICATION_SERVICE); notificationManager.createNotificationChannel(mChannel);&#125; 如果创建的渠道已经存在当程序运行的时候不会出现异常 通知的行为默认是通过设置的重要性(构建Channel实例的第三个参数)来决定的。这些参数来自于NotificationManagerCompat中的几个常量。 如果想更进一步的自定行为可以参考以下方法 ；行为在渠道创建后是不能修改的，用户能够完全控制这些设置。 指示灯是否开启 enableLights() 指示灯的颜色 setLightColor() 设置震动模式 setVibrationPattern() 可以通过 createNotificationChannel() 创建多个渠道； 除了给通知添加渠道，还可以考虑为通知添加系统类型。参考：https://developer.android.google.cn/training/notify-user/build-notification.html#system-category 设置重要性级别渠道重要性决定了渠道中所有的通知打断级别，必须在渠道构造方法中设置重要性级别。有五个重要性级别 从IMPORTANCE_NONE(0) 到 IMPORTANCE_HIGH(4)，我们可以将他们指定给渠道中的所有通知。 为了兼容Android O 以下的版本 必须为通知设置优先级setPriority() 。参数是 NotificationCompat中的几个常量 重要性级别和优先级常量映射到的用户可见的重要性选项如下 用户可见的重要性级别 重要性级别（Android O及以上） 优先级（Android O 以下） 紧急。发出声音并显示为单条通知 IMPORTANCE_HIGH PRIORITY_HIGH or PRIORITY_MAX 高。发出声音 IMPORTANCE_DEFAULT PRIORITY_DEFAULT 中。没有声音 IMPORTANCE_LOW PRIORITY_LOW 低。没有声音也不会出现在状态栏中 IMPORTANCE_MIN PRIORITY_MIN 所有的通知，不管重要性如何，都会出现在不影响用户的系统界面上。例如通知栏，启动图标的通知点（可以改变样式或是否显示） 一但将渠道提交到NotificationManager 就不能再修改重要性级别了，但是用户可随意随时修改。 有关选择适当优先级的信息 ，查看 通知设计指南中的 正确设置和管理优先级 读取通知渠道设置用户可以在设置界面设置渠道的行为（震动，声音等）可以通过以下步骤获取到用户对我们渠道的行为设置。 通过 getNotificationChannel() or getNotificationChannels() 获取NotificationChannel 实例 查询指定的设置 例如 getSound(),getImportance(),getVibrationPattern() 如果检测到用户设置会影响程序的行为。我们可以给用户一个操作让其改变设置。 打开通知渠道设置渠道在创建了之后就不能通过代码的方式改变其行为了，只能用户在系统设置修改。为了方便用户修改我们可以通过代码打开系统设置，让用户更方便的修改。 通过Intent使用action:ACTION_CHANNEL_NOTIFICATION_SETTINGS 打开系统设置。需要两个参数 一个是包名 一个是渠道id。 下面就是打开系统设置渠道的代码。 1234Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());intent.putExtra(Settings.EXTRA_CHANNEL_ID, myNotificationChannel.getId());startActivity(intent); 删除通知渠道可以通过以下代码删除渠道12345NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);// The id of the channel.String id = &quot;my_channel_01&quot;;mNotificationManager.deleteNotificationChannel(id); 系统设置会显示已经删除的渠道数量，作为垃圾邮件防范机制。可以通过重装程序或者清楚数据来清除测试渠道 创建渠道分组如果想要更好的在系统设置UI中显示渠道外观，可以创建渠道分组。当你的APP支持多用户的时候可以为每个账户创建一个渠道分组。这样，用户可以轻易的识别和控制具有相同名字的渠道。 例如，一个网络社交APP可能包含支持个人和工作账户，这种情况下，每个账户可能需要多个相同功能和名称的多个渠道，如下所示： 个人账户的两个渠道 新评论 发布推荐 工作账号的两个渠道 新评论 发布推荐将每个账户的渠道分组确保用户能够轻易的区分它们。 每一个渠道分组都需要一个包内唯一的ID和一个用户可见的名称，下面代码演示怎么创建一个分组1234567// The id of the group.String groupId = &quot;my_group_01&quot;;// The user-visible name of the group.CharSequence groupName = getString(R.string.group_name);NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mNotificationManager.createNotificationChannelGroup(new NotificationChannelGroup(group_id, group_name)); 创建分组后可以通过渠道的setGroup()来关联分组；将渠道提交到通知管理后就无法改变关联关系了。 end]]></content>
      <categories>
        <category>Android</category>
        <category>通知</category>
        <category>通知渠道</category>
      </categories>
      <tags>
        <tag>通知</tag>
        <tag>通知渠道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建通知]]></title>
    <url>%2F2018%2F04%2F20%2FCreateNotification%2F</url>
    <content type="text"><![CDATA[原文地址：https://developer.android.com/training/notify-user/build-notification.html 创建一个通知通知提供了有关应用程序未使用时的事件的简短而及时的信息。这篇文章教你怎么通过Android4.0及以上版本的各种功能去创建一个通知。有关通知怎么在Android上显示，Android 通知 此页面上的代码使用Android支持库中的NotificationCompat APIs。这些 APIs 允许你添加新版本有的功能，可以兼容到 Android 4.0（API level 14），然而，一个新的特征，例如回复操作会在旧版本中无法运行。 添加支持库尽管大部分使用 Android Studio 创建的项目都包含了使用 NotificationCompat 的必要依赖，但还是要检验一下项目的 build.gradle 文件中是否包含下面的依赖123dependencies &#123; implementation &quot;com.android.support:support-compat:27.1.0&quot;&#125; [^ com.android.support 中的其他库也包含了 support-compat 传递性依赖,如果引用了其他库也是可以使用 NotificationCompat 的，就不必显示添加上面的依赖 ] 创建一个基础通知最基本的通知会显示一个 icon ，一个标题，一段简要的内容。这节你将会学习怎么创建一个点击启动APP的通知。 关于通知的每个部分的更多细节 请阅读 通知概览 设置通知内容首先，通过 NotificationCompat.Builder 设置通知的内容和渠道。下面的示例演示了如果通过以下命令创建通知。 小图标 通过 setSmallIcon() ;这是唯一一个必须设置的用户可见内容 标题 通过 setContentTitle() 设置 内容 通过 setContentText() 设置 通知优先权 通过 setPriority() 设置。这个优先权决定了通知在 Android 7.1及以下系统上的行为（Android 8.0 及以上系统通过渠道的 importance 属性统一设置） 12345NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(textTitle) .setContentText(textContent) .setPriority(NotificationCompat.PRIORITY_DEFAULT); 注意这个 NotificationCompat.Builder 构造方式需要一个渠道 ID 。 这是为了兼容 Android 8.0 及以上版本所必须的，旧版本忽略就好 默认通知内容会被自适应为一行，如果你想显示更多，可以通过 setStyle() 设置一个样式模板来启用扩展通知。例如，以下代码会创建一个更大的文本区域: 1234567NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Much longer text that cannot fit one line...&quot;) .setStyle(new NotificationCompat.BigTextStyle() .bigText(&quot;Much longer text that cannot fit one line...&quot;)) .setPriority(NotificationCompat.PRIORITY_DEFAULT); 关于其他大的通知样式，包括怎么去增加图片，控制媒体播放等，创建扩展通知 创建渠道和设置重要性在 Android 8.0 及以上版本必须创建Notificationchannel 实例，并通过 createNotificationchannel() 注册通知渠道。下面代码必须保证 SDK_VERSION 在8.0及以上 123456789101112if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; // Create the NotificationChannel, but only on API 26+ because // the NotificationChannel class is new and not in the support library CharSequence name = getString(R.string.channel_name); String description = getString(R.string.channel_description); int importance = NotificationManagerCompat.IMPORTANCE_DEFAULT; NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance); channel.setDescription(description); // Register the channel with the system NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this); notificationManager.createNotificationChannel(channel);&#125; 注意这个 NotificationChannel 构造方法需要一个 importance 参数，这个参数是类 NotificationManagerCompat 中的常量；这个参数决定了渠道内通知的行为–但是也必须通过 setPriority() 设置优先权来兼容 Android 7.1 及更低的版本。 尽管必须设置通知的重要性和优先级，但是系统并不保证通知的行为，系统可能会因为别的因素改变重要性等级。用户可以随时更改重要性等级。 设置通知点按操作每个通知都应该响应点按操作，通常是去打开一个通知对应的 Activity 。这样就必须指定一个 PedingIntent 定义的 Intent 并使用 setContentIntent() 设置给通知。 下面的代码演示了怎样去创建一个当用户点按打开 Activity 的基本通知12345678910111213// Create an explicit intent for an Activity in your appIntent intent = new Intent(this, AlertDetails.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0);NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) // Set the intent that will fire when the user taps the notification .setContentIntent(pendingIntent) .setAutoCancel(true); 注意：这个通知调用了setAutoCancel(true) 当用户点按后会自动移除通知。 上面所示的 setFlags() 方法有助于在通过通知打开应用程序后保留用户的预期导航体验。但是，是否要用这个功能取决于你打开的 Activity 类型，可能是以下一种情况： 专用于响应通知的 Activity。用户在正常情况下不会打开这个 Activity，所以该 Activity 启动一个新的任务栈而没有必要添加到程序的返回栈中。这就是上面所示的内容意图类型 应用程序中的常规 Activity . 这种情况，启动的 Activity 应该创建一个返回栈以便保留用户的导航体验。 更多关于配置通知意图的方法，移步阅读从通知启动一个Activity 显示通知显示通知需要调用 NotificationManagerCompat.notify() 方法，参数是一个唯一ID和一个 NotificationCompat.Builder.build() 构建的结果。例如1234NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);// notificationId is a unique int for each notification that you must definenotificationManager.notify(notificationId, mBuilder.build()); 记得保存 NotificationManagerCompat.notify() 使用的唯一ID之后要更新或者移除通知都要用到。 注意：从 Android 8.0 开始，程序每秒钟不能发出两次通知声音，如果你每秒钟发出多个通知，只有第一个通知有声音提示。 增加操作按钮一个通知能够添加三个操作按钮去允许用户快速响应。例如停止提醒或者快速回复文本消息。但是这些操作按钮最好不要跟通知点按响应重复。 通知按钮是用 PendingIntent 的 addAction() 方法添加的。就像设置通知默认的点按操作一样，可以不启动 Activity 去做其他的任何事情例如启动一个在后台作业的 BroadcastReceiver 这样就可以不打断用户当前操作。 例如，下面的代码演示了怎么个一个指定的广播接收者发送广播1234567891011121314Intent snoozeIntent = new Intent(this, MyBroadcastReceiver.class);snoozeIntent.setAction(ACTION_SNOOZE);snoozeIntent.putExtra(EXTRA_NOTIFICATION_ID, 0);PendingIntent snoozePendingIntent = PendingIntent.getBroadcast(this, 0, snoozeIntent, 0);NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .setContentIntent(pendingIntent) .addAction(R.drawable.ic_snooze, getString(R.string.snooze), snoozePendingIntent); 关于构建一个后台运行的 BroadcastReceiver 的更多信息，可以查看广播指南 如果要构造一个媒体控制（暂停，跳过等）通知，可以查看创建媒体控制通知 添加直接回复操作Android 7.0 引入的直接回复操作，允许用户不打开 Activity 的情况下在通知内直接输入文本给你程序。例如，你可以在通知内回复文本消息或者更新任务列表。 这个直接回复操作在通知上是一个附加操作按钮打开的文本输入框。当用户完成输入，系统会将含有响应文本的意图发送给你的程序。 添加回复按钮创建一个支持直接回复的通知 创建一个 RemoteInput.Builder 实例添加到你的通知操作。这个类的构造方法接受一个系统为存储输入文本使用的KEY。之后可以在程序中通过这个KEY检索输入文本。 1234567// Key for the string that&apos;s delivered in the action&apos;s intent.private static final String KEY_TEXT_REPLY = &quot;key_text_reply&quot;;String replyLabel = getResources().getString(R.string.reply_label);RemoteInput remoteInput = new RemoteInput.Builder(KEY_TEXT_REPLY) .setLabel(replyLabel) .build(); 为回复操作创建 PendingIntent 123456// Build a PendingIntent for the reply action to trigger.PendingIntent replyPendingIntent = PendingIntent.getBroadcast(getApplicationContext(), conversation.getConversationId(), getMessageReplyIntent(conversation.getConversationId()), PendingIntent.FLAG_UPDATE_CURRENT); 警告：如果您重新使用PendingIntent，用户可能会回复与他们认为不同的对话。你必须为每一个会话提供一个不同的请求码或者提供一个在任何其他对话的回复意图中调用equals（）时不会返回true的意图，对话ID经常作为intent的额外套件的一部分传递，但在您调用equals（）时会被忽略。 使用 addRemoteInput() 方法将 RemoteInput 对象附给一个操作。 123456// Create the reply action and add the remote input.NotificationCompat.Action action = new NotificationCompat.Action.Builder(R.drawable.ic_reply_icon, getString(R.string.label), replyPendingIntent) .addRemoteInput(remoteInput) .build(); 添加操作到通知并发送通知 1234567891011// Build the notification and add the action.Notification newMessageNotification = new Notification.Builder(mContext, CHANNEL_ID) .setSmallIcon(R.drawable.ic_message) .setContentTitle(getString(R.string.title)) .setContentText(getString(R.string.content)) .addAction(action) .build();// Issue the notification.NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);notificationManager.notify(notificationId, newMessageNotification); 用户出发回复操作按钮时系统会提示用户输入消息。如上图所示。 从回复中检索用户输入要从通知的答复用户界面接收用户输入，请调用 RemoteInput.getResultsFromIntent() ，并将接受到的 Intent 传递给他： 1234567private CharSequence getMessageText(Intent intent) &#123; Bundle remoteInput = RemoteInput.getResultsFromIntent(intent); if (remoteInput != null) &#123; return remoteInput.getCharSequence(KEY_TEXT_REPLY); &#125; return null; &#125; 处理完文本后，你必须调用 NotificationManagerCompat.notify() 传入ID和TAG（如果有）来更新通知。以便隐藏直接回复界面并向用户确认他们的回复已经被正确接受并处理。 12345678910// Build a new notification, which informs the user that the system// handled their interaction with the previous notification.Notification repliedNotification = new Notification.Builder(context, CHANNEL_ID) .setSmallIcon(R.drawable.ic_message) .setContentText(getString(R.string.replied)) .build();// Issue the new notification.NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);notificationManager.notify(notificationId, repliedNotification); 在处理这个新通知时，使用传递给接收者的 onReceive() 上下文。 还应该通过调用 setREmoteInputHistory() 将该答复追加到底部。但是，如果您正在构建消息传递应用程序，则应该创建消息传递式通知并将新消息追加到对话中。 添加一个进度条通知能包含一个动画进度指示器，向用户展示正在进行的操作状态。 如果能知道操作在什么时候完成。通过调用 setProgress(max,progress,false) 使用指示器的“确定”模式。第一个参数是“完成”时的值（例如100），第二个参数是当前的完成值，最后一个表示这是一个“确定”进度条。 随着操作的进行，持续的调用 setProgress(max,progress,false) 更新进度值并且重复发送通知。 123456789101112131415161718192021222324...NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this, CHANNEL_ID);mBuilder.setContentTitle(&quot;Picture Download&quot;) .setContentText(&quot;Download in progress&quot;) .setSmallIcon(R.drawable.ic_notification) .setPriority(NotificationCompat.PRIORITY_LOW);// Issue the initial notification with zero progressint PROGRESS_MAX = 100;int PROGRESS_CURRENT = 0;mBuilder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false);notificationManager.notify(notificationId, mBuilder.build());// Do the job here that tracks the progress.// Usually, this should be in a worker thread// To show progress, update PROGRESS_CURRENT and update the notification with:// mBuilder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false);// notificationManager.notify(notificationId, mBuilder.build());// When done, update the notification one more time to remove the progress barmBuilder.setContentText(&quot;Download complete&quot;) .setProgress(0,0,false);notificationManager.notify(notificationId, mBuilder.build()); 操作结束时，progress（完成进度）应该等于 max （最大值）。你可以让通知显示完成时间或者移除它。不管哪种情况，都应该更新通知显示操作已经完成。调用 setProgress(0,0,false) 可以移除通知进度条。 注意：因为进度条需要你不停的更新进度，所以这些代码通常运行在后台服务中。 显示一个指示器进度条（不确定模式，不显示完成百分比），可以调用 setProgress(0,0,true)。 样式是一个跟上边一样的进度条，除了进度条是一个不表示进度的连续动画。这个进度条动画会一直进行着直到你调用 setProgress(0,0,false) 然后更新通知删除进度指示器。 记得在操作完成后更新通知文本去通知用户 注意：如果确实需要下载文件，应该考虑使用 DownloadManager 他提供自己的进度通知来跟踪下载进度。 设置一个系统范围的类别Android 通过一些预定义的系统范围类型去确定在用户开启不打扰模式的情况下怎么用通知打扰用户。 如果你的通知是 NotificationCompat 中预定义的通知类别中的一个–例如 CATEGORY_ALARM,CATEGORY_REMINDER,CATEGORY_EVENT or CATEGORY_CALL ,你应该通过 setCatergory() 定义一个类别。123456NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.drawable.notification_icon) .setContentTitle(&quot;My notification&quot;) .setContentText(&quot;Hello World!&quot;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .setCategory(NotificationCompat.CATEGORY_MESSAGE); 当设备进入忽扰模式系统将根据设置的通知类别决定通知的行为。 此外，通知类别不是必须的，只有你的通知输入系统预定义中一种才需要设置。 设置锁屏可见性要在锁定屏幕中控制通知可见的详细程度，调用 setVisiblity() 并设置下面中的一个值： VISIBILITY_PUBLIC 显示通知的完整内容 VISIBILITY_SECRET 不显示任何内容 VISIBILITY_PRIVATE 显示基础内容，例如通知的icon，标题，但是隐藏了内容； 当设置为 VISIBILITY_PRIVATE 时可以提供一个隐藏部分内容的备用版本。例如，一个 SMS app 可能会显示 “你有三条文本消息”,但是隐藏了消息内容和发送人。提供这个备用通知，首先通过 NotificationCompat.Builder 创建一个备用通知。然后调用 setPublicVersion() 附加进普通通知。 然而，用户对这些有最终控制权，甚至可以从通知渠道控制。 更新通知在发布后更新通知，可以再次调用 NotificationManagerCompat.notify() 使用原来的通知ID。如果通知已经消失会发出一个新的通知。 可以选择性调用 setOnlyAlertOnce() 让通知只在第一次显示时才会中断用户（包括声音，震动，视觉），而不是以后的更新都中断用户。 注意：Android系统在更新通知时应用了比例限制。如果你的更新过于频繁（一秒内多个），系统可能会放弃一些更新（通常一秒内只更新一次）。 移除通知通知会在以下几种情况被移除： 用户清除 创建通知时调用了 setAutoCancel()，用户点击通知后会自动消失。 调用 cancel() 方法，传入指定ID，这个方法会删除指定通知。 调用 cancelAll() 移出所有你发出的通知 如果创建的时候调用 setTimeoutAfter() 设置了超市时间，系统会在指定时间后清除此通知，如果需要，你可以在系统清除之前清除掉。 消息应用最佳实践使用此处列出的最佳做法作为创建消息传递和聊天应用通知时要记住的内容的快速参考 使用 MessagingStyle从 Android 7.0 开始，Android 为消息类型通知子提供了样式模板。 使用 NotificationCompat.MessagingStyle 类，你可以更改多个显示在通知的标签，包括会话标题，其他的消息和通知的内容视图。 下面的代码片段演示了怎么用 Messagingstyle 类自定一个通知样式。 12345678Notification notification = new Notification.Builder(this, CHANNEL_ID) .setStyle(new NotificationCompat.MessagingStyle(&quot;Me&quot;) .setConversationTitle(&quot;Team lunch&quot;) .addMessage(&quot;Hi&quot;, timestamp1, null) // Pass in null for user. .addMessage(&quot;What&apos;s up?&quot;, timestamp2, &quot;Coworker&quot;) .addMessage(&quot;Not much&quot;, timestamp3, null) .addMessage(&quot;How about lunch?&quot;, timestamp4, &quot;Coworker&quot;)) .build(); 从Android 8.0（API级别26）开始，使用NotificationCompat.MessagingStyle类的通知将以折叠形式显示更多内容。您还可以使用addHistoricMessage（）方法通过向与消息传递相关的通知添加历史消息来为对话提供上下文。 使用 NotificationCompat.MessagingStyle 的情况： 调用MessagingStyle.setConversationTitle（）为两个以上的人设置群组聊天的标题。一个好的对话标题可能是群组聊天的名称，或者如果它没有特定的名称，则可能是对话中的参与者列表。如果没有这个，该消息可能被误认为属于与对话中最近消息的发送者的一对一对话。 使用MessagingStyle.setData（）方法包含媒体消息，如图像。目前支持模式图像/ *的MIME类型 使用直接回复直接回复允许用户回复内部消息 在用户使用内联回复操作回复后，使用MessagingStyle.addMessage（）更新MessagingStyle通知，并且不收回或取消通知。不取消通知允许用户从通知中发送多个回复。 要使内联回复操作与Android Wear兼容，请调用Action.WearableExtender.setHintDisplayInlineAction（true）。 使用addHistoricMessage（）方法通过向通知添加历史消息来为直接回复对话提供上下文 启用智能回复要启用智能回复，请在回复操作上调用setAllowGeneratedResponses（true）。这会使通知桥接到Android Wear设备时，用户可以使用智能回复响应。智能答复响应由完全在机器学习模型生成，使用NotificationCompat.MessagingStyle通知提供的上下文，并且没有数据上传到互联网以生成响应 添加通知元数据当设备处于免打扰模式时，分配通知元数据以告知系统如何处理您的应用通知。例如，使用addPerson（）或setCategory（Notification.CATEGORY_MESSAGE）方法覆盖免打扰模式。]]></content>
      <categories>
        <category>Android</category>
        <category>通知</category>
      </categories>
      <tags>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Room 持久化库]]></title>
    <url>%2F2018%2F04%2F15%2FRoom%2F</url>
    <content type="text"><![CDATA[这是一篇自己从Android开发文档中翻译来的关于Room 的文档。哪里不对，欢迎纠错 Room 持久化库Room持久性库提供了SQLite的抽象层，以便在充分利用SQLite的同时允许流畅的数据库访问。该库可帮助你在设备上创建应用程序的缓存数据，这样不管设备是否联网都能看到数据。 摘自 Room Persistence Library 使用 Room 在本地保存数据 原文地址 https://developer.android.com/training/data-storage/room/index.html 对于不重要的数据可以存储在本地，最常见的就是缓存相关的数据。这样，在设备没有网络的时候就可以浏览离线数据。当设备联网后，将用户改动的数据同步至服务端。 Room 有三个重要组件 Database Entity DAO Database包含数据库持有者，并作为与应用持久关联数据的底层连接的主要接入点。 使用@Database注解，并满足以下条件 是抽象类，并且继承自RoomDatabase 在注解中包含与数据库关联的实体列表。 包含一个具有0个参数的抽象方法，并返回用@Dao注解的类。在运行时，可以通过调用Room.databaseBuilder（）或Room.inMemoryDatabaseBuilder（）来获取数据库实例。 Entity表示数据库中的表格 DAO包含用户访问数据库的方法 这些组件以及组件与APP其他部分的关系 如图所示 下面的代码片段是一个数据库实例配置包含了一个Entity和一个DAO: User.java1234567891011121314@Entitypublic class User &#123; @PrimaryKey private int uid; @ColumnInfo(name = &quot;first_name&quot;) private String firstName; @ColumnInfo(name = &quot;last_name&quot;) private String lastName; // Getters and setters are ignored for brevity, // but they&apos;re required for Room to work.&#125; UserDao.java123456789101112131415161718@Daopublic interface UserDao &#123; @Query(&quot;SELECT * FROM user&quot;) List&lt;User&gt; getAll(); @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;) List&lt;User&gt; loadAllByIds(int[] userIds); @Query(&quot;SELECT[^] * FROM user WHERE first_name LIKE :first AND &quot; + &quot;last_name LIKE :last LIMIT 1&quot;) User findByName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125; AppDatabase.java 1234@Database(entities = &#123;User.class&#125;, version = 1)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125; 创建完完成后使用以下代码获取数据库实例： 12AppDatabase db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, &quot;database-name&quot;).build(); 数据库实例最好是单例以节省内存开销 使用 Room 实体定义数据 原文地址 https://developer.android.com/training/data-storage/room/defining-data.html 我们定义的每一个实体，Room 都会对应的在数据库中创建一个表。默认 Room 会为 每个字段在表中创建对应的字段;如果其中一些属性不想被创建在表中怎么办，那就是使用 @Ignore 注解此属性。完成实体的创建之后必须在 Database 引用。 1234567891011@Entityclass User &#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 类中的每个字段都必须让Room能够访问到。否则Room无法管理。 [^] 注意 ：要遵循 JavaBean 规约；否则 管杀不管埋；[^] 定义主键每个实体必须定义最少一个主键，就算类中只有一个字段，也要保证使用 @PrimaryKey；如果想让Room自动分配ID，可以设置 autoGenerate 为true；如果是联合主键，可以在@Entity中设置 primaryKeys 属性。 12345678@Entity(primaryKeys = &#123;"firstName", "lastName"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 默认Room会使用类名当作数据库表名，如果你想设置其他名字，可以设置 tableName 属性 1234@Entity(tableName = "users")class User &#123; ...&#125; [^]Sqlite中表名不区分大小写[^] 就像表名一样，字段的名字默认的也是类中属性的名字如果想设置其他名字，可使用 @ColumnInfo 的 name属性 1234567891011121314@Entity(tableName = "users")class User &#123; @PrimaryKey public int id; @ColumnInfo(name = "first_name") public String firstName; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125; 注解索引和唯一约束使用 @Entity 的 indices 来创建索引，并列出索引或者组合索引包含的列； 123456789101112131415@Entity(indices = &#123;@Index("name"), @Index(value = &#123;"last_name", "address"&#125;)&#125;)class User &#123; @PrimaryKey public int id; public String firstName; public String address; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125; 使用 @Index 注解 和 unique 属性设置 唯一约束。下面代码 firstName 和 lastName 两列组合唯一索引 123456789101112131415@Entity(indices = &#123;@Index(value = &#123;"first_name", "last_name"&#125;, unique = true)&#125;)class User &#123; @PrimaryKey public int id; @ColumnInfo(name = "first_name") public String firstName; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125; 定义对象间的关联关系由于Sqlite 是关系型数据库，我们可以指定对象间的关系。大部分的ORM框架也都支持对象间相互引用。但是 Room 明确禁止这样做。至于为什么明确禁止，文章最后会说。原文链接：https://developer.android.com/training/data-storage/room/referencing-data.html#understand-no-object-references 虽然不能直接定义对象间引用，但是可以使用外键建立关系。 例如：有一个 Book 实体，可以使用 @ForeignKey 关联到 User 实体。下面代码演示使用123456789101112@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = "id", childColumns = "user_id"))class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = "user_id") public int userId;&#125; @ForeignKey 是非常强大的，我们可以定义对象间的级联操作。例如可以在注解中设置 onDelete = CASCADE，当删除用户的的时候就会把用户所关联的书都删掉了。 [^]SQLite将@Insert（onConflict = REPLACE）作为一组REMOVE和REPLACE操作处理，而不是单个UPDATE操作。这种替换冲突值的方法可能会影响外键约束。有关更多详细信息，请参阅ON_CONFLICT子句的SQLite文档。[^] 创建嵌套对象Room 支持在数据实体中嵌套其他对象来组合相关字段。例如 User 中嵌套一个 Address 这个地址对象中有三个字段：街道，城市，邮编。在数据表中这个三个字段是在用户表中的，就像其他字段一样。通过在 User 使用 ` 注解 属性address` 即可。 12345678910111213141516171819class Address &#123; public String street; public String state; public String city; @ColumnInfo(name = "post_code") public int postCode;&#125;@Entityclass User &#123; @PrimaryKey public int id; public String firstName; @Embedded public Address address;&#125; 表示User对象的表格包含具有以下名称的列：id，firstName，street，state，city和post_code。 [^] 嵌套字段可以嵌套其他字段[^]如果数据实体中有多个 嵌套字段，可以通过设置属性 prefix 加前缀的方式保证字段名不重复。如果在 User 中使用下面的代码,那么嵌套字段就会是 address_street,address_state,address_city和address_post_code12@Embedded(prefix = "address_")public Address address; 使用 Room DAO 访问数据 原文地址：https://developer.android.com/training/data-storage/room/accessing-data.html Room 使用数据对象和 DAO 访问数据库。DAO 是 Room 的重要组件，他包含了操作数据的抽象方法；DAO可以是一个接口或者抽象类，如果是抽象类的话，它可以有一个构造函数，它将RoomDatabase作为其唯一参数。Room会在编译时创建实现。DAO不能在主线程的时候操作数据，可能会阻塞UI，除非在构建的时候调用 allowMainThreadQueries()。如果是返回 LiveData或者 Flowable 的异步查询例外。 定义操作方法这里只列出几个常用方法 Insert当创建一个DAO方法并使用它的时候，Room会生成它的实现并在单个事物中将所有参数插入。 1234567891011@Daopublic interface MyDao &#123; @Insert(onConflict = OnConflictStrategy.REPLACE) public void insertUsers(User... users); @Insert public void insertBothUsers(User user1, User user2); @Insert public void insertUsersAndFriends(User user, List&lt;User&gt; friends);&#125; 如果 @Insert 只接受到一个参数，他会返回一个新插入行的 long类型的 rowid。如果参数是 一个数组和集合就会返回一个long类型的数组或集合。关于 @Insert 的详细介绍查看文档 https://developer.android.com/reference/android/arch/persistence/room/Insert.html UpdateRoom 会通过每个实体的主键进行查询，然后再进行修改。返回值可以是一个 int 型的值，返回更新的行数。12345@Daopublic interface MyDao &#123; @Update public void updateUsers(User... users);&#125; DeleteRoom 会数据实体的主键删除相应的数据。返回值可以是一个 int 型的值，用来表示删除的行数。12345@Daopublic interface MyDao &#123; @Delete public void deleteUsers(User... users);&#125; 查询信息@Query 是 DAO 中主要使用的注解。它可以执行对数据库的读写操作。每一个 @Query 方法都会在编译时验证，如果出现问题也是在编译时出现问题不会在运行时出现问题。 Room 也会验证方法的返回值，如果返回对象中的字段名称和查询响应中的字段名字不匹配， Room 会通过以下方式给出提示 如果只有一些字段名称不匹配，会发出警告 如果没有字段名称匹配，会发出错误。 简单查询12345@Daopublic interface MyDao &#123; @Query(&quot;SELECT * FROM user&quot;) public User[] loadAllUsers();&#125; 这是一个非常简单的查询所有用户的查询。在编译时，Room会知道是查询用户表的所有列。如果查询包含语法错误或者数据库中不存在这个表。Room会在编译时报错并给出错误信息。 将参数传递给查询大部分时候查询都是需要过滤参数的。比如要查询一些年龄比较大的用户。12345@Daopublic interface MyDao &#123; @Query("SELECT * FROM user WHERE age &gt; :minAge") public User[] loadAllUsersOlderThan(int minAge);&#125; 在编译时，Room会将 :minAge 与方法参数匹配绑定。 Room使用参数名字匹配，如果匹配不上给出错误提示。 也可以传递多个参数或者引用多次：123456789@Daopublic interface MyDao &#123; @Query("SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge") public User[] loadAllUsersBetweenAges(int minAge, int maxAge); @Query("SELECT * FROM user WHERE first_name LIKE :search " + "OR last_name LIKE :search") public List&lt;User&gt; findUserWithName(String search);&#125; 返回列的子集很多时候只需要数据实体的中几个列。例如你可能只想显示用户的姓和名而不是全部的用户信息。只查询需要的列可以节省资源并且查询的更快。 Room 允许返回任何的Java对象。只要查询的结果列能够和Java对象映射上即可。所以我们可以创建一个只包含需要的列的类。 1234567public class NameTuple &#123; @ColumnInfo(name="first_name") public String firstName; @ColumnInfo(name="last_name") public String lastName;&#125; 使用这个 POJO 12345@Daopublic interface MyDao &#123; @Query("SELECT first_name, last_name FROM user") public List&lt;NameTuple&gt; loadFullName();&#125; Room 知道查询的值并知道怎么映射到对应的NameTuple字段中。所以 Room 会生成正确的代码。如果查询返回的列多了或者少了，Room会给出警告 这里也可以使用@Embedded注解 传递参数集合有时候查询的参数数量是动态的，只有运行的时候才知道。例如只查询某些地区的用户。当参数是一个集合的时候，Room 会在运行的时候自动扩展它。 12345@Daopublic interface MyDao &#123; @Query("SELECT first_name, last_name FROM user WHERE region IN (:regions)") public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);&#125; 可观察的查询在执行查询时，我们经常想让UI在数据更改时自动更新。要实现这一点，可以在查询方法使用 LiveData 类行的返回值。当数据更新时 Room 会自动生成所需的代码已更新LiveData。 12345@Daopublic interface MyDao &#123; @Query("SELECT first_name, last_name FROM user WHERE region IN (:regions)") public LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);&#125; 从版本1.0开始，Room使用查询中访问的表的列表来决定是否更新LiveData的实例。 使用 RxJava 进行响应查询Room还可以从定义的查询中返回 RxJava2 的 Publisher 和 Flowable 对象。要使用此功能，需要将 Room 组中的 android.arch.persistence.room:rxjava2 组件添加到构建Gradle依赖项中,添加组件之后就可以返回 Rxjava2 中的对象 12345@Daopublic interface MyDao &#123; @Query("SELECT * from user where id = :id LIMIT 1") public Flowable&lt;User&gt; loadUserById(int id);&#125; 更多 Room 和 Rxjava2 的使用 看另一篇文章 https://medium.com/google-developers/room-rxjava-acb0cd4f3757 直接访问 Cursor12345@Daopublic interface MyDao &#123; @Query(&quot;SELECT * FROM user WHERE age &gt; :minAge LIMIT 5&quot;) public Cursor loadRawUsersOlderThan(int minAge);&#125; 非常不推荐使用Cursor API，因为它不能保证行是否存在或行包含的值。只有当已经拥有需要游标并且无法轻松重构的代码时才使用此功能。 查询多个表有些时候可能需要查询多个表中的数据来计算结果。Room运行我们写任何查询，当然也允许连接其他表。如果响应式可观察数据类型，例如 Flowable 或者 LiveData，Room会监视查询中的所有表，使其无效。 12345678@Daopublic interface MyDao &#123; @Query("SELECT * FROM book " + "INNER JOIN loan ON loan.book_id = book.id " + "INNER JOIN user ON user.id = loan.user_id " + "WHERE user.name LIKE :userName") public List&lt;Book&gt; findBooksBorrowedByNameSync(String userName);&#125; 也可以从这些查询中返回POJO。例如，可以编写一个查询来加载用户及其宠物的名称，如下所示：1234567891011121314@Daopublic interface MyDao &#123; @Query("SELECT user.name AS userName, pet.name AS petName " + "FROM user, pet " + "WHERE user.id = pet.user_id") public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames(); // You can also define this class in a separate file, as long as you add the // "public" access modifier. static class UserPet &#123; public String userName; public String petName; &#125;&#125; 迁移 Room 数据库 原文 https://developer.android.com/training/data-storage/room/migrating-db-versions.html 在APP升级时可能需要更改数据库来策应新的功能。这个时候当然不希望数据库中的数据丢失。 Room 允许我们编写 Migration ，以此来迁移数据。每个迁移类制定一个开始版本和结束版本。 在运行时，Room会运行每个Migration类的migrate（）方法，并使用正确的顺序将数据库迁移到更高版本。 如果不提供必要的Migration , Room 会重建数据库，所以数据会丢失 123456789101112131415161718Room.databaseBuilder(getApplicationContext(), MyDb.class, "database-name") .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();static final Migration MIGRATION_1_2 = new Migration(1, 2) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL("CREATE TABLE `Fruit` (`id` INTEGER, " + "`name` TEXT, PRIMARY KEY(`id`))"); &#125;&#125;;static final Migration MIGRATION_2_3 = new Migration(2, 3) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL("ALTER TABLE Book " + " ADD COLUMN pub_year INTEGER"); &#125;&#125;; 要保持迁移逻辑按预期运行，请使用完整查询，而不是引用表示查询的常量。 在迁移完成之后，Room 验证模式会确认迁移正确进行，如果 Room 发现错误，会抛出一个包含不匹配的异常。 测试迁移数据迁移是很重要的，一旦迁移失败可能会发生Crash。为了保证程序的稳定性，一定要确认是否否迁移成功。Room 提供了一个测试工件来帮助我们测试，为保证测试工件的正确运行，必须开启导出模式。 导出模式编译后，Room将数据库的模式信息导出到JSON文件中。要导出模式，在build.gradle文件中设置room.schemaLocation注解处理器属性，如下面的代码片段所示： build.gradle123456789101112android &#123; ... defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [&quot;room.schemaLocation&quot;: &quot;$projectDir/schemas&quot;.toString()] &#125; &#125; &#125;&#125; 我们应该把导出的 json 文件加入到版本控制中，它记录了数据库的模式历史，它能让Room在测试时创建老版本的数据库。 为了测试迁移，增加 Room 的测试工件依赖，并设置数据库模式文件地址，如下所示： 123456android &#123; ... sourceSets &#123; androidTest.assets.srcDirs += files(&quot;$projectDir/schemas&quot;.toString()) &#125;&#125; 测试包提供了一个MigrationTestHelper类，它可以读取这些模式文件。它实现了 JUnit4 的 TestRule 接口，它能够管理已经创建的数据库。 下面是一个简单的测试1234567891011121314151617181920212223242526272829303132@RunWith(AndroidJUnit4.class)public class MigrationTest &#123; private static final String TEST_DB = &quot;migration-test&quot;; @Rule public MigrationTestHelper helper; public MigrationTest() &#123; helper = new MigrationTestHelper(InstrumentationRegistry.getInstrumentation(), MigrationDb.class.getCanonicalName(), new FrameworkSQLiteOpenHelperFactory()); &#125; @Test public void migrate1To2() throws IOException &#123; SupportSQLiteDatabase db = helper.createDatabase(TEST_DB, 1); // db has schema version 1. insert some data using SQL queries. // You cannot use DAO classes because they expect the latest schema. db.execSQL(...); // Prepare for the next version. db.close(); // Re-open the database with version 2 and provide // MIGRATION_1_2 as the migration process. db = helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2); // MigrationTestHelper automatically verifies the schema changes, // but you need to validate that the data was migrated properly. &#125;&#125; 测试数据库使用 Room 创建数据库时，验证数据库和用户数据的稳定性非常重要。 测试数据库有两种方法 在Android 设备上 在开发主机上（不推荐） 关于测试指定数据库升级的信息 上面已经说过了。 注意：在测试时，Room允许创建Dao的模拟实例。这样的话，如果不是测试数据库本身就不需要创建完整的数据库，这个功能是很好的，Dao不会泄露数据库的任何信息 在设备上测试测试数据库实现的推荐方法是编写在Android设备上运行的JUnit测试，由于这些测试不需要创建活动，它们应该比UI测试更快执行。 在设置测试时，应该创建数据库的内存中版本，以使测试更加密封，如以下示例所示1234567891011121314151617181920212223242526@RunWith(AndroidJUnit4.class)public class SimpleEntityReadWriteTest &#123; private UserDao mUserDao; private TestDatabase mDb; @Before public void createDb() &#123; Context context = InstrumentationRegistry.getTargetContext(); mDb = Room.inMemoryDatabaseBuilder(context, TestDatabase.class).build(); mUserDao = mDb.getUserDao(); &#125; @After public void closeDb() throws IOException &#123; mDb.close(); &#125; @Test public void writeUserAndReadInList() throws Exception &#123; User user = TestUtil.createUser(3); user.setName(&quot;george&quot;); mUserDao.insert(user); List&lt;User&gt; byName = mUserDao.findUsersByName(&quot;george&quot;); assertThat(byName.get(0), equalTo(user)); &#125;&#125; 在电脑上测试Room使用SQLite Support Library，它提供了与Android Framework类中的接口相匹配的接口。此支持允许您传递支持库的自定义实现以测试数据库查询。 注意：即使此设置允许您的测试运行速度非常快，也不建议这样做，因为设备上运行的SQLite版本以及用户的设备可能与主机上的版本不匹配 使用Room引用复杂数据Room提供了原始和包装类型转换的功能，但是不允许实体间对象引用。这里会解释为什么不支持对象引用和怎么使用类型转换器。 使用类型转换器有时候你想存储自定义的数据类型在数据库的单个列中。这就需要为自定义类型添加一个类型转换器，这个转换器会将自定类型转换为Room能够认识的原始类型。 例如，我想保存Date类型的实例，我可以编写下面的类型转换器来在数据库中存储等效的Unix时间戳：1234567891011public class Converters &#123; @TypeConverter public static Date fromTimestamp(Long value) &#123; return value == null ? null : new Date(value); &#125; @TypeConverter public static Long dateToTimestamp(Date date) &#123; return date == null ? null : date.getTime(); &#125;&#125; 上面的例子定义了两个函数，一个是将Date对象转换为Long对象，另一个则相反，从Long对象到Date对象。因为，Room是知道怎么持久化Long对象的，所以能用这个转换器将Date对象持久化。 接下来，在AppDataBase类添加注解 @TypeConverters 这样AppDataBase中的Dao和实体就都能使用这个转换器了。 AppDatabase.java12345@Database(entities = &#123;User.class&#125;, version = 1)@TypeConverters(&#123;Converters.class&#125;)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125; 这样就可以使用自定义类型了，就像使用其他原始类型一样。 User.java12345@Entitypublic class User &#123; ... private Date birthday;&#125; UserDao.java 123456@Daopublic interface UserDao &#123; ... @Query(&quot;SELECT * FROM user WHERE birthday BETWEEN :from AND :to&quot;) List&lt;User&gt; findUsersBornBetweenDates(Date from, Date to);&#125; 还可以将@TypeConverters限制到不同的作用域,包括个体实体，DAO和DAO方法。关于 @TypeConverters更详细的介绍 请查看文档 https://developer.android.com/reference/android/arch/persistence/room/TypeConverters.html 理解Room不允许使用对象引用的原因关键问题：Room不允许实体类之间的对象引用。相反，您必须明确您的应用需要的数据。 将数据库中的关系映射到相应的对象模型是常见的做法，并且在服务器端运行良好。即使程序在访问时加载字段，服务器仍然运行良好。 但是，在客户端，这种延迟加载不可行，因为它通常发生在UI线程上，并且在UI线程中查询磁盘上的信息会产生严重的性能问题。UI线程通常具有约16 ms的时间来计算和绘制活动的更新布局，因此即使查询只需要5 ms，仍然可能您的应用程序将耗尽时间来绘制框架，从而导致明显的视觉干扰。如果有单独的事务并行运行，或者设备正在运行其他磁盘密集型任务，则查询可能需要更多时间才能完成。但是，如果不使用延迟加载，则应用会获取比所需更多的数据，从而导致内存消耗问题。 对象关系映射通常将这个决定留给开发人员，以便他们可以为他们的应用程序的用例做最好的事情。开发人员通常决定在应用程序和用户界面之间共享模型。然而，这种解决方案并不能很好地扩展，因为随着UI的变化，共享模型会产生一些难以让开发人员预测和调试的问题。 例如，考虑加载一个Book对象列表的UI，每个书都有一个Author对象。最初可能会将查询设计为使用延迟加载，以便Book的实例使用getAuthor（）方法返回作者。过了一段时间，你意识到你也需要在应用程序的用户界面中显示作者姓名。您可以轻松地添加方法调用，如以下代码片段所示：1authorNameTextView.setText(user.getAuthor().getName()); 但是，这个看起来无害的更改会导致在主线程上查询Author表。 如果提前查询作者信息，如果不再需要数据，则很难更改数据的加载方式。例如，如果您的应用程序的用户界面不再需要显示作者信息，则您的应用程序会有效地加载不再显示的数据，从而浪费宝贵的内存空间。如果作者类引用另一个表（如Books），则应用程序的效率会进一步降低。 要使用Room同时引用多个实体，需要创建一个包含每个实体的POJO，然后编写一个查询来加入相应的表。这种结构良好的模型与Room强大的查询验证功能相结合，可让您的应用在加载数据时消耗更少的资源，从而改善应用的性能和用户体验。 end]]></content>
      <categories>
        <category>Android</category>
        <category>Android Architecture Components</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Room</tag>
        <tag>Android Architecture Components</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 将 library module 发布到本地仓库，并添加本地依赖]]></title>
    <url>%2F2018%2F04%2F10%2Fpush-library-to-local-maven%2F</url>
    <content type="text"><![CDATA[将module发布到本地maven仓库 在本地准备一个目录，当做maven仓库 在项目的 gradle.properties 配置仓库信息(主要是POM文件信息) 在module的 build.gradle 配置插件，任务，及代码信息 执行发布任务 本地 maven 查看 引用本地仓库中的包 1. 准备目录Example: 1E:\libs\localMaven 2. 配置仓库信息在项目的 gradle.properties 中配置属性信息Example： 12345678910111213141516171819# 包信息PROJ_GROUP= 一般为公司域名PROJ_VERSION=版本# 项目的描述PROJ_WEBSITEURL= 项目地址PROJ_ISSUETRACKERURL= 提 issue 地址PROJ_DESCRIPTION= 项目介绍# Licence信息 这部分是固定的PROJ_LICENCE_NAME=The Apache Software License, Version 2.0PROJ_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txtPROJ_LICENCE_DEST=repo# Developer 信息 这里是开发者信息DEVELOPER_ID=mxcDEVELOPER_NAME=孟祥超DEVELOPER_EMAIL=skymxc@foxmail.com` 3. 为 module 配置插件，任务，代码信息为了优雅，在 module 下创建一个 gradle.properties 文件设置属性 1234PROJ_NAME=依赖名字 localrepoPROJ_ARTIFACTID=所属分类LOCAL_REPO_URL= 本地仓库的地址：file://+本地路径 ；例如 file://E:/libs/localMaven 在 module 的 build.gradle 中使用 maven 插件 定义上传任务 使用 maven 插件 1apply plugin: &apos;maven&apos; 定义上传任务12345678uploadArchives &#123; repositories.mavenDeployer &#123; repository(url: LOCAL_REPO_URL) pom.groupId = PROJ_GROUP pom.artifactId = PROJ_ARTIFACTID pom.version = android.defaultConfig.versionName &#125;&#125; Example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647apply plugin: 'com.android.library'apply plugin: 'maven'android &#123; compileSdkVersion 26 buildToolsVersion "26.0.2" defaultConfig &#123; minSdkVersion 19 targetSdkVersion 26 versionCode 1 versionName "1.0" &#125; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true zipAlignEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125; &#125; repositories&#123; flatDir&#123; dirs'libs' &#125; &#125;&#125;uploadArchives &#123; repositories.mavenDeployer &#123; repository(url: LOCAL_REPO_URL) pom.groupId = PROJ_GROUP pom.artifactId = PROJ_ARTIFACTID pom.version = android.defaultConfig.versionName &#125;&#125;dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs')&#125; 4. 执行命令 开始任务 我这里是 windows 系统 故使用 gradlew localrepo 就是本地的 module在 Android studio 的 Terminal 窗口 输入命令1gradlew -p localrepo clean build uploadArchives --info 5. 如果顺利执行成功的话 本地maven 目录中现在应该已经有了6. 引用本地依赖添加本地的 maven 地址 在项目的 build.gradle 1234567891011allprojects &#123; repositories &#123; jcenter() mavenCentral() google() maven &#123; url "https://jitpack.io" &#125; maven&#123; url 'file://E:/libs/localMaven/' &#125; &#125;&#125; 添加依赖 在 moudle 的 build.gradle1implementation 'cn.sintoon:localrepo:1.0' end 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1z0rlkggpcdck]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>push-to-local-maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的线程]]></title>
    <url>%2F2017%2F08%2F27%2Fthread-in-Android%2F</url>
    <content type="text"><![CDATA[Android 中线程的使用 线程Android官网文档-&gt;https://developer.android.com/guide/components/processes-and-threads.html?hl=zh-cn#Threads 应用启动时，系统会为应用创建一个线程，称为主线程；它负责UI的绘制以及UI的事件响应交互，也称为UI线程；系统不会为每个组件实例创建单独的线程，同一进程中的所有组件都在主线程实例化，并且每个组件的资源调用都由主线程分配，因此响应系统回调都在主线程进行。因为主线程要处理UI的绘制及事件的交互，所以主线程中不能进行耗时的操作（网络访问，数据库操作），一旦主线程进行耗时操作就会出现阻塞，UI事件就没办法响应了，就会出现ANR，这是非常不友好的。 Android UI是非线程安全的，所以关于UI的操作只能在UI线程操作，所以Android单线程模式必须遵守两条规则 不能阻塞UI线程 UI操作要在UI线程，不要在 UI 线程之外访问 Android UI 工具包 工作线程 为了保证应用的顺畅，所有耗时的操作都在工作线程中进行。 遵循上述的两条规则，不能再UI线程之外的线程访问UI，但是网络访问结果是在工作线程，要将结果填充到UI中怎么办呢，Android提供了几种方法在工作线程中访问UI Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) Handler 还有一种方式 AsyncTask; 线程相关API Runnable Thread Callable Future&lt;?&gt; RunnableFuture FutureTask Executor ExecutorService ThreadPoolExecutor Executors 创建线程 有两种方式创建一个线程。 继承 Thread类 实现 Runnable接口 继承Thread类 重写 run方法，在调用start()后JVM会自动调用run()方法 1234567891011121314151617181920212223242526/** * 通过继承Thread 创建一个Thread */class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; /** * 重写run方法 JVM会自动调用此方法 */ @Override public void run() &#123; // logic code &#125; /** * 重载（Overload）run()方法 和普通的方法一样，并不会在该线程的start()方法被调用后被JVM自动运行 * * @param str */ public void run(String str) &#123; Log.e(&quot;run&quot;, str + &quot;&quot;); &#125;&#125; 实现 Runnable接口 1234567891011121314/** * 通过实现 Runnable 创建一个线程 */class MyRunnable implements Runnable &#123; /** * JVM会自动调用此方法 */ @Override public void run() &#123; //logic code &#125;&#125; 启动线程 继承Thread方式 12MyThread thread0 = new MyThread(); thread0.start(); 实现 Runnable方式 123MyRunnable myRunnable = new MyRunnable();Thread thread1 = new Thread(myRunnable);thread1.start(); Runnable和Thread两种方式的区别和联系 其实这块主要是围绕着接口和抽象类的区别以及一些设计原则而言的。 Java是单继承的，你继承了Thread类再也无法继承别的类。 Java虽然是单继承但是可以实现多接口的，即使你实现Runnable，你也可以实现别的接口。 在面向对象编程中，继承一个类就意味着要使用或者改善某些功能，如果不准备改善Thread提供的封装好的功能，使用Runnable更好。 Runnable接口表示一个任务，可以被任意一个普通线程，线程池或者其他方式执行。逻辑上的分离，Runnable比Thread更好。 将任务分离为Runnable，就可以重用或者通过其他方式执行它，Thread一旦完成就无法重新启动了。 线程池的接口接收的参数为Runnable 用Runnable能够代表一个线程就不必继承Thread，那样就额外的继承了Thread的全部方法 继承Thread，你就必须为每个线程都创建一个实例，然后为每个实例分配内存。 写一个接口而不是实现，会让程序更容易扩展。 Thread类也是实现了Runnable接口 参考资料 https://www.linkedin.com/pulse/20140917120728-90925576-difference-between-implements-runnable-and-extends-thread-in-java https://my.oschina.net/leejun2005/blog/483999 这个重点看评论-&gt;http://mars914.iteye.com/blog/1508429 资源共享及同步问题 关于多线程资源共享，多线程并发操作有随机性，不能保证每个线程都顺序的去访问某个资源，在多个线程同时去访问一个资源的时候要进行资源的同步. 经典的卖票例子 资源共享 资源共享，多个线程并发执行访问同一个资源，才是共享的资源。 票 1234567891011121314/** * 票 */class Tickets &#123; int num = 5; public int get() &#123; return num; &#125; public void set(int num) &#123; this.num = num; &#125;&#125; 卖票程序 12345678910111213141516171819202122232425262728/** * 卖票 程序 */class SaleRunnable implements Runnable &#123; private Tickets tickets; public SaleRunnable(Tickets tickets) &#123; this.tickets = tickets; &#125; @Override public void run() &#123; while (tickets.get() &gt; 0) &#123; Log.e(Thread.currentThread().getName(), &quot;销售第&quot; + tickets.get() + &quot;张，剩余&quot; + (tickets.get() - 1) + &quot;张&quot;); tickets.set(tickets.get() - 1); try &#123; //延迟 1000 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Log.e(Thread.currentThread().getName(), &quot;没票了&quot;); &#125;&#125; 卖票 1234567//票资源Tickets tickets = new Tickets();SaleRunnable saleRunnable = new SaleRunnable(tickets);//开三个窗口使用同一程序去卖票 new Thread(saleRunnable, &quot;窗口零&quot;).start();new Thread(saleRunnable, &quot;窗口一&quot;).start();new Thread(saleRunnable, &quot;窗口二&quot;).start(); 卖票结果 多线程并发执行的结果就是 多个窗口同时售票，同一时间销售掉了同一个票，尴尬了，一个票卖了多次 1234567891011121314151617181920212223242526272808-22 14:23:41.066 E/窗口零: 销售第5张，剩余4张08-22 14:23:41.066 E/窗口一: 销售第4张，剩余3张08-22 14:23:41.076 E/窗口二: 销售第3张，剩余2张08-22 14:23:42.066 E/窗口零: 销售第2张，剩余1张08-22 14:23:42.076 E/窗口二: 销售第2张，剩余1张08-22 14:23:42.076 E/窗口一: 销售第2张，剩余1张08-22 14:23:43.076 E/窗口一: 没票了08-22 14:23:43.076 E/窗口二: 没票了08-22 14:23:43.076 E/窗口零: 没票了08-22 14:24:29.866 E/窗口零: 销售第5张，剩余4张08-22 14:24:29.866 E/窗口一: 销售第4张，剩余3张08-22 14:24:29.866 E/窗口二: 销售第3张，剩余2张08-22 14:24:30.866 E/窗口零: 销售第2张，剩余1张08-22 14:24:30.866 E/窗口二: 销售第1张，剩余0张08-22 14:24:30.866 E/窗口一: 销售第2张，剩余1张08-22 14:24:31.866 E/窗口零: 没票了08-22 14:24:31.866 E/窗口二: 没票了08-22 14:24:31.866 E/窗口一: 没票了08-22 14:24:51.906 E/窗口二: 销售第5张，剩余4张08-22 14:24:51.906 E/窗口一: 销售第4张，剩余3张08-22 14:24:51.906 E/窗口零: 销售第3张，剩余2张08-22 14:24:52.906 E/窗口二: 销售第2张，剩余1张08-22 14:24:52.906 E/窗口一: 销售第2张，剩余1张08-22 14:24:52.916 E/窗口零: 没票了08-22 14:24:53.916 E/窗口二: 没票了08-22 14:24:53.916 E/窗口一: 没票了 资源同步 Java 同步块（synchronized block）用来标记方法或者代码块是同步的 java中每个对象都对应于一个称为“互斥锁”的标志，这个标志用来保证在任何时刻，只能有一个线程访问该对象。如果系统中的资源当前没有被使用，线程可以得到“互斥锁”，即线程可以得到资源的使用权。当线程执行完毕后，他放弃“互斥锁”，如果一个线程获得“互斥锁”时，其余的线程就必须等待当前线程结束并放弃“互斥锁”。在java中，提供了关键字synchronized来实现对象的“互斥锁”关系。当某个对象或方法用关键字synchronized修饰时，表明该对象或方法在任何一个时刻只能有一个线程访问。如果synchronized用在类的声明中，表明该类中的所有方法都是synchronized的。 在这个例子中，我们只需要将“票”这个资源同步即可 多个线程都是访问的这一个实例，所以同步这个实例方法，就可以了； 1234567891011121314151617181920212223242526272829303132333435363738/** * 卖票 程序 */class SaleRunnable implements Runnable &#123; private Tickets tickets; public SaleRunnable(Tickets tickets) &#123; this.tickets = tickets; &#125; @Override public void run() &#123; while (true) &#123; if (sale()) &#123; break; &#125; try &#123; //延迟 1000 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Log.e(Thread.currentThread().getName(), &quot;没票了&quot;); &#125; private synchronized boolean sale() &#123; if (tickets.get() &gt; 0) &#123; Log.e(Thread.currentThread().getName(), &quot;销售第&quot; + tickets.get() + &quot;张，剩余&quot; + (tickets.get() - 1) + &quot;张&quot;); tickets.set(tickets.get() - 1); return false; &#125; return true; &#125;&#125; 或者 12345678910111213141516171819202122232425262728293031323334/** * 卖票窗口 */class SaleThread extends Thread &#123; private Tickets tickets; public SaleThread(Tickets ti, String name) &#123; super(name); tickets = ti; &#125; @Override public void run() &#123; while (true) &#123; //同步这个资源 synchronized (tickets) &#123; if (tickets.get() &gt; 0) &#123; Log.e(Thread.currentThread().getName(), &quot;销售第&quot; + tickets.get() + &quot;张，剩余&quot; + (tickets.get() - 1) + &quot;张&quot;); tickets.set(tickets.get() - 1); &#125; else &#123; break; &#125; &#125; try &#123; //延迟 1000 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Log.e(Thread.currentThread().getName(), &quot;没票了&quot;); &#125;&#125; 学习资料 http://ifeve.com/java-concurrency-thread-directory/ http://ifeve.com/synchronized-blocks/ http://student-lp.iteye.com/blog/2083170 http://www.cnblogs.com/dennisit/archive/2013/02/24/2925288.html http://lanvis.blog.163.com/blog/static/26982162009798422547/ 线程状态 新生状态（new） 当一个线程的实例被创建即使用new关键字后台Thread类或者其子类创建一个线程对象后，此时该线程就处于新生状态，处于新生状态的线程有自己的内存空间，但该线程并没有运行，此时线程还不是活着的（not alive） 就绪状态（Runnable） 通过调用线程实例的start()方法来启动线程使线程进入就绪状态(runnable);处于就绪状态的线程已经具备了运行条件，但还没被分配到CPU就是不一定会被立即执行，此时处于线程就绪队列，等待线程为期分配CPU，等待状态不是执行状态；此时线程是活着的（alive）； 运行状态（Running） 一旦获取CPU（被JVM选中），线程就进入运行（running）状态，线程run()方法才开始被执行；在运行状态的线程执行自己的run()方法中的操作，知道调用其他的方法而终止、或者等待某种资源而阻塞、或者完成任务而死亡；如果在给定的时间片内没有执行结束，就会被系统给换下来回到线程的就绪状态；此时线程是活着的（alive）； 阻塞状态（Blocked） 通过调用join(),sleep(),wait()或者资源被占用使线程处于阻塞(blocked)状态；处于Blocked状态的线程仍然是活着的（alive）； 死亡状态（Dead） 当一个线程的run()方法运行完毕或被中断或被异常退出，该线程到达死亡(dead)状态。此时可能仍然存在一个该Thread的实例对象，但该Thread已经不可能在被作为一个可被独立执行的线程对待了，线程的独立的call stack已经被dissolved。一旦某一线程进入Dead状态，他就再也不能进入一个独立线程的生命周期了。对于一个处于Dead状态的线程调用start()方法，会出现一个运行期(runtime exception)的异常；处于Dead状态的线程不是活着的（not alive）。 学习资料 http://www.cnblogs.com/DreamSea/archive/2012/01/11/JavaThread.html http://www.cnblogs.com/whoislcj/p/5603277.html http://student-lp.iteye.com/blog/2083170 线程通信 Java中常规的通信方式这里我就不说了，看一下Android的消息机制 Java常规的通信方式传送门-&gt;http://ifeve.com/thread-signaling Android中的消息机制可以用于线程间通信也可用于在各个组件间通信,这里只总结一下怎么在线程间使用 消息机制中重要的API Message 线程间通信就是在传递消息，Message就是消息的载体。常用的有四个字段：arg1，arg2，what，obj。obj可以携带Object对象，其余三个可以携带整形数据 MessageQueue 消息队列，它主要用于存放所有通过Handler发送的消息（也就是一个个Message），这部分的消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。 Looper 每个线程通过Handler发送的消息都保存在，MessageQueue中，Looper通过调用loop()的方法，就会进入到一个无限循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中。 Handler 发送消息，处理消息 Thread 线程 每个线程中只会有一个Looper对象。 运行机制 在哪个Thread中创建Handler，默认情况下Handler就会获取哪个线程中的Looper（前提是Looper创建好了）；handler发送消息就是将消息发送到了自己持有的这个Looper对象里；Looper内有一个MessageQueue，消息就存放在队列里，一旦Looper的loop()方法被调用就会开启无限循环模式，一直循环遍历这个队列，从中取Handler发送的消息，没有消息就阻塞；一旦有消息就唤醒线程取出来；从MessageQueue中取出的消息，会调用本身target持有的handler实例来处理这个消息; 综上所述，线程间通信handler就可以实现； 主线程给工作线程发消息 想要在主线程给工作线程发消息，我们就得持有在工作线程中创建的handler；而创建handler之前必须先初始化一下Looper对象；handler创建完之后就开启Looper的无限循环来等待消息 创建一个线程并创建一个handler 123456789101112131415161718192021222324252627Handler handlerA = null; class ThreadA extends Thread implements Handler.Callback &#123; public ThreadA() &#123; super(&quot;ThreadA&quot;); &#125; @Override public void run() &#123; //创建此线程的Looper对象 ，一个线程只能有一个，所以此方法只能调用一次 Looper.prepare(); handlerA = new Handler(this); //开始循环遍历 Looper.loop(); &#125; @Override public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case 100: Log.e(&quot;handleMessage&quot;, Thread.currentThread().getName() + &quot;;src-&gt;&quot; + msg.obj); break; &#125; return false; &#125; &#125; 使用handlerA发送消息 12345678910//创建一个消息Message msg = new Message();msg.what = 100; //标识你这消息想要干啥msg.obj = Thread.currentThread().getName();/** * 因为handler 里持有所在线程的Looper，所有handler发送的消息会在所在线程中执行 *///发送给A线程handlerA.sendMessage(msg); 看一个log 处理线程是ThreadA，消息来源是Main线程108-23 16:26:02.609 E/handleMessage: ThreadA;src-&gt;main 工作线程发给主线程 与上面的同理，想要给主线程发送消息，拿到主线程的handler就可以了； 因为点击事件是在UI线程中响应的，所以想让工作线程给主线程发送一个消息就麻烦一点，我这里为了测试做了个中转，先给B线程发送一个信号，B接到这个信号就给主线程发消息 12345678910111213141516171819202122232425262728293031class ThreadB extends Thread implements Handler.Callback &#123; public ThreadB() &#123; super(&quot;ThreadB&quot;); &#125; @Override public void run() &#123; Looper.prepare(); handlerB = new Handler(this); Looper.loop(); &#125; @Override public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case 100: Log.e(&quot;handleMessage&quot;, Thread.currentThread().getName() + &quot;;src-&gt;&quot; + msg.obj); break; case 101: //给main发送一个消息 Message message = new Message(); message.what = 100; message.obj = Thread.currentThread().getName(); handler.sendMessage(message); break; &#125; return false; &#125;&#125; 在主线程创建的handler 1234567891011/** * Main 的handler * 程序启动的时候就为Main线程创建了Looper */Handler handler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; Log.e(&quot;handleMessage&quot;, Thread.currentThread().getName() + &quot;;src-&gt;&quot; + msg.obj); return false; &#125;&#125;); 主线程的handler创建时没有提前创建Looper也没有调用Looper的loop()方法，是因为程序在启动的时候已经为主线程创建好了Looper，并且调用了loop(),一直在等待消息 工作线程给工作线程发消息 跟上面两个一样，想给哪个线程发消息就要先拿到哪个线程的handler；我这里就不贴代码了； 学习资料 http://www.jianshu.com/p/02962454adf7 http://www.jianshu.com/p/7657f541c461 http://www.cnblogs.com/younghao/p/5116819.html http://www.voidcn.com/article/p-pmejydob-bbs.html 线程池 为啥使用线程池 减少频繁创建销毁线程带来的开销 复用创建好的线程 对线程进行简单的管理 ExecutorService是一个接口，定义了线程池的方法。 1234567891011121314151617181920212223242526public interface ExecutorService extends Executor &#123; void shutdown();//关闭线程池，不再接受新任务，当所有任务都执行完毕后，关闭线程池 List&lt;Runnable&gt; shutdownNow(); //关闭线程池，阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表 boolean isShutdown(); //是否关闭 boolean isTerminated();//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位 如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; var1); //提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。 &lt;T&gt; Future&lt;T&gt; submit(Runnable var1, T var2); // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果 Future&lt;?&gt; submit(Runnable var1);///提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) throws InterruptedException; //执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, long var2, TimeUnit var4) throws InterruptedException; //执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) throws InterruptedException, ExecutionException; //执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, long var2, TimeUnit var4) throws InterruptedException, ExecutionException, TimeoutException;&#125; ThreadPoolExecutor具体实现了ExecutorService接口，提供了一系列的参数来配置线程池，熟悉ThreadPoolExecutor可自定义线程池。 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; corePoolSize 核心线程池数量 maximumPoolSize 最大线程数量 keepAliveTime 非核心线程闲置的超时时长，超过这个时长，非核心线程就会被回收,当allowCoreThreadTimeOut为true时，keepAliveTime同样作用于核心线程。 unit 时间单位，常用的为 TimeUnit.MILLISECONDS(毫秒)、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES(分钟)，详情-》https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/TimeUnit.html workQueue 线程池中的任务队列，通过execute方法提交的Runnable对象会存储在这个参数中 threadFactory 线程工厂，为线程池提供创建线程的功能，是个接口，提供Thread newThread(Runnable r)方法；通常用默认的Executors.defaultThreadFactory()即可 handler 拒绝策略，当线程池无法执行新任务时，可能由于线程队列已满或无法成功执行任务，这时候 ThreadPoolExecutor会调用handler的 rejectedExecution的方法，默认会抛出RejectedExecutionException Android通过Executors为我们提供了几种线程池 方法 说明 Executors.newCachedThreadPool() 缓存线程池，线程数量不定，最大线程数为Integer.MAX_VALUE(相当于任意大),有新任务时会检查是否有空闲线程，没有则会创建线程，空闲线程超过60s会被回收，任何任务都会被立即执行，适合大量的耗时较少任务 Executors.newFixedThreadPool(int nThreads) 固定型线程池，线程数量固定，只有核心线程并且无超时机制，当所有线程都执行任务时，新任务进入队列等待。能够快速响应请求 Executors.newScheduledThreadPool(int corePoolSize) 调度型线程池，核心数量固定，非核心数量无限制，非核心线程一旦空闲立马回收。会根据Scheduled(任务列表)进行延迟执行，或者是进行周期性的执行.适用于一些周期性的工作 EExecutors.newSingleThreadExecutor() 单例线程池，只有一个核心线程，所有任务都在这个线程中串行执行，不需要处理线程同步问题，在任意的时间段内，线程池中只有一个线程在工作… 在ExecutorService的方法中可以看到线程池除了可执行Runnable接口还可以执行Callable&lt;V&gt; 接口,并且可以通过Future&lt;V&gt;来感知线程状态和结果。 因为Runnable的返回值为void 无法获取执行完毕后的结果 ，所以才有了Callable&lt;V&gt;，可以返回一个结果123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Future&lt;V&gt; 定义了几种方法来感知线程状态和获取结果 ，可以理解为管理线程的。Future提供了三种功能： 判断任务是否完成； 能够中断任务； 能够获取任务执行结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface Future&lt;V&gt; &#123; /** * 尝试取消执行此任务。 如果任务已经完成，已经被取消或由于某种其他原因而无法取消，则此尝试将失败。返回false。 * 当此方法调用时此任务尚未开始，则此任务不会被运行。返回true。 * 如果任务已经开始，则&#123;mayInterruptIfRunning&#125;参数确定执行此任务的线程是否应该中断，以试图停止该任务。 * 此方法返回后，对&#123;@link #isDone&#125;的后续调用将始终返回&#123;@code true&#125;。 * 如果此方法返回&#123;@code true&#125;，则后续调用&#123;@link #isCancelled&#125;将始终返回&#123;@code true&#125;。 * @param mayInterruptIfRunning 线程在运行是否中断; 如果值为true表示中断正在进行的任务返回则返回true，值为false表示不中断返回false，如果任务无法取消，通常是因为它已经正常完成; * &#123;@code true&#125; otherwise */ boolean cancel(boolean mayInterruptIfRunning); /** * 如果在完成之前被取消 则返回 true，否则返回false * * @return &#123;@code true&#125; if this task was cancelled before it completed */ boolean isCancelled(); /** * 任务已经完成 返回 true。 * 任务被取消，异常，或者正常完成都会返回 true。此方法返回结果表示任务是否允许完毕 * @return &#123;@code true&#125; if this task completed */ boolean isDone(); /** * 获取任务完成的结果，如果任务没有执行完毕，则阻塞线程，直到拿到结果 * @return the computed result * @throws CancellationException if the computation was cancelled * @throws ExecutionException if the computation threw an * exception * @throws InterruptedException if the current thread was interrupted * while waiting */ V get() throws InterruptedException, ExecutionException; /** * 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null * @param timeout 指定等待时间 * @param unit 等待时间单位 * @return the 执行结果 * @throws CancellationException if the computation was cancelled * @throws ExecutionException if the computation threw an * exception * @throws InterruptedException if the current thread was interrupted * while waiting * @throws TimeoutException if the wait timed out */ V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。 可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;&#125; 1234public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; ScheduledExecutorService 调度线程池 ，扩展了ExecutorService,增加了几个方法用来执行周期性或者定时的任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public interface ScheduledExecutorService extends ExecutorService &#123; /** * 在给定延迟时间后执行一个单次的操作 * @param command 要执行的操作 * @param delay 延迟时间 * @param unit 延迟时间单位 * @return a ScheduledFuture 代表一个未完成的任务，可以通过get()获取null，还可以通过getDelay()获取剩余延迟时间 * @throws RejectedExecutionException if the task cannot be * scheduled for execution * @throws NullPointerException if command is null */ public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit); /** * 在给定延迟时间后执行一个单次的 操作 * @param callable 单次操作 * @param delay 延迟时间 * @param unit 延迟时间单位 * @param &lt;V&gt; 返回结果类型 * @return a ScheduledFuture 可以通过get() 拿到结果，可以通过getDelay() 获取剩余延迟时间； * @throws RejectedExecutionException if the task cannot be * scheduled for execution * @throws NullPointerException if callable is null */ public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit); /** * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期； * 也就是将在 initialDelay 后开始执行，然后在initialDelay+period 后执行， * 接着在 initialDelay + 2 * period 后执行，依此类推。 * @param command 要执行的操作 * @param initialDelay 首次执行延迟时间 * @param period 执行周期时间 * @param unit 时间单位 * @return a ScheduledFuture representing pending completion of * the series of repeated tasks. The future&apos;s &#123;@link * Future#get() get()&#125; method will never return normally, * and will throw an exception upon task cancellation or * abnormal termination of a task execution. * @throws RejectedExecutionException if the task cannot be * scheduled for execution * @throws NullPointerException if command is null * @throws IllegalArgumentException if period less than or equal to zero */ public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); /** * 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 * @param command 要执行的定期任务 * @param initialDelay 首次执行的延迟时间 * @param delay 再上一次任务执行完毕后下次要执行的延迟时间 * @param unit 时间单位 * @return a ScheduledFuture representing pending completion of * the series of repeated tasks. The future&apos;s &#123;@link * Future#get() get()&#125; method will never return normally, * and will throw an exception upon task cancellation or * abnormal termination of a task execution. * @throws RejectedExecutionException if the task cannot be * scheduled for execution * @throws NullPointerException if command is null * @throws IllegalArgumentException if delay less than or equal to zero */ public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);&#125; 关于几种线程池的使用，代码都放在我的GitHub了。 学习资料 https://developer.android.com/reference/java/util/concurrent/ScheduledExecutorService.html https://tom510230.gitbooks.io/android_ka_fa_yi_shu_tan_suo/content/chapter11.html http://www.cnblogs.com/whoislcj/p/5607734.html http://blog.csdn.net/u010687392/article/details/49850803 http://www.cnblogs.com/RGogoing/p/4766971.html http://www.cnblogs.com/dolphin0520/p/3949310.html 关于本次的Demo https://github.com/sky-mxc/AndroidDemo/tree/master/thread 没有涉及到的地方，欢迎补充。错误的地方，感谢指正]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3 学习笔记]]></title>
    <url>%2F2017%2F08%2F08%2FEventBus%2F</url>
    <content type="text"><![CDATA[脑图 概述EventBus 是一款针对Android优化的发布/订阅(publish/subscribe)事件总线。主要功能是替代Intent，Handler，Broadcast在Fragment，Activity，Service，线程之间传递消息。简化了应用程序内各组件，组件与后台线程间的通信。优点代码简洁，以及将发送者和订阅者解耦。 基本使用使用步骤 添加依赖 定义事件 注册/取消订阅 发送事件 添加依赖1compile &apos;org.greenrobot:eventbus:3.0.0&apos; 定义事件 这里的事件是一个任意的POJO 没有任何要求 12345678public class MessageEvent &#123; public final String message; public MessageEvent(String message) &#123; this.message = message; &#125;&#125; 订阅 准备订阅者 使用注解 @Subscribe ，在3.0中对方法名称没有任何要求 当发送事件时EventBus会调用方法 1234567891011// This method will be called when a MessageEvent is posted (in the UI thread for Toast)@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) &#123; Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();&#125;// This method will be called when a SomeOtherEvent is posted@Subscribepublic void handleSomethingElse(SomeOtherEvent event) &#123; doSomethingWith(event);&#125; 注册/取消订阅 1234567891011@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;@Overridepublic void onStop() &#123; EventBus.getDefault().unregister(this); super.onStop();&#125; 发送事件 1EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;)); 官网指南 http://greenrobot.org/eventbus/documentation/how-to-get-started/ 交付线程 Delivery Threads (ThreadMode)EventBus 通过 threadMode 决定订阅事件 在哪个线程处理，threadMode的取值 有四个枚举类型 POSTING MAIN BACKGROUND ASYNC POSTING。 默认值，将会与发送线程一致，发送事件在哪个线程，订阅者就在哪个线程处理 1234567// Called in the same thread (default)// ThreadMode is optional here@Subscribe(threadMode = ThreadMode.POSTING)public void onMessage(MessageEvent event) &#123; log(event.message);&#125; MAIN 。 UI线程，订阅者将会在UI线程处理 123456// Called in Android UI&apos;s main thread@Subscribe(threadMode = ThreadMode.MAIN)public void onMessage(MessageEvent event) &#123;textField.setText(event.message);&#125; BACKGROUND 。 后台线程处理，如果发送者在UI线程发出就会另开线程处理，否则就直接在同一线程处理，不会在UI线程处理就对了 123456// Called in the background thread@Subscribe(threadMode = ThreadMode.BACKGROUND)public void onMessage(MessageEvent event)&#123; saveToDisk(event.message);&#125; ASYNC 。异步，订阅者将会另开一个线程处理，无论发送者从哪个线程发出 123456// Called in a separate thread@Subscribe(threadMode = ThreadMode.ASYNC)public void onMessage(MessageEvent event)&#123; backend.send(event.message);&#125; 官网指南 http://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/ 优先级及事件取消 Priorities and Event Cancellation 优先级 EventBus 通过 priority 属性决定优先级 ，默认0 值越高 优先级越高。 12345@Subscribe(priority = 1);public void onEvent(MessageEvent event) &#123; ...&#125; 事件取消 EventBus 通过 cancelEventDelivery(Object event) 取消事件，这可是优先级高的特权了。 123456789// Called in the same thread (default)@Subscribepublic void onEvent(MessageEvent event)&#123; // Process the event ... // Prevent delivery to other subscribers EventBus.getDefault().cancelEventDelivery(event) ;&#125; 官网指南 http://greenrobot.org/eventbus/documentation/priorities-and-event-cancellation/ 配置 Configuration一般我们使用 EventBus.getDefault() 得到EventBus实例，如果有别的需求可以使用 EventBusBuilder 类构建EventBus，例如 关闭log 1234EventBus eventBus = EventBus.builder() .logNoSubscriberMessages(false) .sendNoSubscriberEvent(false) .build(); 或者说 当订阅者抛出异常时 发送 SubscriberExceptionEvent 事件 1EventBus eventBus = EventBus.builder().throwSubscriberException(true).build(); 默认情况下 订阅者抛出异常EventBus会捕获异常并发一个 SubscriberExceptionEvent 事件 我们可以通过 installDefaultEventBus()方法我们的配置放到默认实例上；但是要在使用 EventBus.getDefault()之前 1EventBus.builder().throwSubscriberException(BuildConfig.DEBUG).installDefaultEventBus(); 官网指南 http://greenrobot.org/eventbus/documentation/configuration/ 粘性事件 Sticky Events对于一般的事件，我们首先要注册订阅者，然后发送事件，订阅者才能收到事件。如果先发送事件，再订阅此事件，将收不到事件，而粘性事件恰恰相反，粘性事件是可以先发送，然后再注册订阅者，后注册的订阅者依然可以接收到事件（ps：在发送前注册的也可以收到） 先发送粘性事件 1EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello everyone!&quot;)); 再启动一个Activity 仍然可以接受到之前发送的事件 属性 sticky 的取值决定是否是粘性事件 ps:你不注册的话，啥事件也是收不到的 1234567891011121314151617@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;// UI updates must run on MainThread@Subscribe(sticky = true, threadMode = ThreadMode.MAIN)public void onEvent(MessageEvent event) &#123; textField.setText(event.message);&#125;@Overridepublic void onStop() &#123; EventBus.getDefault().unregister(this); super.onStop();&#125; 移除粘性事件 如果你不移除粘性事件，那么它将一直存在，直到你程序被杀死 1234567MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class);// Better check that an event was actually posted beforeif(stickyEvent != null) &#123; // &quot;Consume&quot; the sticky event EventBus.getDefault().removeStickyEvent(stickyEvent); // Now do something with it&#125; 官网传送门 http://greenrobot.org/eventbus/documentation/configuration/sticky-events/ 订阅索引 Subscriber Index订阅索引是3.0中的新特性，是可选项。 在3.0中由于使用了注解，比起使用反射来遍历方法的2.4版本逊色不少。但开启索引后性能远远超出旧版本。看作者放出的图 既然使用索引后那么叼，那就看看怎么使用索引 注意项 只有@Subscribe 可以被索引，必须是 public修饰 不能再内部类中 使用 apt插件的方式 顶级 build.gradle 中加入 123456buildscript &#123; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125;&#125; 再module的build.gradle 中使用 apt插件 12apply plugin: &apos;com.android.application&apos;apply plugin: &apos;com.neenbedankt.android-apt&apos; module的build.gradle 添加依赖 1234dependencies &#123; compile &apos;org.greenrobot:eventbus:3.0.0&apos; apt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;&#125; module 的 build.gradle 配置参数 ，这里写自己的包名 12345apt &#123; arguments &#123; eventBusIndex &quot;com.example.myapp.MyEventBusIndex&quot; &#125;&#125; 使用索引 编译过后 会生成 MyEventBusIndex类，没有生成就多编译几遍 1EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build(); 将索引配置到默认实例中 123EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();// Now the default instance uses the given index. Use it like this:EventBus eventBus = EventBus.getDefault(); 还可以添加多个不同的library中索引 123EventBus eventBus = EventBus.builder() .addIndex(new MyEventBusAppIndex()) .addIndex(new MyEventBusLibIndex()).build(); 官网指南 http://greenrobot.org/eventbus/documentation/subscriber-index/ 混淆 ProGuard12345678910-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; 官网指南 http://greenrobot.org/eventbus/documentation/proguard/ AsyncExecutor懒得翻译了，直接看吧http://greenrobot.org/eventbus/documentation/asyncexecutor/ 参考感谢各位大神的分享 https://juejin.im/entry/570ae5668ac247004c3128a4 https://dev.qq.com/topic/59190e9ae315487c53deeca3 http://www.jianshu.com/p/4a3d953d1319 Demo地址： https://github.com/sky-mxc/AndroidDemo/tree/master/event]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewDragHelper使用笔记及侧滑菜单实践]]></title>
    <url>%2F2017%2F07%2F29%2Fandroid-ViewDragHelper%2F</url>
    <content type="text"><![CDATA[ViewDragHelper 一个拖拽实现的帮助类，存在于v4包中，对于实现简单的拖拽简直不要太简单；再也不用去重写onTouch()了； 官网API https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html 该类主要用于拖拽view的实现，例如侧滑菜单时候的左右拖拽或者上下拖拽 使用方法 创建 ViewDragHelper实例 123ViewDragHelper create (ViewGroup forParent, float sensitivity, ViewDragHelper.Callback cb) 参数1 要使用DragHelper的布局 参数2 灵敏度，值越大越灵敏，1.0属于正常 参数3 回调，这里是主要阵地 事件拦截于处理 重写布局的 onInterceptTouchEvent()方法 ，ViewDragHelper会自行判断是否需要拦截事件 1234@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev);&#125; 重写布局的 onTouchEvent() 处理拦截的事件 12345@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mDragHelper.processTouchEvent(event); return true;&#125; 如果需要滑动动画 重写 computeScroll() 12345678910/** * 因为要在 DragHelper的中使用动画 */@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 前面在创建ViewDragHelper的时候用到了一个Callback，其实主要是在这里添加自己的逻辑，主要介绍一下这个类 这是一个抽象类，我们必须要实现的方法只有一个tryCaptureView() 1public abstract boolean tryCaptureView(View child, int pointerId); 参数1 准备捕获的子view 参数2 准备捕获的指针ID 该方法的返回值决定了ViewDragHelper是否要捕获这个view；如果返回false就不捕获； 说的一下我的思路吧，我在父布局中持有了需要拖拽处理的子view的引用，如果捕获的view是我持有的view就返回true，捕获这次事件 1234567891011/** * 决定是否捕获此view * 这里自由决定 * @param child 待捕获的子元素 * @param pointerId * @return 是否捕获 */@Overridepublic boolean tryCaptureView(View child, int pointerId) &#123; return child==mContentView;&#125; 如果你需要处理水平拖拽，重写 clampViewPositionHorizontal() 即可，该方法返回值就是view拖拽后的坐标值;默认是不处理的； 下面是我的实现，为了防止拖拽出屏幕做了简单处理 123456789101112131415/** * 水平 拖动 * @param child 拖动的元素 * @param left 将要去往的位置 * @param dx 拖动了的距离 * @return 新位置 */@Overridepublic int clampViewPositionHorizontal(View child, int left, int dx) &#123; //限制在容器内 int leftBound = getPaddingLeft(); int rightBound = getWidth() - mContentView.getWidth(); int newLeft = Math.min(Math.max(left,leftBound),rightBound); return newLeft;&#125; 如果需要处理垂直拖拽，重写 clampViewPositionVertical() ；该方法和上面的那个方法一样，返回值就是view拖拽后的坐标值；默认不处理； 1234567891011121314/** * 垂直拖动 * @param child * @param top * @param dy * @return */@Overridepublic int clampViewPositionVertical(View child, int top, int dy) &#123; int topBound = getPaddingTop(); int bottomBound = getHeight() - mContentView.getHeight(); int newTop = Math.min(Math.max(top,topBound),bottomBound); return newTop;&#125; 可以从onViewDragStateChanged()方法中得到ViewDragHelper的状态变化 1234567891011121314@Overridepublic void onViewDragStateChanged(int state) &#123; switch (state)&#123; case ViewDragHelper.STATE_IDLE: Log.e(&quot;onViewDragStateChanged&quot;,&quot;state--&gt;STATE_IDLE&quot;+state); break; case ViewDragHelper.STATE_DRAGGING: Log.e(&quot;onViewDragStateChanged&quot;,&quot;state--&gt;STATE_DRAGGING&quot;+state); break; case ViewDragHelper.STATE_SETTLING: Log.e(&quot;onViewDragStateChanged&quot;,&quot;state--&gt;STATE_SETTLING&quot;+state); break; &#125;&#125; 当子view的位置发生变化会触发 onViewPositionChanged() 方法 1234567891011/** * 当 view 的 position发生改变时触发 * @param changedView 拖动的view * @param left 新位置 X轴 * @param top 新位置 Y轴 * @param dx 从上次位置 到这次位置移动的距离 X轴 * @param dy 从上次位置 到这次位置移动的距离 Y轴 */@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123;&#125; 拖动动作停止，可以从 onViewReleased() 中得到速度信息 12345678910/** * * @param releasedChild * @param xvel x 轴速度 每秒移动的像素值 * @param yvel Y 轴速度 每秒移动的像素值 */@Overridepublic void onViewReleased(View releasedChild, float xvel, float yvel) &#123; Log.e(&quot;onViewReleased&quot;,&quot;xvel--&gt;&quot;+xvel+&quot;;yvel--&gt;&quot;+yvel);&#125; 我用到的就这些，就介绍这些吧 ，实现了一个可以自由拖动的layout 看Demo中的DragLayout ； https://github.com/sky-mxc/AndroidDemo/tree/master/drag 侧滑菜单实现以前写过一个侧滑菜单，思路是重写 ListView或者RecycleView 的onTouch事件，判断根据坐标点判断找到子view，然后让子view滑动，从而实现的侧滑。感觉比较麻烦。今天说一下另外一个思路， 写一个通用的布局，例如一个LineaLayout,里面定义两个Group，一个是item内容，另一个是Item 菜单；在LineaLayout内部定义一个ViewDragHelper来处理拖动事件。ViewDragHelper会将拖动事件处理好，我们只需要在callback中处理简单的逻辑就好。 写一个SwipeLayout 继承自 LineaLayout; 在构造时就创建好 DragHelper 1234public SwipeItemLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mDragHelper = ViewDragHelper.create(this, 1.0f, new SwipeItemDragHelper());&#125; 加载完毕布局之后，拿到两个item,一个内容，一个菜单 123456@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mContentView = getChildAt(0); mActionView = getChildAt(1);&#125; 事件交由 DragHelper处理 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mDragHelper.processTouchEvent(event); return true;&#125; 要在callback中使用动画 12345678910/** * 因为要在 DragHelper的中使用动画 */@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 主要逻辑就在callback中处理 tryCaptureView() 如果拖动的时内容或者菜单就捕获此次多动 1234@Overridepublic boolean tryCaptureView(View child, int pointerId) &#123; return child == mContentView || child == mActionView;&#125; 因为实现的是侧滑菜单，这里只处理 水平拖动就好，注释写的很清楚了 12345678910111213141516171819202122@Overridepublic int clampViewPositionHorizontal(View child, int left, int dx) &#123; dragDx+=dx; if (child == mContentView) &#123; /** * 这个位置 的范围应该是在 0和 -dragDistance之间；最大是0；最小是 -dragDistance */ int leftBound = getPaddingLeft(); int minLeft = -leftBound - mDragDistance; int newLeft = Math.min(Math.max(minLeft, left), 0); return newLeft; &#125; else &#123; /** * 这个view的位置范围应该是在 父布局的宽度-actionView的宽和父布局的宽度之间； */ int leftBound = getPaddingLeft(); int minLeft = getWidth() - leftBound - mActionView.getWidth(); int newLeft = Math.min(Math.max(minLeft, left), getWidth()); return newLeft; &#125;&#125; 当view 被拖动的时候，另一个view跟随被拖动的view一起移动 1234567891011@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; //同时移动 if (changedView == mContentView) &#123; mActionView.offsetLeftAndRight(dx); &#125; else &#123; mContentView.offsetLeftAndRight(dx); &#125; invalidate();&#125; 当滑动结束后，可以根据滑动的速度或者滑动的距离来决定是否要打开或者关闭菜单;具体思路 注释已经很清楚了 12345678910111213141516171819202122232425262728293031323334@Overridepublic void onViewReleased(View releasedChild, float xvel, float yvel) &#123; /** * 这里的速度 是这样计算的 每秒的拖动的像素 值 * 速度判断 * 如果向→滑动 速度肯定是 正数； * 如果向←滑动 速度肯定是 负数 * 如果 拖动距离 是 actionView的 ¼ 就允许打开或关闭 */ //根据速度决定是否打开 boolean settleToOpen = false; float realVel = Math.abs(xvel); int realDragX = Math.abs(dragDx); if (realVel &gt; AUTO_OPEN_SPEED_LIMIT) &#123; //根据速度判断 if (xvel &gt; 0) &#123; //右滑 settleToOpen = false; &#125; else &#123; //左滑 settleToOpen = true; &#125; &#125;else if(realDragX&gt; mDragDistance/4)&#123; //根据拖动距离判断 if (dragDx&gt;0)&#123; //右滑 settleToOpen = false; &#125;else&#123; settleToOpen = true; &#125; &#125; isOpen = settleToOpen; int settleDestX = isOpen ? -mDragDistance : 0; Log.e(&quot;onViewReleased&quot;, &quot;settleToOpen-&gt;&quot; + settleToOpen + &quot;;destX-&gt;&quot; + settleDestX + &quot;;xvel-&gt;&quot; + xvel + &quot;;dragDx--&gt;&quot; + dragDx); mDragHelper.smoothSlideViewTo(mContentView, settleDestX, 0); ViewCompat.postInvalidateOnAnimation(SwipeItemLayout.this); dragDx = 0;&#125;&#125; 为了滑动更加灵敏，在左右滑动item时，禁止父布局的上下滑动 在onTouch中 判断滑动距离，超过一定范围就不让父布局处理；getParent().requestDisallowInterceptTouchEvent(true); 123456789101112131415161718192021@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mDragHelper.processTouchEvent(event); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: x = event.getRawX(); break; case MotionEvent.ACTION_MOVE: float gap = event.getRawX() - x; int sl = ViewConfiguration.get(getContext()).getScaledTouchSlop(); if (Math.abs(gap) &gt; sl) &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: x = 0; break; &#125; return true;&#125; 贴一下代码，完整Demo看GitHub https://github.com/sky-mxc/AndroidDemo/tree/master/drag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * Created by mxc on 2017/7/23. * description: */public class SwipeItemLayout extends LinearLayout &#123; private final double AUTO_OPEN_SPEED_LIMIT = 500.0; private View mActionView; private View mContentView; private int mDragDistance; private ViewDragHelper mDragHelper; private boolean isOpen; public SwipeItemLayout(Context context) &#123; this(context, null); &#125; public SwipeItemLayout(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SwipeItemLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mDragHelper = ViewDragHelper.create(this, 1.0f, new SwipeItemDragHelper()); &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); mContentView = getChildAt(0); mActionView = getChildAt(1); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mDragDistance = mActionView.getMeasuredWidth(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev); &#125; float x = 0; @Override public boolean onTouchEvent(MotionEvent event) &#123; mDragHelper.processTouchEvent(event); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: x = event.getRawX(); break; case MotionEvent.ACTION_MOVE: float gap = event.getRawX() - x; int sl = ViewConfiguration.get(getContext()).getScaledTouchSlop(); if (Math.abs(gap) &gt; sl) &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: x = 0; break; &#125; return true; &#125; /** * 因为要在 DragHelper的中使用动画 */ @Override public void computeScroll() &#123; super.computeScroll(); if (mDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; class SwipeItemDragHelper extends ViewDragHelper.Callback &#123; private int dragDx; @Override public boolean tryCaptureView(View child, int pointerId) &#123; return child == mContentView || child == mActionView; &#125; @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; dragDx+=dx; if (child == mContentView) &#123; /** * 这个位置 的范围应该是在 0和 -dragDistance之间；最大是0；最小是 -dragDistance */ int leftBound = getPaddingLeft(); int minLeft = -leftBound - mDragDistance; int newLeft = Math.min(Math.max(minLeft, left), 0); return newLeft; &#125; else &#123; /** * 这个view的位置范围应该是在 父布局的宽度-actionView的宽和父布局的宽度之间； */ int leftBound = getPaddingLeft(); int minLeft = getWidth() - leftBound - mActionView.getWidth(); int newLeft = Math.min(Math.max(minLeft, left), getWidth()); return newLeft; &#125; &#125; @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; //同时移动 if (changedView == mContentView) &#123; mActionView.offsetLeftAndRight(dx); &#125; else &#123; mContentView.offsetLeftAndRight(dx); &#125; invalidate();// Log.e(&quot;onViewPosition&quot;, &quot;dx--&gt;&quot; + dx); &#125; @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; /** * 这里的速度 是这样计算的 每秒的拖动的像素 值 * 速度判断 * 如果向→滑动 速度肯定是 正数； * 如果向←滑动 速度肯定是 负数 * 如果 拖动距离 是 actionView的 ¼ 就允许打开或关闭 */ //根据速度决定是否打开 boolean settleToOpen = false; float realVel = Math.abs(xvel); int realDragX = Math.abs(dragDx); if (realVel &gt; AUTO_OPEN_SPEED_LIMIT) &#123; //根据速度判断 if (xvel &gt; 0) &#123; //右滑 settleToOpen = false; &#125; else &#123; //左滑 settleToOpen = true; &#125; &#125;else if(realDragX&gt; mDragDistance/4)&#123; //根据拖动距离判断 if (dragDx&gt;0)&#123; //右滑 settleToOpen = false; &#125;else&#123; settleToOpen = true; &#125; &#125; isOpen = settleToOpen; int settleDestX = isOpen ? -mDragDistance : 0; Log.e(&quot;onViewReleased&quot;, &quot;settleToOpen-&gt;&quot; + settleToOpen + &quot;;destX-&gt;&quot; + settleDestX + &quot;;xvel-&gt;&quot; + xvel + &quot;;dragDx--&gt;&quot; + dragDx); mDragHelper.smoothSlideViewTo(mContentView, settleDestX, 0); ViewCompat.postInvalidateOnAnimation(SwipeItemLayout.this); dragDx = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewDragHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 文件下载]]></title>
    <url>%2F2017%2F06%2F03%2Fdownload%2F</url>
    <content type="text"><![CDATA[时间问题，延期 文件下载用到的知识点 多线程，线程池 http协议 RandomAccessFile 类 properties文件 流程分析 确定文件流长度 创建线程池 确定每个线程的下载起点，止点，长度 记录每个线程的进度]]></content>
      <categories>
        <category>Android</category>
        <category>文件下载</category>
      </categories>
      <tags>
        <tag>断点续传</tag>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中关于UUID的操作]]></title>
    <url>%2F2017%2F03%2F12%2Fandroid-uuid%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io UUID 通用唯一识别码（Universally Unique Identifier）是一种软件建构的标准；UUID的目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不是需要通过中央控制端来做辨识信息的指定。如此以阿里，每个人都可以创建与其他人不冲突的UUID。在这种情况下，就不需要考虑数据库创建时的重复问题； UUID是由一组32位数的16进制数字构成，UUID的标准形式包含32个16进制数字，以连字号分为五段。形式为 8-4-4-12的32个字符。 550e8400-e29b-41d4-a716-446655440000 参考链接：https://zh.wikipedia.org/wiki UUID的生成java中提供了 UUID类来生成UUID 1UUID uuid = UUID.randomUUID(); UUID ，byte[]，16进制字符串之间的转换1234567891011121314151617181920212223242526272829303132333435363738394041/** * uuid转化 byte[] * @param uuid * @return */public static byte[] toByte(UUID uuid) &#123; ByteBuffer buffer = ByteBuffer.wrap(new byte[16]); buffer.putLong(uuid.getMostSignificantBits()); buffer.putLong(uuid.getLeastSignificantBits()); return buffer.array();&#125;/** * byte[] 转换 uuid * @param bytes * @return */public static UUID toUUID(byte[] bytes) &#123; ByteBuffer buffer = ByteBuffer.wrap(bytes); long fistLong = buffer.getLong(); long secondLong = buffer.getLong(); return new UUID(fistLong, secondLong);&#125;/** * byte[] 转换为 16进制字符串啊 * @param bytes * @return */public static String bytesToHexStr(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(); for (byte b : bytes) &#123; int v = b &amp; 0xff; String hv = Integer.toHexString(v); if (hv.length() &lt; 2) &#123; sb.append(&quot;0&quot;); &#125; sb.append(hv); &#125; return sb.toString();&#125; 参考链接：http://stackoverflow.com/questions/17893609/convert-uuid-to-byte-that-works-when-using-uuid-nameuuidfrombytesb https://my.oschina.net/u/347386/blog/182717 sqlite中 guid类型数据的操作 表结构 插入1234567891011121314private void insert() &#123; UUID uuid = UUID.randomUUID(); String name = &quot;mxc&quot;; byte[] bytes = UUIDUtils.toByte(uuid); ContentValues cv = new ContentValues(); cv.put(&quot;id&quot;,bytes); cv.put(&quot;name&quot;,name); SQLiteDatabase db = helper.getWritableDatabase(); db.beginTransaction(); db.insert(&quot;tb0&quot;,null,cv); db.setTransactionSuccessful(); db.endTransaction();&#125; 修改12345678910111213141516private void update()&#123; /** * 对于uuid的比较 ，转换为16进制字符串 */ String hexStr = UUIDUtils.bytesToHexStr(bytes); SQLiteDatabase db = helper.getWritableDatabase(); ContentValues cv = new ContentValues(); cv.put(&quot;name&quot;,&quot;sky-mxc&quot;); cv.put(&quot;age&quot;,23); Log.e(TAG, &quot;update: hexStr=&quot;+hexStr); db.beginTransaction(); db.update(&quot;tb0&quot;,cv,&quot;id = x&apos;&quot;+hexStr+&quot;&apos;&quot;,null); db.setTransactionSuccessful(); db.endTransaction(); query();&#125; 查询12345678910111213141516171819202122232425private void query()&#123; StringBuffer sb = new StringBuffer(&quot;数据如下：\n&quot;); SQLiteDatabase db = helper.getReadableDatabase(); Cursor cursor = db.query(&quot;tb0&quot;, new String[]&#123;&quot;id&quot;, &quot;name&quot;, &quot;age&quot;&#125;, null, null, null, null, null); while (cursor.moveToNext())&#123; byte[] ids = cursor.getBlob(cursor.getColumnIndex(&quot;id&quot;)); bytes = ids; UUID uuid = UUIDUtils.toUUID(ids); String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); int age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;)); sb.append(&quot;uuid=&quot;+uuid.toString()); sb.append(&quot;;\n&quot;); String hexStr = UUIDUtils.bytesToHexStr(ids); sb.append(&quot;hexStr=&quot;+hexStr); sb.append(&quot;;\n&quot;); Log.e(TAG, &quot;query: hexStr=&quot;+hexStr); sb.append(&quot;name=&quot;+name); sb.append(&quot;;\n&quot;); sb.append(&quot;age=&quot;+age); sb.append(&quot;;\n&quot;); sb.append(&quot;---------------------------\n&quot;); &#125; cursor.close(); tvShow.setText(sb.toString());&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UUID</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android操作位于sd卡上的sqlite数据库]]></title>
    <url>%2F2017%2F03%2F06%2FopeateSDCardDb%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明出处：https://sky-mxc.github.io 对 sd卡上sqlite 数据库的操作 Android默认的数据库位置是在 data\data\packageName\databases\目录下的；有时候因为业务需要我们需要操作位于sd卡的数据库，就可以通过重写 Context类的方法来实现 重写 ContextWrapper我们在创建SqliteOpenHelper实例的时候需要传入一个Context 实例，就是通过他来实现的 1234567891011121314151617181920212223242526272829303132333435public class DBContext extends ContextWrapper &#123; public static final String TAG = &quot;DBContext&quot;; public DBContext(Context base) &#123; super(base); &#125; /** * 返回 数据库文件 * 重写此方法 返回我们位于sd卡的数据库文件 * @param name * @return */ @Override public File getDatabasePath(String name) &#123; //位于 sd卡的数据库 初始化时已经创建好了 File file = new File(Environment.getExternalStorageDirectory().getPath()+&quot;/dbDemo&quot;,name); return file; &#125; /** * Android 4.0后会调用此方法 还有一个2.3以前的方法就重写了，也没有那么底的版本了 * @param name * @param mode * @param factory * @param errorHandler * @return */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler) &#123; SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name),factory); return db; &#125;&#125; DBHelper DBHelper 12345678910111213141516171819202122232425262728293031public class DBHelper extends SQLiteOpenHelper &#123; public static final String TAG = &quot;DBHelper&quot;; private static final String NAME = &quot;test.db&quot;; private static final int VERSION = 1; private static DBHelper dbHelpter; public static DBHelper getDbHelpter(Context context)&#123; if (dbHelpter == null)&#123; dbHelpter = new DBHelper(context); &#125; return dbHelpter; &#125; private DBHelper(Context context) &#123; super(context, NAME, null, VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 使用12345678910111213141516private void query()&#123; DBContext dbContext = new DBContext(this); DBHelper helpter = DBHelper.getDbHelpter(dbContext); SQLiteDatabase db = helpter.getWritableDatabase(); Cursor cu = db.query(&quot;table1&quot;, new String[]&#123;&quot;id&quot;, &quot;name&quot;, &quot;age&quot;&#125;, null, null, null, null, &quot;id desc&quot;, null); if (null != cu)&#123; while (cu.moveToNext())&#123; int id = cu.getInt(cu.getColumnIndex(&quot;id&quot;)); String name = cu.getString(cu.getColumnIndex(&quot;name&quot;)); int age = cu.getInt(cu.getColumnIndex(&quot;age&quot;)); Log.e(TAG, &quot;query: id=&quot;+id+&quot;;name=&quot;+name+&quot;;age=&quot;+age); &#125; cu.close(); &#125;&#125; 参考博客http://blog.csdn.net/liyulei316686082/article/details/7230709]]></content>
      <categories>
        <category>Android</category>
        <category>Sqlite</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 导入现有数据库]]></title>
    <url>%2F2017%2F02%2F26%2FcopyDB%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io 我们都知道 Android的 数据库默认是放在data\data\packageName\datbases\下的;要导入现有的数据库将我们的数据库在 程序第一次启动的时候将数据库放在这个目录下，然后我们配置好SqliteDabase对象就可以 直接操作了。 12345678910111213141516171819202122232425262728293031323334/** * 将 数据库从 assets 复制到 databases下 */private void copyDB() &#123; //data/data/packageName/databases/ File mkdir = new File(getFilesDir().getParent(),"databases"); //创建 databases文件夹 if (!mkdir.exists()) mkdir.mkdirs(); Log.e(TAG, "copyDb: mkdir="+mkdir.getPath()); //数据库文件 File file = new File(mkdir,"SinBusinessWssm1.db"); //只是在程序第一次启动时创建 if(!file.exists())&#123; //获取 assets管理 AssetManager assets = getAssets(); //执行文件复制 try &#123; InputStream open = assets.open("SinBusinessWssm1.db"); FileOutputStream fos = new FileOutputStream(file); byte[] bs = new byte[1024]; int len ; while ((len = open.read(bs))!=-1)&#123; fos.write(bs,0,len); &#125; fos.flush(); fos.close(); open.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; Log.e(TAG, "copyDb: exists="+file.getPath());&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Sqlite</category>
      </categories>
      <tags>
        <tag>Android导入现有数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql命令集锦]]></title>
    <url>%2F2017%2F01%2F08%2Fmysqlcommand%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io MySQL命令创建数据库 如果存在就先删了吧 1drop database if exists db_ name; 创建数据库 1create database db_name; 查看所有用户 所有的用户都存储于系统的user表里 1select user from mysql.user; 创建用户创建用户其实就是向 ‘mysql.user’ 表里插入一条记录 123#create user &apos;用户名‘@&apos;用户登录ip % 表示无限制也可以是localhost&apos; identified by &apos;密码’create user &apos;mxc&apos;@&apos;localhost&apos; identified by &apos;mxc&apos;; 查询用户权限123#show grants for 用户名@&apos;IP地址&apos;;show grants for mxc@&apos;localhost&apos;; 为用户授权 在创建一个用户的时候默认的权限只有登录权限，想要其他的权限必须授权； 123#mxc用户拥有test数据库的所有权限grant all on test.* to mxc@localhost identified by &apos;mxc&apos;; 权限列表数据库/数据表/数据列权限： Alter: 修改已存在的数据表(例如增加/删除列)和索引。 Create: 建立新的数据库或数据表。 Delete: 删除表的记录。 Drop: 删除数据表或数据库。 INDEX: 建立或删除索引。 Insert: 增加表的记录。 Select: 显示/搜索表的记录。 Update: 修改表中已存在的记录。 全局管理MySQL用户权限： file: 在MySQL服务器上读写文件。 PROCESS: 显示或杀死属于其它用户的服务线程。 RELOAD: 重载访问控制表，刷新日志等。 SHUTDOWN: 关闭MySQL服务。 特别的权限： ALL: 允许做任何事(和root一样)。 USAGE: 只允许登录–其它什么也不允许做 创建数据表 创建之前先删 1drop table if exists table_name; 1234567create table employee( id int auto_increment primary key, name varchar(50) not null, age int default 18, sex int default 0, dept int not null) default charset =utf8; 查看表结构 1desc table_name; 默认值设置 int类型：默认值也得是整型，并且default后边不要()括号。 char类型：默认值使用单引号。 DATETIME类型：NOW()函数以’YYYY-MM-DD HH:MM:SS’返回当前的日期时间，可以直接存到DATETIME字段中。不支持使用系统默认值。 DATE类型：CURDATE()以’YYYY-MM-DD’的格式返回今天的日期，可以直接存到DATE字段中。不支持使用系统默认值。 TIME类型：CURTIME()以’HH:MM:SS’的格式返回当前的时间，可以直接存到TIME字段中。不支持使用系统默认值。 插入数据1insert into table_name values(对应的列的值）； 为已存在的表添加外键1234alter table 表名 add constraint 外键名字 foreign key(外键字段名） references 外表(对应表的字段);# 为 employee 添加外键 employee表的dept字段对应dept表里的 d_id字段alter table employee add constraint FK_ED foreign key(dept) references dept(d_id); 查看创建表的SQL语句1show create table 表名; 添加列123alter table 表名 add 列名 数据类型;# 为 dept表增加 d_location列alter table dept add d_location varchar(200); description 平时用到的SQL语句记录，持续更新中….]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySql命令集锦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql5.7.17解压版安装教程]]></title>
    <url>%2F2017%2F01%2F05%2FinstallMysql5-7%2F</url>
    <content type="text"><![CDATA[sky-mxc总结 转载注明: https://sky-mxc.github.io Mysql5.7.17 解压版安装下载解压版下载地址(需要登录) http://dev.mysql.com/downloads/mysql/ 下载后解压到你想要安装的目录就可以了 配置环境变量为了方便使用，不必每次都进入bin目录 就添加环境变量，如果不嫌麻烦就不必添加了 增加系统环境变量： MYSQL_HOME ，值就是你的MySQL目录了 例如：D:\tools\database\mysql-5.7.17-winx64 在path变量后追加 %MYSQL_HOME%\bin; 注意前面加分号； 初始化数据库得到data目录两种命令方式 一种是初始化一个无密码的 root ，一个是初始化一个随机密码的root无密码的方式 1mysqld --initialize-insecure 随机密码的方式，不过要记住随即密码 1mysqld --initialize 配置 my.imi文件 主要是配置 basedir,datadir,port,在5.7之后 有些配置是不识别的例如：default-character-set=utf8 #安装目录 basedir = D:\\tools\\database\\mysql-5.7.17-winx64 # 数据库存放目录 datadir = D:\\tools\\database\\mysql-5.7.17-winx64\\data #端口 port = 3306 ps:这里需要注意的地方是 目录的间隔标识 使用 \\ 在win7上可能会出现 无法识别的情况 添加服务在bin目录下 输入命令 mysqld -install 启动服务输入命令 net start mysql 登录数据库并修改密码进入数据库,因为没有密码 ，回车即可进入 mysql -u root -p 修改root 密码 set password = password(&apos;新密码&apos;); 退出并测试密码 遇到的坑 在安装的时候 遇到了一个坑，在win7上是坑，而我在win10测试的时候这个坑就不会出现；这个疑惑实在不解； MySQL 服务正在启动 . MySQL 服务无法启动。 服务没有报告任何错误。 请键入 NET HELPMSG 3534 以获得更多的帮助。 这里遇到这个情况是因为在my.imi配置中 目录间隔符没有使用 \\ 在更改后重新初始化; 因为在之前已经初始化过一次了，在这次初始化之前要把data目录清空，否则会执行不成功 清空data目录后，重新初始化即可 over]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql5.7.17安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2017%2F01%2F04%2FdesignModel-observer%2F</url>
    <content type="text"><![CDATA[sky-mxc总结 转载请注明：https://sky-mxc.github.io/2016/12/25/designModel-observer 观察者模式 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象在状态上发生改变时，通知所有的观察者对象，并让他们自动更新自己； 观察者模式的组成抽象主题角色： 将所有的观察者引用存放到一个集合中，每个主题可以拥有任意数量的观察者；主题提供一个接口，用来增加，移除通知观察者。一般用一个抽象类或接口来实现； 抽象观察者角色：为所有的观察者定义一个接口，在得到主题通知时更新自己； 具体主题角色：在具体主题状态发生改变时，通知所有登记过的观察者。具体主题通常由一个子类实现； 具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，在得到主题通知时更新自己，让本身的状态和观察者的状态相协调。通常是一个自类实现。如果需啊，可以在内部保存观察的主题的引用。 程序实现抽象观察者角色123456789101112/** * 抽象观察者接口 * Created by sky-mxc on 2016/12/25. */public interface IObserver &#123; /** * 主题发生变化 * @param str */ void update(String str);&#125; 抽象主题角色1234567891011121314151617181920212223242526272829303132333435363738 /** * 抽象主题 * Created by sky-mxc on 2016/12/25. */public abstract class ISubject &#123; //观察者 集合 protected List&lt;IObserver&gt; observers = new ArrayList&lt;&gt;(); //主题名字 protected String name; public ISubject(String name) &#123; this.name = name; &#125; /** * 增加 观察者 * @param observer 观察者 */ public void addObserver(IObserver observer)&#123; observers.add(observer); &#125; /** * 移除观察者 * @param observer 观察者 */ public void removeObserver(IObserver observer)&#123; observers.remove(observer); &#125; /** * 通知观察者 * @param str 通知内容 */ protected abstract void notifyUpdate(String str);&#125; 具体主题角色1234567891011121314151617/** * 具体主题 * Created by sky-mxc on 2016/12/25. */public class Subject extends ISubject &#123; public Subject(String name) &#123; super(name); &#125; @Override public void notifyUpdate(String str) &#123; for (IObserver observer :observers)&#123; observer.update(str+"\t\t\t--- "+name); &#125; &#125;&#125; 具体观察者角色12345678910111213141516/** * 具体观察者 * Created by sky-mxc on 2016/12/25. */public class Observer implements IObserver &#123; private String name; public Observer(String name) &#123; this.name = name; &#125; @Override public void update(String str) &#123; System.out.println(name+"接收到了通知："+str); &#125;&#125; 运行12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Observer observer1 =new Observer("张三"); Observer observer2 =new Observer("李四"); Observer observer3 =new Observer("王五"); Subject subject = new Subject("PM"); subject.addObserver(observer1); subject.addObserver(observer2); subject.addObserver(observer3); for (int i=0;i&lt;5;i++)&#123; subject.notifyUpdate("通知："+System.currentTimeMillis()); try &#123; Thread.sleep(1000*3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("\n"); &#125; &#125;&#125; result：]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用百度定位当前位置并获取附近的位置]]></title>
    <url>%2F2016%2F12%2F19%2FbaiduLocation%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 ；欢迎转载交流 https://sky-mxc.github.io 1. 下载sdk 2. 生成 SHA1码（debug,和release版本） 3. 申请key 4. 集成sdk 5. 获取位置（包含附近poi） 下载定位sdk链接 http://lbsyun.baidu.com/index.php?title=android-locsdk/geosdk-android-download 生成 SHA1 码 在填写 SHA1码的时候能填写两个，发布版和开发版，如果是的一个人开发的话两个都填一个电脑生成的就好了，如果是多人的话，最好是两个码从两个电脑生成；因为如果码不对的话，定位是无法使用的； debug 版 定位到 .android 目录下： 打开cmd 输入命令 keytool -list -v -keystore debug.keystore 输入口令 ：android （百度地图官网提供） 就得到了SHA1 码： 发布版在获取发布版的SHA1前 要对项目进行签名 输入命令 keytool -list -v -keystore jrjh.jks （ps:jrjh.jks 是你签名是的keystore） 口令输入你的密码 得到 发布版的SHA1 申请key 集成sdk详细文档地址：http://lbsyun.baidu.com/index.php?title=android-locsdk/guide/buildprojec 获取位置定义位置帮助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import android.content.Intent;import android.util.Log;import com.baidu.location.BDLocation;import com.baidu.location.BDLocationListener;import com.baidu.location.LocationClient;import com.baidu.location.LocationClientOption; /** * Location utils. * 位置 帮助类 * @author 孟祥超 on 2016.12.15 */public class LocationHelper &#123; public static final String TAG = "LocationHelper"; public LocationClient client= new LocationClient(AppUtils.getAppContext()); //位置监听 private BDLocationListener locationListener = new BDLocationListener() &#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; // 2016/12/15 发送一个广播啊 Log.i(TAG, "onReceiveLocation: address="+bdLocation.getAddrStr()); Intent intent =new Intent(Constants.Intent.LOCATION_CHANGE); intent.putExtra("location",bdLocation); AppUtils.getAppContext().sendBroadcast(intent); &#125; &#125;; public static LocationHelper locationHelper; /** * 获取位置帮助类 * @return location helper * @author 孟祥超 on 2016.12.15 14:16:01 */ public synchronized static LocationHelper getInstance()&#123; if (locationHelper == null)&#123; locationHelper = new LocationHelper(); &#125; return locationHelper; &#125; private LocationHelper()&#123; initLocation(); &#125; //初始化 定位 private void initLocation()&#123; LocationClientOption option = new LocationClientOption(); option.setIsNeedLocationPoiList(true); //获取附近 poi option.setIsNeedAddress(true); //需要详细位置 option.setCoorType("bd09ll"); //百度的编码 option.setScanSpan(1000*3); //3秒 一次 option.setIsNeedLocationDescribe(true); //位置语义化 client.setLocOption(option); //设置参数 client.registerLocationListener(locationListener); //注册获取位置监听 &#125; /** * 释放 位置对象 * @author 孟祥超 on 2016.12.15 14:23:04 */ public void release()&#123; if (locationHelper == null) return; client.unRegisterLocationListener(locationListener); locationHelper = null; &#125; &#125; 接受广播并更新UI123456789101112131415161718192021222324 //获取到 位置信息 private BroadcastReceiver locationChangeReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; BDLocation location =intent.getParcelableExtra("location"); if (location == null || TextUtils.isEmpty(location.getAddrStr()))&#123; letterCreateAddress.setText("没有定位的外星球....."); return; &#125; Log.i(TAG, "onReceive: address ="+location.getAddrStr()); letterCreateAddress.setText(location.getAddrStr()); List&lt;Poi&gt; pois = location.getPoiList(); if (pois != null &amp;&amp; pois.size() != 0)&#123; nearbyAddress = new ArrayList&lt;&gt;(); &#125;else&#123; return; &#125; for (Poi poi :pois)&#123; Log.i(TAG, "onReceive: poi ="+poi.getName()); nearbyAddress.add(poi.getName()); &#125; &#125; &#125;; 在项目中已经测试可用；这里做个总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>百度定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github+hexo 搭建个人博客]]></title>
    <url>%2F2016%2F12%2F04%2FbuildBlogs%2F</url>
    <content type="text"><![CDATA[sky-mxc总结 转载注明：https://sky-mxc.github.io/2016/09/29/buildBlogs githubPages + hexo 搭建个人博客 hexo是基于git和Node.js的 必须先安装 git和Node.js; node.js安装 Node.js 下载地址 http://nodejs.cn/download/ 选择好安装路径之后一路 next就可以了;检测是否安装成功：1node -v 查看 npm是否安装 以前的版本没有集成npm，新版本已经集成了npn1npm -version hexo 安装 关于hexo 的安装 在官网有很详细的教程 ：https://hexo.io/zh-cn/docs/ 安装 hexo1npm install -g hexo-cli 检测安装是否成功1hexo -v 指定一个文件夹 必须是空目录 配置hexo1hexo init 安装完成后会生成一些文件 具体目录的用途 官网说的很清楚 _config.yml 网站的配置信息。大部分的参数在这里配置 package.json 应用程序的信息 scaffolds 模板 文件夹 source 资源文件夹 存放 资源 如图片之类的；除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes 主题文件夹 Hexo很久主题生成静态页面 剩下的就是配置了 主要是在 _config.yml中配置 怎么配置 官网也解释的跟清楚了。这里说一下主要的，详情移步官网查看:https://hexo.io/zh-cn/docs/configuration.html title 网站标题 subtitle 子标题 description 网站描述 language 使用语言 author 你的名字 到这里基本上本地已经配置完了 现在可以 测试一下了 12$ hexo g # 生成静态文件 生成文件在public 目录下$ hexo s # 启动本地预览 hexo s --debug 命令可以用来调试 发布到github 首先在github上建一个repository 名字格式：[your_user_name.github.io] 例如我的 sky-mxc.github.io 要发布到 github 还得下载 一个组件( hexo-deployer-git) 执行命令1npm install hexo-deployer-git --save 还需要修改 _config.yml ;参考官网得说明 我的配置如下： 配置完之后 就可以发布到 github上了1hexo d #发布 发布完成之后 就可输入网址查看了 这里贴一下我的吧：https://sky-mxc.github.io 这里就基本搭建完成了 常用 命令12345hexo clean # 清理之前的内容hexo g # 生成静态文件hexo d #部署hexo s # 启动本地服务 ，可以通过 http://localhost:4000查看hexo s --debug # 使用debug模式启动服务 更换主题 感觉默认主题有点low 关于主题的选择 这里贴个连接 https://hexo.io/themes/ 我要更换的主题：http://theme-next.iissnan.com/getting-started.html 在要theme 目录下 clone1git clone https://github.com/iissnan/hexo-theme-next themes/next clone完成后 修改 _config.yml 将theme 的值修改为 next 具体看官网配置：http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>搭建个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机和相册选取图片并剪裁]]></title>
    <url>%2F2016%2F11%2F03%2FSelectPhoto%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明https://sky-mxc.github.io 图片的选择 这两天做头像模块的时候，使用到了相册，相机，剪裁，自定义圆形图片；这里做个总结吧 这里关于权限的处理 之前已经做过总结了，就不再写了 https://sky-mxc.github.io/2016/10/08/permission 相册选取 相机选取 剪裁 自定义圆形图片 相册选取 图库选取之后获得的是这个图片的路径，我的实现方法是通过ContentResovler来获取路径，存储在文件夹里，然后启动剪裁程序去剪裁 12345678910/** * 执行图库选取图片 */private void invokePhoto() &#123; Log.i(TAG, "invokePhoto: "); Intent intent = new Intent(Intent.ACTION_PICK); intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,"image/*"); startActivityForResult(intent,PHOTO);&#125; 获取图片路径 存储并启动剪裁 ，存储文件的代码就不贴了，都是那一套12345678String projection = MediaStore.Images.Media.DATA;Cursor cursor = getContentResolver().query(data.getData(), new String[]&#123;projection&#125;, null, null, null);if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; String path = cursor.getString(cursor.getColumnIndex(projection)); Log.i(TAG, "onActivityResult: photoPath=" + path); startPhotoZoom(Uri.fromFile(FileUtil.saveHeadImg(path)));&#125;cursor.close(); 相机选取 在启动相机的时候 传入一个文件uri（和刚才相册临时存储的文件路径一致，方便使用），在拍照完毕，直接去读取该图片 并执行剪裁 1234567891011121314/** * 执行拍照 */private void invokeCamera() &#123; String state = Environment.getExternalStorageState(); if(state.equals(Environment.MEDIA_MOUNTED)) &#123; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(FileUtil.getHeadImage())); startActivityForResult(intent, CAMERA); &#125;else&#123; Toast.makeText(this, "检测不到SD卡，无法使用", Toast.LENGTH_SHORT).show(); &#125;&#125; 剪裁12345678910111213141516171819/** * 打开系统图片裁剪功能 * @param uri */private void startPhotoZoom(Uri uri) &#123; Intent intent = new Intent("com.android.camera.action.CROP"); intent.setDataAndType(uri,"image/*"); intent.putExtra("crop",true); intent.putExtra("aspectX",1); intent.putExtra("aspectY",1); intent.putExtra("outputX",200); intent.putExtra("outputY",200); intent.putExtra("scale",true); //黑边 intent.putExtra("scaleUpIfNeeded",true); //黑边 intent.putExtra("return-data",true); intent.putExtra("noFaceDetection",true); startActivityForResult(intent,ZOOM);&#125; 剪裁后获取 1234if (data != null) &#123; Bitmap bmp = data.getParcelableExtra("data"); headImg.setImageBitmap(bmp);&#125; 自定义圆形图片对于这个实现方式想到了两种，看连接https://sky-mxc.github.io/2016/11/03/customCircleImageView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>相机拍照</tag>
        <tag>相册选取图片</tag>
        <tag>图片剪裁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义圆形图片控件]]></title>
    <url>%2F2016%2F11%2F03%2FcustomCircleImageView%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明https://sky-mxc.github.io 自定义圆形ImageView圆形ImageView在头像显示用的比较普遍了，今天对于实现圆形ImageView做个总结； 主要思路是 重写 onDraw() ;方法有两个： 使用paint的Shader(着色器)将图片印在一个圆的画板上 使用Bitmap创建一个空的Canvas(画板)，在画板上画一个圆和显示的图片，paint图像混合模式显示 着色器 方式不带边框 思路 将图片压缩到和控件的大小一致 创建Bitmap 着色器 创建画笔并设置着色器 使用带有着色器的画笔在画板上画圆 123456789101112131415private void drawShader(Canvas canvas) &#123; Drawable mDrawable = getDrawable(); if (mDrawable == null) return; if (mDrawable instanceof BitmapDrawable)&#123; Bitmap bmp = ((BitmapDrawable)mDrawable).getBitmap(); if (bmp == null) return; //图片缩放，参数2 目标宽度，参数3目标高度，参数4 是否过滤 bmp = Bitmap.createScaledBitmap(bmp,getWidth(),getHeight(),true); //着色器 Shader shader = new BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); paint = new Paint(); paint.setShader(shader); canvas.drawCircle(getWidth()/2,getWidth()/2,getWidth()/2,paint); &#125;&#125; 效果 加边框有时候我们需要为头像加上一个圆的边框显得更好看一点，其实这个也很好实现，在绘制图片之前先绘制一个带有颜色的圆，根据边框的大小，将图片缩小一点，这样就将边框显示出来了。 画边框1234paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(outColor);paint.setStyle(Paint.Style.FILL);canvas.drawCircle(getWidth()/2,getHeight()/2,getWidth()/2,paint); 绘制图片 将边框大小空出来 (getWidth()-outWidth*2)/2123456789101112131415private void drawShader(Canvas canvas) &#123; Drawable mDrawable = getDrawable(); if (mDrawable == null) return; if (mDrawable instanceof BitmapDrawable)&#123; Bitmap bmp = ((BitmapDrawable)mDrawable).getBitmap(); if (bmp == null) return; //图片缩放，参数2 目标宽度，参数3目标高度，参数4 是否过滤 bmp = Bitmap.createScaledBitmap(bmp,getWidth(),getHeight(),true); //着色器 Shader shader = new BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); paint = new Paint(); paint.setShader(shader); canvas.drawCircle(getWidth()/2,getWidth()/2,(getWidth()-outWidth*2)/2,paint); &#125;&#125; 效果 着色器方式全部代码自定义属性 边框颜色和宽度1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="CircleImageView"&gt; &lt;attr name="out_width" format="dimension"&gt;&lt;/attr&gt; &lt;attr name="out_color" format="color"&gt;&lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 重写 onDraw() 绘制图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.skymxc.lesson_36_view_override;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import android.graphics.Shader;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.util.Log;import android.widget.ImageView;/** * Created by sky-mxc */public class CircleImageView extends ImageView &#123; private static final String TAG = "CircleImageView"; private int outWidth = 2; private int outColor = Color.RED; private Paint paint; public CircleImageView(Context context) &#123; this(context,null,0); &#125; public CircleImageView(Context context, AttributeSet attrs) &#123; this(context, attrs,0); &#125; public CircleImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initAttrs(attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; paint = new Paint(Paint.ANTI_ALIAS_FLAG);// canvas.drawColor(Color.YELLOW); paint.setColor(outColor); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(getWidth()/2,getHeight()/2,getWidth()/2,paint); drawShader(canvas); &#125; private void drawShader(Canvas canvas) &#123; Drawable mDrawable = getDrawable(); if (mDrawable == null) return; if (mDrawable instanceof BitmapDrawable)&#123; Bitmap bmp = ((BitmapDrawable)mDrawable).getBitmap(); if (bmp == null) return; //图片缩放，参数2 目标宽度，参数3目标高度，参数4 是否过滤 bmp = Bitmap.createScaledBitmap(bmp,getWidth(),getHeight(),true); //着色器 Shader shader = new BitmapShader(bmp, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); paint = new Paint(); paint.setShader(shader); canvas.drawCircle(getWidth()/2,getWidth()/2,(getWidth()-outWidth*2)/2,paint); &#125; &#125; public void initAttrs(AttributeSet attrs)&#123; TypedArray array = getContext().obtainStyledAttributes(attrs,R.styleable.CircleImageView); int len = array.length(); for(int i=0;i&lt;len;i++)&#123; int attr = array.getIndex(i); switch (attr)&#123; case R.styleable.CircleImageView_out_color: this.outColor = array.getColor(attr,Color.GREEN); break; case R.styleable.CircleImageView_out_width: this.outWidth = (int) array.getDimension(attr,2); Log.i(TAG, "initAttrs: outWidth="+this.outWidth); break; &#125; &#125; array.recycle(); &#125;&#125; 使用图片混合模式显示 创建 Bitmap 使用图片混合模式 将图片和圆形交叉显示 123456789101112131415161718192021222324252627282930313233 private Bitmap getCircleBitmap()&#123; Drawable mDrawable = getDrawable(); if (mDrawable == null) return null; if (mDrawable instanceof BitmapDrawable)&#123; Bitmap bmp = ((BitmapDrawable)mDrawable).getBitmap(); if (bmp == null) return null; paint = new Paint(); paint.setAntiAlias(true); //创建空的位图 Bitmap output = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888); //创建画板，以位图进行创建 Canvas canvas= new Canvas(output); //Bitmap就成了 透明的图片 canvas.drawColor(Color.TRANSPARENT); //画一个圆形 和图像大小一致 paint.setColor(Color.WHITE); canvas.drawCircle(output.getWidth()/2,output.getHeight()/2,output.getWidth()/2,paint);// //paint 相交模式 必须在 两者中间定义 显示交叉的地方 ;前面是 dst;后面是 src paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));//// //绘制 Bitmap Rect src = new Rect(0,0,bmp.getWidth(),bmp.getHeight()); RectF dst = new RectF(0,0,output.getWidth(),output.getHeight()); canvas.drawBitmap(bmp,src,dst,paint); return output; &#125; return null; &#125; 123456@Overrideprotected void onDraw(Canvas canvas) &#123; Bitmap bmp= getCircleBitmap(); canvas.drawBitmap(bmp,0,0,paint);&#125; 对于这种方式的实现主要在于 paint 的交叉模式； PorterDuffXfermode 实现的方式有很多种 目前是两种. 未完待续。。。。。]]></content>
      <categories>
        <category>Android</category>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义圆形图片控件</tag>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView最基本的使用]]></title>
    <url>%2F2016%2F10%2F24%2FWebView%2F</url>
    <content type="text"><![CDATA[WebView sky-mxc 总结 转载注明:https://sky-mxc.github.io Android内置webkit内核的高性能浏览器,而WebView则是在这个基础上进行封装后的一个 控件,WebView直译网页视图,我们可以简单的看作一个可以嵌套到界面上的一个浏览器控件！在 版本之后内核换成了 chrome 内核，但是 对外的API并没有更换 相关的类和方法WebChromeClient 主要处理 对话框，网站title，icon 加载进度 等;侧重于对 内容的处理 方法 作用 onJsAlert(WebView view,String url,String message,JsResult result) 对js中alert对话框的处理 onJsConfirm(WebView view,String url,String message,JsResult result) 对js中confirm对话框的处理 onJsPrompt(WebView view,String url,String message,String defaultValue,JsPromptResult result) 对js中 Prompt对话框的处理 onProgressChanged(WebView view,int newProgress) 当加载进度发生变化时调用 onReceivedIcon(WebView view, Bitmap icon) 获得网页的icon onReceivedTitle(WebView view,String title) 获取网页的标题 注意点： 在对话框处理完之后要对网页做出回应确认处理完成(result.confirm();)不让网页就会卡在 对话框那个地方 ，无法再次进行相应 12345678910111213141516171819202122private WebChromeClient chromeClient = new WebChromeClient()&#123; //网页加载进度显示 @Override public void onProgressChanged(WebView view, int newProgress) &#123; Log.i(TAG, "onProgressChanged: progress="+newProgress); if (newProgress!=100)&#123; pb.setVisibility(View.VISIBLE); pb.setProgress(newProgress); &#125;else&#123; pb.setVisibility(View.GONE); &#125; &#125; @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); //确认交互完成 提交结果 勿忘 result.confirm(); return true; &#125; &#125;; WebViewClient 主要处理WebView的各种请求通知； 侧重于对浏览器本身事件重写 方法 作用 onPageStared(WebView view,String url) 通知主程序网页开始加载 onPageFinished(WebView view,String url,Bitmap favicon) 通知主程序网页加载完毕 doUpdateVisitedHistory(WebView view,String url,boolean isReload) 更新历史记录 onLoadResource(WebView view,String url) 通知主程序即将加载指定url的资源 onScaleChanged(WebView view,float oldScale,float newScale) WebView的缩放改变时调用 shouldOverrideKeyEvent(WebView view,KeyEvent event) 控制WebView是否处理按键事件，如果返回true则处理，返回false则不处理 shouldOverrideUrlLoading(WebView view,String url) 控制对新加载的url的处理;例如在本view打开，返回true说明 处理 ，返回false说明不处理; onReceivedError(WebView view,int errorCode,String description,String failingUrl) 遇到不可恢复的错误信息时调用 注意点：shouldOverrideUrlLoading(WebView view,String url) 在 API 21中过时； 替代方法为shouldOverrideUrlLoading(WebView view, WebResourceRequest request) 1234567891011//主要处理WebView的各种请求通知 侧重于 对 浏览器本身事件重写private WebViewClient viewClient = new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; Log.i(TAG, "shouldOverrideUrlLoading: url="+url); //当打开一个新的 url 时在本view打开，不跳转至浏览器 view.loadUrl(url); return true; &#125;&#125;; WebSettings WebView相关配置的设置，比如setJavaScriptEnabled()设置是否允许JS脚本执行 部分方法如下： 方法 作用 setUseWideViewPort(boolean enabled) 是否支持viewPort setLoadWithOverviewMode(boolean enabled) 自适应屏幕 setSupportZoom(boolean enabled) 是否支持缩放 setBuiltInZoomControls(boolean enabled) 目前没测试 setDisplayZoomControls(boolean enabled) 是否支持缩放控件 setDefaultFontSize(int size) 设置默认字体大小 setDefaultTextEncodingName(String encoding) 默认字符编码可用来解决中文乱码问题 setJavaScriptEnabled(boolean enabled) 是否支持js交互 1234567//支持js交互webView.getSettings().setJavaScriptEnabled(true);//设置默认编码方式webView.getSettings().setDefaultTextEncodingName("utf-8"); webView.getSettings().setDefaultFontSize(20); WebView 自身的常用方法 方法 作用 loadUrl(String url) 加载指定的url loadData(String data,String mimeType,String encoding) 加载指定的Data到WebView中.使用”data:”作为标记头,该方法不能加载网络数据.其中mimeType为数据类型如:textml,image/jpeg. encoding为字符的编码方式 loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl) loadData的升级版 可以以baseUrl为标准路径加载相应的文件等 getSettings() 返回一个WebSettings对象,用来控制WebView的属性设置 setWebViewClient(WebViewClient client) 为WebView指定一个WebViewClient对象 setWebChromeClient(WebChromeClient client) 为WebView制定一个 WebChromeClient对象 setBackgroundColor(int color) 设置WebView的背景颜色 setOnScrollChangeListener(View.OnScrollChangeListener changeListener) 滚动条滚动监听，在API 23 加入 注意点： WebView 背景色 需要代码进行设置 ；xml属性不好使； 加载指定的Url loadUrl();12 //urlwebView.loadUrl("http://baidu.com"); 加载网页代码 loadData();如果出现中文乱码问题 需要修改 mimeType 为text/html;charset=utf-812//加载网页代码webView.loadData("&lt;h1&gt;title&lt;/h1&gt;","text/html","utf-8"); 基于一个url加载代码 loadDataWithBaseURL()不需要考虑中文乱码问题1234567//加载 以url为基准的数据 比loadData 更加强大//parameter1 ：代码内容中相对地址的基准路径//parameter2 ：网页代码//parameter3 ：数据的内容类型//parameter4 : 编码//parameter5 ：上一个页面地址webView.loadDataWithBaseURL("http://www.baidu.com","&lt;html&gt;&lt;h1&gt;title&lt;/h1&gt;this is content&lt;/html&gt;","text/html","utf-8",null); 实例加载 assets 目录下网页 目录结构 html 代码 123456789101112131415161718192021222324252627282930 &lt;html&gt; &lt;head&gt; &lt;link type="text/css" rel="stylesheet" href="css/index.css"/&gt; &lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table class="table"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;节操&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td onclick="del(this)"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;贞操&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td onclick="del(this)"&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; css 123 table&#123; border:double 2px #ccc ;&#125; js 1234 function del(delBt)&#123; var result = confirm("确定删除吗？"); alert("===="+result);&#125; 加载html文件 12345678910111213141516171819202122232425262728293031323334/** * 加载 assets目录下文件 * @return */public String getIndex() &#123; InputStream is =null; BufferedReader reader = null; try &#123; is = getAssets().open("index.html"); reader = new BufferedReader(new InputStreamReader(is)); StringBuffer sb = new StringBuffer(); while (reader.ready())&#123; sb.append(reader.readLine().trim()); &#125; Log.i(TAG, "getIndex: html="+sb.toString()); return sb.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (is!=null)&#123; is.close(); &#125; if (reader!=null)&#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return "";&#125; loadDataWithBaseURL加载html网页 因为使用外部样式 需要使用 loadDataWithBaseUrl() 因为这个可以使用相对基准路径 可以将assets目录作为 基准目录；html 根据基准目录加载响应的css 12 String data = getIndex();webView.loadDataWithBaseURL("file:///android_asset/",data,"text/html","utf-8",null); 注意点： 路径的格式 ：file:///android_asset/ 开启 js交互 1234 //支持js交互webView.getSettings().setJavaScriptEnabled(true);//背景色webView.setBackgroundColor(Color.GRAY); 效果 可以看到 css文件 加载到了 边框已经显示出来了 ; 原始的 网页confirm 确认框 ; 处理原始网页confirm 改为 AlertDialog对话框 //处理JavaScript confirm 对话框 @Override public boolean onJsConfirm(WebView view, String url, String message, final JsResult result) { new AlertDialog.Builder(MainActivity.this) .setTitle(&quot;确认提示&quot;) .setMessage(message) .setNegativeButton(&quot;Ok&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { result.confirm(); } }) .setNeutralButton(&quot;cancel&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { result.cancel(); } }) .show(); return true; } ; 对 alert 对话框进行处理 改为 Toast显示 @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) { Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); //确认交互完成 提交结果 勿忘 result.confirm(); return true; } ; 获取网站的 title ico信息 重写 WebChromeClient内部方法 123456789101112chromeClient = new WebChromeClient()&#123; //获取 title @Override public void onReceivedTitle(WebView view, String title)&#123; tvTitle.setText(title); &#125; //获取 icon @Override public void onReceivedIcon(WebView view, Bitmap icon) &#123; ImgIcon.setImageBitmap(icon); &#125;&#125;; ; WebView 的滚动监听 在API 23 加入了滚动监听的 get/set方法 ；在API 23之前需要重写 WebView的 protected void onScrollChanged(final int l, final int t, final int oldl,final int oldt){}然后再对外提供一个接口 12345678910111213141516//滚动条监听webView.setOnScrollChangeListener(new View.OnScrollChangeListener() &#123; @Override public void onScrollChange(View v, int scrollX, int scrollY, int oldScrollX, int oldScrollY) &#123;// Log.e(TAG, "onScrollChange: scrollX="+scrollX);// Log.e(TAG, "onScrollChange: oldScrollX="+oldScrollX); Log.e(TAG, "onScrollChange: scrollY="+scrollY);// Log.e(TAG, "onScrollChange: oldScrollY="+oldScrollY); if (scrollY&gt;0)&#123; floatButton.setVisibility(View.VISIBLE); &#125;else&#123; floatButton.setVisibility(View.GONE); &#125; dy = scrollX; &#125;&#125;); 关于滚动条的设置 123webView.setHorizontalScrollBarEnabled(false); //水平滚动条不显示webView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY); //WebView内部显示 回到顶部 实现 使用 方法 scrollTo(x,y); 12345678floatButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, "onClick: dy="+dy); webView.scrollTo(0,0); floatButton.setVisibility(View.GONE); &#125; &#125;); 网页自适应 必须两个都写上, 缺一不可12settings.setUseWideViewPort(true); //支持 viewportsettings.setLoadWithOverviewMode(true); //自适应屏幕 ;; 支持缩放网页隐蔽缩放控件1234//保留缩放功能 隐藏缩放控件settings.setBuiltInZoomControls(true);settings.setDisplayZoomControls(false);settings.setSupportZoom(true); //支持缩放 回退键实现 返回网页回退 而不退出程序 重写 onBackPressed() 通过 canGoBack()判断是否能够回退 ，通过 goBack()实现回退 123456789101112131415161718@Overridepublic void onBackPressed() &#123; //判断 WebView 是否可以回退 if (webView.canGoBack())&#123; webView.goBack(); &#125;else&#123; Log.e(TAG, "onBackPressed: currentTimeMillis="+System.currentTimeMillis()); Log.e(TAG, "onBackPressed: exit="+exit); Log.e(TAG, "onBackPressed: currentTimeMillis- exit="+(System.currentTimeMillis()-exit)); if (System.currentTimeMillis()-exit &gt;2000)&#123; Toast.makeText(this, "再按一次退出", Toast.LENGTH_SHORT).show(); exit= System.currentTimeMillis(); &#125;else&#123; super.onBackPressed(); &#125; &#125;&#125; 与js交互 js调用本地API调用js function未完待续。。。。 参考文章： http://www.runoob.com/w3cnote/android-tutorial-webview.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的广播]]></title>
    <url>%2F2016%2F10%2F16%2FBroadcast%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io Broadcast在Android中 Broadcast是一种 广泛运用在引用程序之间传输信息的机制。而BroadcastReceiver 是对发送出来的Broadcaset进行过滤接受并响应的一类组件。如果不需发送广播到别的应用 使用 LocalBroadcastManger就可以了。 发送和接收流程发送和接受的过程： 发送首先在需要发送信息的地方 ，把要发送的信息和用于过滤的信息（如action 和 category）封装进intent对象，然后调用 Context.sendBroadcast() 、sendOrderBroadcast()或sendStickBroadcast()方法，把intent对象以广播的形式发送出去 接收当intent发送后，所有已经注册的BroadcastReceiver会检查注册时的IntentFilter是否与发送的intent匹配。若匹配就会调用BroadcastReceiver的onReceiver() 方法。所以 我们定义一个BroadcastReceiver的时候必须实现onReceiver()方法 Note：若在使用sendBroadcast()的方法时指定了接受权限，则只有在AndroidManifest.xml文件中声明了对应权限的BroadcastReceiver才能就收到；同样的，如果在注册BroadcastReceiver时指定了可接受的Broadcast的权限，则只有在包的AndroidManifest.xml中用标签声明了。拥有此权限的Context对象所发送的Broadcast才能被这个BroadcastReceiver所接收。 虽然 广播的发送和接受都是通过intent类，但是广播intent完全和 启动activity的intent不同。BroadcastReceiver是无法看到启动activity的intent的。同样的，当你发送一个Broadcast Intent 是不会去发现或启动一个activity的。两者是完全不同的。启动activity的intent是属于前台用户可以看到的操作，而 Broadcat Intent是后台操作 。通常用户是看不到 的。 广播类型 两大类 广播类型 ： Normal broadcasts(普通广播) :使用 Context.sendBroadcast ;完全是异步操作，广播发出后广播的所有接受者通常都在同一时间运行并得到结果，但是顺序不固定。这样效率是很高的但是 接收器的结果并不能影响其他的接受者 Orderd broadcasts(有序广播) :同步操作一次发送到一个接受者 ，按照预先声明的顺序依次接受，（-1000~1000）优先级高的优先接受到广播，优先级高的可以更改广播或者完全终止这个广播（abortBroadcast()），那优先级低的接受者将不能接受到 接收广播 使用broadcastsReceiver 接受广播，定义自己的广播接收器 只需继承BroadcastsReceiver； 广播接收器创建完毕后需要注册才能接受到。注册分为两种 动态和静态；如果发送的广播附带有权限 ，那接受者必须有相应的权限才能接受到 在BroadcastReceiver中一般是用来启动 某个activity或者启动某个服务，不允许执行耗时操作，也不允许开线程，最好是操作不要超过10秒。* 定义 接收器 接收网络变化 继承 BroadcastReceiver 1234567891011121314/** * Created by sky-mxc * 网络状态改变接收器 */public class NetworkReceiver extends BroadcastReceiver &#123; private static final String TAG = "NetworkReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; Log.i(TAG,"=====网络状态改变了"); Toast.makeText(context,"网络状态改变了",Toast.LENGTH_LONG).show(); &#125;&#125; 静态注册 静态注册：在manifest文件 使用 标签注册 ，并在标签内设置过滤器(intentFilter) 什么时候都可以接受到广播，只要应用程序安装了 就是注册了，如果有广播就能接受 但是规定有部分广播 静态注册无法接受 例如屏幕的关闭和点亮广播。 123456&lt;receiver android:name=".receiver.NetworkReceiver"&gt; &lt;intent-filter &gt; &lt;!--priority 默认0--&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册 动态注册： 动态的在代码中定义。先定义设置好一个IntentFilter对象。然后在需要注册时调用Context.registerReceiver()，如果取消就调用Context.unregisterReceiver()方法。（动态注册的BroadcastReceiver在context被销毁后也会被干死） 使用 context.registerReceiver() 注册 1234receiver = new NetworkReceiver();IntentFilter intentFilter = new IntentFilter("android.net.conn.CONNECTIVITY_CHANGE");intentFilter.setPriority(600);registerReceiver(receiver,intentFilter); 取消注册 context.unregisterReceiver(); 123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(receiver);&#125; 发送广播发送普通广播 使用方法 sendBroadcast() 发送广播。 1234//发送普通广播Intent intent = new Intent("com.mxc.example.broadcast.normal");intent.putExtra("type","normal");sendBroadcast(intent); 接收发送的广播 Manifest文件注册 12345&lt;receiver android:name=".receiver.MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.mxc.example.broadcast.normal"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 接收发送的数据12345678public class MyReceiver extends BroadcastReceiver &#123; private static final String TAG = "MyReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; Log.i(TAG,"==action:"+intent.getAction()+"===time:"+ SystemClock.currentThreadTimeMillis()); Log.i(TAG,"==type:"+intent.getStringExtra("type")); &#125;&#125; 发送有序广播使用 sendOrderedBroadcast() 如果接受者不需要权限 设置为null即可1234Intent orderIntent = new Intent("com.mxc.example.broadcast.order");orderIntent.putExtra("type","order");//不添加权限sendOrderedBroadcast(orderIntent,null); 可以通过 priority 属性来设置接受者的优先级，优先级的接受者可以 终止广播的发送或者 添加额外的数据或者修改 发送的广播数据 终止 广播1234if (intent.getAction().equals("com.mxc.example.broadcast.order"))&#123; //终止广播 abortBroadcast(); &#125; 添加或者修改数据1234//增加额外的结果Bundle b = getResultExtras(true);//获取数据 如果没有就创建b.putString("result","MyReceiver");setResultExtras(b); 获取 额外的数据1Log.e(TAG,"==result:"+getResultExtras(true).getString("result")); Log 信息12345I/MyReceiver: ==action:com.mxc.example.broadcast.order===time:390I/MyReceiver: ==type:orderI/SecondReceiver: ==action:com.mxc.example.broadcast.order===time:391I/SecondReceiver: ==type:orderE/SecondReceiver: ==result:MyReceiver 本地广播 本地广播和广播的操作几乎是一致的不过是使用 LocalBroadcastManager 来管理的；发送的注册都是 LocalBroadcastManager实例来管理 本地广播和 广播一样 分为 异步广播和同步广播 发送本地广播1234Intent localIntent = new Intent("com.example.broadcast.local.async");manager.sendBroadcast(localIntent);//发送 同步的（有序）的广播//manager.sendBroadcastSync(localIntent); 接收本地广播1234manager = LocalBroadcastManager.getInstance(this);receiver = new LocalReceiver();IntentFilter filter = new IntentFilter("com.example.broadcast.local.async");manager.registerReceiver(receiver,filter); 各种广播 &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;&lt;/action&gt; 开机广播 &lt;permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt; 接受的权限 android.intent.action.SCREEN_OFF 屏幕点亮 规定 只有动态注册才可以 android.intent.action.SCREEN_ON 屏幕关闭 规定 只有动态注册才可以 android.net.conn.CONNECTIVITY_CHANGE 网络状态改变 特别感谢： 本文中的图 都是从菜鸟扒的]]></content>
      <categories>
        <category>Android</category>
        <category>广播</category>
      </categories>
      <tags>
        <tag>Broadcast</tag>
        <tag>广播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager 获取当前显示的Fragment]]></title>
    <url>%2F2016%2F10%2F11%2FgetCurrentFragment%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io Viewpager 获取当前显示的fragment使用 getSupportFragmentManager().findFragmentByTag()方法 Viewpager + FragmentPagerAdapter 情况下 才好使； FragmentPagerAdapter 有一个特点 凡是加载过的Fragment 都会被保留,既然Fragment不会被销毁，那我们就可以使用findFragmentByTag() 方法找到它；但问题是动态创建的话 tag的设置；我们知道动态加载时是可以设置tag的，但是动态创建就没法设置了;如果viewpager使用的是适配器是 FragmentPagerAdapter 的话 ，Fragment就会被设置上tag 根据这个tag 我们就可以获取到当前显示的fragment了；下面看看这个过程 新创建时 tag ==null 123456789@Overridepublic Fragment getItem(int position) &#123; PageTab pageTab = tabs.get(position); TabFragment tab = new TabFragment(); Log.e(TAG,"====getItem===新创建时的tag:=="+tab.getTag()); tab.getArguments().putSerializable("tab",pageTab); //取出数据 新建Fragment return tab;&#125; Log 查看 tag 时为 null 1E/FileListPagerAdapter: ====getItem===新创建时的tag:==null 将 适配器设置给Viewpager后 的tag 1234E/MainActivity: ==findCurrentFragment==pagerId:2131492976E/MainActivity: ==findCurrentFragment==currentItem:0E/MainActivity: =======findCurrentFragment=========完整Tag===android:switcher:2131492976:0E/MainActivity: =======findCurrentFragment=========当前显示的Fragment 的tag===:android:switcher:2131492976:0 可以看到 tag的组成；四部分 android : &nbsp;&nbsp;&nbsp;&nbsp; 固定部分 switcher : &nbsp;&nbsp;&nbsp;&nbsp; 固定部分 2131492976 : &nbsp;&nbsp;&nbsp;&nbsp; ViewPager 的id 0 : &nbsp;&nbsp;&nbsp;&nbsp; ViewPager 当前显示的itemPostion 既然FragmentPagerAdapter的特点是保存fragment状态。 就可以利用这个特点通过 findFragmentByTag() 找到这个Fragment 12//Viewpager + FragmentPagerAdapter 情况下 获取 当前显示的Fragment,只能找已经加载过的FragmentFragment fragment = getSupportFragmentManager().findFragmentByTag("android:switcher:"+pager.getId()+":"+pager.getCurrentItem()); 重写适配器的 setPrimaryItem()方法 ; 这个方法在每次viewpager滑动后都会被调用 而 object参数就是显示的Fragment ；可以在适配器中定义个变量 currentFragment 每次改变时都会获取到显示的Fragment 12345@Overridepublic void setPrimaryItem(ViewGroup container, int position, Object object) &#123; currentFragment = (TabFragment) object; super.setPrimaryItem(container, position, object);&#125; 这种方式有一个缺陷 setPrimaryItem()是在 viewpager的滑动监听执行完后才会调用的；所以在 换的个滑动监听中获取当前显示的Fragment 是不对的]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewPager</tag>
        <tag>获取当前显示的Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.0 运行时权限处理]]></title>
    <url>%2F2016%2F10%2F08%2Fpermission%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明出处：https://sky-mxc.github.io 6.0 运行时权限处理 在6.0以前 权限都是在安装时授权的，如果用户不授权就无法安装；Android从6.0（API 23）开始 使用运行时权限，而不是像以前那样安装时授权。当你需要某些权限时，系统会向用户去申请权限。用户可以随时取消授权给你的权限。6.0中权限分为两类 普通权限和危险权限，普通权限在AndroidManifest 文件中注册就可以得到，对于能获得用户隐私的权限属于危险权限。在使用的时候必须用户授权才能使用。例如 拍照，录音 sd卡的操作，危险权限被分为很多组，只要一组中的其中一项被授权 Android 就会将这一组的权限打包都授权给你app 危险权限 危险权限被分为了9组 Permission Group Permissions CALENDAR • READ_CALENDAR • WRITE_CALENDAR CAMERA • CAMERA CONTACTS • READ_CONTACTS • WRITE_CONTACTS • GET_ACCOUNTS LOCATION • ACCESS_FINE_LOCATION • ACCESS_COARSE_LOCATION MICROPHONE • RECORD_AUDIO PHONE • READ_PHONE_STATE • CALL_PHONE • READ_CALL_LOG • WRITE_CALL_LOG • ADD_VOICEMAIL • USE_SIP • PROCESS_OUTGOING_CALLS SENSORS • BODY_SENSORS SMS • SEND_SMS • RECEIVE_SMS • READ_SMS • RECEIVE_WAP_PUSH • RECEIVE_MMS STORAGE • READ_EXTERNAL_STORAGE • WRITE_EXTERNAL_STORAGE 普通权限 • ACCESS_LOCATION_EXTRA_COMMANDS • ACCESS_NETWORK_STATE • ACCESS_NOTIFICATION_POLICY • ACCESS_WIFI_STATE • BLUETOOTH • BLUETOOTH_ADMIN • BROADCAST_STICKY • CHANGE_NETWORK_STATE • CHANGE_WIFI_MULTICAST_STATE • CHANGE_WIFI_STATE • DISABLE_KEYGUARD • EXPAND_STATUS_BAR • GET_PACKAGE_SIZE • INSTALL_SHORTCUT • INTERNET • KILL_BACKGROUND_PROCESSES • MODIFY_AUDIO_SETTINGS • NFC • READ_SYNC_SETTINGS • READ_SYNC_STATS • RECEIVE_BOOT_COMPLETED • REORDER_TASKS • REQUEST_IGNORE_BATTERY_OPTIMIZATIONS • REQUEST_INSTALL_PACKAGES • SET_ALARM • SET_TIME_ZONE • SET_WALLPAPER • SET_WALLPAPER_HINTS • TRANSMIT_IR • UNINSTALL_SHORTCUT • USE_FINGERPRINT • VIBRATE • WAKE_LOCK • WRITE_SYNC_SETTINGS 请求权限targetSdkVerion 申请权限之前必须先说一下tartgetSdkVersion ，目标sdk版本，一般定义在build.gradle文件中。 如果 targetSDKVersion 是22 安装好之后 Android系统就知道这个App在系统API22一下都测试过了并且能正确运行的，假如这个App运行在了Android6.0系统上，Android就会对这个App很”照顾“，兼容它正确运行。6.0系统会把App申请的权限都默认给这个App。但是 ，在6.0系统 ，用户可随时撤销授权给app的权限 ，即使系统默认都授权给你，用户也可以取消掉。这时就没权限了。所以即使是targetSDKVersion &lt; 23 也不是就万事大吉了。Android为我们提供了android.support.v4.content.PermissionChecker 来检测是否具有某些权限 判断 targetSdkVersion 123456789101112131415161718/** * 检查targetSDKVersion 是否在 23以上 * @return */private boolean checkTargetSdkVersion()&#123; PackageInfo info= null; try &#123; info = getPackageManager().getPackageInfo(getPackageName(),0); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; int targetSdk= info.applicationInfo.targetSdkVersion; log("TargetSdkVersion:"+targetSdk); if (targetSdk&gt;=Build.VERSION_CODES.M)&#123; return true; &#125; return false;&#125; 检查权限 在去请求权限之前 应该先检查一下系统 的版本 如果系统版本在6.0以上再去请求权限，如果不在就不去请求，直接使用 123456789101112/** * 检查系统版本是否在6.0或者6.0以上 * @return */private boolean checkVersion()&#123; // Build.VERSION.SDK_INT 当前系统版本 //Build.VERSION_CODES.M 6.0版本 if(Build.VERSION.SDK_INT &gt;=Build.VERSION_CODES.M)&#123; return true; &#125; return false;&#125; PermissionChecker.checkSelfPermission() 方法就是用于检查App自身有没有某一个权限 此方法适用于 targetSdkVersion &lt; 23 context.checkSelfPermission() 适用于 targetSDKVersion &gt;=23 返回结果有三种 状态 PermissionChecker.PERMISSION_GRANTED; //有权限 PermissionChecker.PERMISSION_DENIED ; //无权限 PermissionChecker.PERMISSION_DENIED_APP_OP;//无权限 PermissionChecker.PERMISSION_DENIED 和 PermissionChecker.PERMISSION_DENIED_APP_OP 的区别: targetSDKVersion 小于23没有权限就返回 PermissionChecker.PERMISSION_DENIED_APP_OP targetSdkVersion23或者以上的返回 PermissionChecker.PERMISSION_DENIED 12345678910//检测targetSDKVersion 是否在23以上if (checkTargetSdkVersion())&#123; //targetSDKVersion &gt;=23 //检查是否具有读取短信的权限 result = checkSelfPermission(permission);&#125;else&#123; //targetSDKVersion &lt;23 //检查是否具有读取短信的权限 result= PermissionChecker.checkSelfPermission(this,permission);&#125; 请求权限 使用 requestPermissions() 方法去请求权限 参数有两个 权限数组 和请求码 1requestPermissions(new String[]&#123;"android.permission.READ_SMS"&#125;,10); 在请求权限之前最好是跟用户解释清楚为什么要使用这个权限 ，用时候用户并不清楚为什么使用权限 就会被拒绝，如果一个权限被请求一次以上 在系统申请权限的Dialog会出现一个不再提醒的复选框 那怎么判断 用户是否勾选了这个 不再提醒呢 ，Android提供了 shouldShowRequestPermissionRationale() 方法; 这个方法 在 第一次请求的时候 和 在用户勾选了不再提醒时 返回false ，其他均返回true 123456789101112131415161718192021// 第一次请求就返回false 拒绝过返回true 或者 用户选择不再提示返回falseboolean answer= shouldShowRequestPermissionRationale(permission);log("shouldShowRequestPermissionRationale :"+answer);if (!answer)&#123; new AlertDialog.Builder(this).setTitle("权限说明") .setMessage("此功能需要读取短信的权限，没有权限无法使用此功能。请在稍后授权后使用") .setNegativeButton("确定", new DialogInterface.OnClickListener() &#123; @RequiresApi(api = Build.VERSION_CODES.M) @Override public void onClick(DialogInterface dialog, int which) &#123; requestPermissions(new String[]&#123;permission&#125;,SMS); &#125; &#125;) .setNeutralButton("取消",null) .show();&#125;else&#123; requestPermissions(new String[]&#123;permission&#125;,SMS);&#125; 处理用户响应 重写 activity的 onRequestPermissionsResult() 的方法 处理权限的响应 权限的申请是可以多个权限一块申请的 ，所以 响应结果也是 数组和 请求的权限数组对应 1234567891011121314151617181920212223/** * 申请权限的响应 * @param requestCode 请求码 * @param permissions 权限数组 * @param grantResults 结果数组 */@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case SMS: LogCheckResult(grantResults[0]); if (grantResults.length&gt;0 &amp;&amp; grantResults[0]==PermissionChecker.PERMISSION_GRANTED)&#123; //TODO 读取短信 Toast.makeText(this,"读取短信授权成功",Toast.LENGTH_SHORT).show(); tv.setText(getSmsInPhone()); &#125;else&#123; Toast.makeText(this,"读取短信授权失败",Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125; 完整的短信读取权限申请 流程 请求权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 请求短信权限 */@RequiresApi(api = Build.VERSION_CODES.M)private void requestSms() &#123; // 权限 final String permission = "android.permission.READ_SMS"; //检查当前系统版本是否在6.0以上 if (checkVersion())&#123; int result =-1; //检测targetSDKVersion 是否在23以上 if (checkTargetSdkVersion())&#123; //targetSDKVersion &gt;=23 //检查是否具有读取短信的权限 result = checkSelfPermission(permission); &#125;else&#123; //targetSDKVersion &lt;23 //检查是否具有读取短信的权限 result= PermissionChecker.checkSelfPermission(this,permission); &#125; LogCheckResult(result); if(result==PermissionChecker.PERMISSION_GRANTED)&#123; //已经有了权限 //TODO 读取短信 Toast.makeText(this,"读取短信授权成功",Toast.LENGTH_SHORT).show(); tv.setText(getSmsInPhone()); &#125;else&#123; //没有权限 //TODO 请求权限 // 第一次请求就返回false 拒绝过返回true 或者 用户选择不再提示返回false boolean answer= shouldShowRequestPermissionRationale(permission); log("shouldShowRequestPermissionRationale :"+answer); if (!answer)&#123; new AlertDialog.Builder(this).setTitle("权限说明") .setMessage("此功能需要读取短信的权限，没有权限无法使用此功能。请在稍后授权后使用") .setNegativeButton("确定", new DialogInterface.OnClickListener() &#123; @RequiresApi(api = Build.VERSION_CODES.M) @Override public void onClick(DialogInterface dialog, int which) &#123; requestPermissions(new String[]&#123;permission&#125;,SMS); &#125; &#125;) .setNeutralButton("取消",null) .show(); &#125;else&#123; requestPermissions(new String[]&#123;permission&#125;,SMS); &#125; &#125; &#125;else&#123; //无需请求 Toast.makeText(this,"读取短信授权成功",Toast.LENGTH_SHORT).show(); tv.setText(getSmsInPhone()); &#125;&#125; 响应处理 1234567891011121314151617@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case SMS: LogCheckResult(grantResults[0]); if (grantResults.length&gt;0 &amp;&amp; grantResults[0]==PermissionChecker.PERMISSION_GRANTED)&#123; //TODO 读取短信 Toast.makeText(this,"读取短信授权成功",Toast.LENGTH_SHORT).show(); tv.setText(getSmsInPhone()); &#125;else&#123; Toast.makeText(this,"读取短信授权失败",Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125; 短信读取 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public String getSmsInPhone() &#123; log("开始读取短信"); final String SMS_URI_ALL = "content://sms/"; final String SMS_URI_INBOX = "content://sms/inbox"; final String SMS_URI_SEND = "content://sms/sent"; final String SMS_URI_DRAFT = "content://sms/draft"; final String SMS_URI_OUTBOX = "content://sms/outbox"; final String SMS_URI_FAILED = "content://sms/failed"; final String SMS_URI_QUEUED = "content://sms/queued"; StringBuilder smsBuilder = new StringBuilder(); try &#123; Uri uri = Uri.parse(SMS_URI_ALL); String[] projection = new String[] &#123; "_id", "address", "person", "body", "date", "type" &#125;; Cursor cur = getContentResolver().query(uri, projection, null, null, "date desc"); // 获取手机内部短信 log("cursor:"+cur.getCount()); if (cur.moveToFirst()) &#123; int index_Address = cur.getColumnIndex("address"); int index_Person = cur.getColumnIndex("person"); int index_Body = cur.getColumnIndex("body"); int index_Date = cur.getColumnIndex("date"); int index_Type = cur.getColumnIndex("type"); do &#123; String strAddress = cur.getString(index_Address); int intPerson = cur.getInt(index_Person); String strbody = cur.getString(index_Body); long longDate = cur.getLong(index_Date); int intType = cur.getInt(index_Type); SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); Date d = new Date(longDate); String strDate = dateFormat.format(d); String strType = ""; if (intType == 1) &#123; strType = "接收"; &#125; else if (intType == 2) &#123; strType = "发送"; &#125; else &#123; strType = "null"; &#125; smsBuilder.append("[ "); smsBuilder.append(strAddress + ", "); smsBuilder.append(intPerson + ", "); smsBuilder.append(strbody + ", "); smsBuilder.append(strDate + ", "); smsBuilder.append(strType); smsBuilder.append(" ]\n\n"); &#125; while (cur.moveToNext()); if (!cur.isClosed()) &#123; cur.close(); cur = null; &#125; &#125; else &#123; smsBuilder.append("no result!"); &#125; // end if smsBuilder.append("getSmsInPhone has executed!"); &#125; catch (SQLiteException ex) &#123; log("SQLiteException in getSmsInPhone"); &#125; return smsBuilder.toString();&#125; 读取短信的代码参考这位大神的代码：http://blog.csdn.net/ithomer/article/details/7328321 关于这次的Demo，github 地址： https://github.com/sky-mxc/AndroidDemo/tree/master/permission]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Permission</tag>
        <tag>运行时权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation]]></title>
    <url>%2F2016%2F10%2F05%2FAnimation%2F</url>
    <content type="text"><![CDATA[动画 帧动画 补间动画 属性动画 Interpolator 帧动画 FrameAnimation 其实就是一个Drawable ，将一系列的图片联合起来顺序的播放。形成动画效果。 帧动画本质就是一些图片的集合，要播放这个动画就必须将一系列的图片全部加载进内存中，所以帧动画的图片不易过大。 创建drawable文件 oneshot ：是否只播放一次， drawable ：一帧的图片 duration ：一帧播放的时间 毫秒单位 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@mipmap/a_01" android:duration="200"/&gt; &lt;item android:drawable="@mipmap/a_02" android:duration="200"/&gt; &lt;item android:drawable="@mipmap/a_03" android:duration="200"/&gt; &lt;item android:drawable="@mipmap/a_04" android:duration="200"/&gt; &lt;item android:drawable="@mipmap/a_5" android:duration="200"/&gt; &lt;item android:drawable="@mipmap/a_6" android:duration="200"/&gt;&lt;/animation-list&gt; 使用刚才的drawable文件做背景12345678910111213141516&lt;ImageView android:id="@+id/image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:adjustViewBounds="true" android:background="@drawable/drawable_frame" android:clickable="true" android:onClick="onClick"/&gt; 播放动画1234//FrameAnimation 帧动画((AnimationDrawable)image.getBackground()).start(); 补间动画 tweenAnimation 主要是对view的内容完成一系列的图形变换(缩放，透明，旋转，平移）来实现动画效果。 具体来说就是 预先定义一些指令 ，这些指令指定了图形变换的类型，触发时间，持续时间。指令可以预先定义在xml文件中也可以源代码的方式定义。程序沿着时间线执行这些指令就可以实现动画效果。 Android中提供了 Animation，Interpolator，Transformation 等类具体实现Tween动画， Animation类及其子类是动画的核心模块，它实现了 各种动画效果如 平移 旋转 缩放 改变透明度等等。 Tween动画的每一帧都根据Interpolator对view的内容做一次图像变换，因此Animation的核心工作是做变换（transformation）； Animation是基类 ，它记录了动画的通用属性和方法。主要的属性包括动画持续时间、重复次数、Interpolator等。 常用属性 duration ：动画时间 毫秒 infinite ：无限次 fillAfter 是否停顿在最后一针 repeatMode 重复模式 值：restart 重新开始 reserve 反复 repeatCount ：重复次数 startOffset ：开始延迟时间 常用Animation子类： AlphaAnimation 改变Alpha值 TranslationAnimation 平移动画 RotateAnimation 旋转动画 ScaleAnimation 缩放动画 AnimationSet 动画集合 实例 补间动画 既可以使用 xml文件预先定义 也可以使用代码动态创建; 使用xml文件定义必须在 res/anim/目录下创建 文件; 可以使用 AnimationUtils的静态方法 loadAnimation()将动画文件加载 AlphaAnimation 透明度改变动画定义 AlphaAnimation 文件123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:fromAlpha="1" android:toAlpha="0.1" android:duration="2000" android:repeatCount="5" android:repeatMode="reverse"&gt;&lt;/alpha&gt; 加载 动画文件并播放123456//AlphaAnimation xml定义AlphaAnimation alphaAnimation = (AlphaAnimation) AnimationUtils.loadAnimation(this,R.anim.anim_alpha);view.startAnimation(alphaAnimation); 代码创建12345678910111213141516//AlphaAnimation 代码创建AlphaAnimation alphaAnimation1 = new AlphaAnimation(0.1f,0.8f);alphaAnimation1.setDuration(2000);alphaAnimation1.setStartOffset(100);alphaAnimation1.setFillAfter(true);alphaAnimation1.setRepeatCount(2);alphaAnimation1.setRepeatMode(Animation.REVERSE);view.startAnimation(alphaAnimation1); TranslationAnimation 平移动画 fromXDelta X轴开始坐标 toXDelta X轴结束坐标 fromYDelta Y 轴开始坐标 toYDelta Y轴结束坐标 &gt; 定义动画文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;translate xmlns:android="http://schemas.android.com/apk/res/android" android:duration="2000" android:fromXDelta="0" android:toXDelta="300" android:repeatMode="reverse" android:repeatCount="3" android:fillBefore="true" android:fromYDelta="200" android:toYDelta="100"&gt;&lt;/translate&gt; 加载动画并播放1234TranslateAnimation translateAnimation = (TranslateAnimation) AnimationUtils.loadAnimation(this,R.anim.anim_translation);view.startAnimation(translateAnimation); 代码创建动画12345678TranslateAnimation translateAnimation1 = new TranslateAnimation(-10,100,0,0);translateAnimation1.setInterpolator(new BounceInterpolator());translateAnimation1.setDuration(2000);view.startAnimation(translateAnimation1); RotateAnimation 旋转动画 fromDegrees:起始角度 toDegrees:到达角度 pivotX:X轴中心点 pivotY:Y轴中心点 中心点取值模式： 固定像素 50 相对于自身 50% 相对于父容器 50%p 定义动画文件123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:pivotX="50%" android:pivotY="50%" android:toDegrees="90" android:fromDegrees="0" android:duration="2000" android:fillAfter="true"&gt;&lt;/rotate&gt; 加载动画并播放1234RotateAnimation rotate = (RotateAnimation) AnimationUtils.loadAnimation(this,R.anim.anim_rotate);view.startAnimation(rotate); 代码创建动画123456789101112//在右上角中心，0-180度RotateAnimation rotate = new RotateAnimation(0, 180);//（100，100）像素位中心RotateAnimation rotate = new RotateAnimation(0, 180, 100, 100);//相对于自身一半为中心RotateAnimation rotate = new RotateAnimation(0, 180,Animation.RELATIVE_TO_SELF, 0.5f,Animation.RELATIVE_TO_SELF, 0.5f); 沿中心旋转 45° 12345678910RotateAnimation rotateAnimation = new RotateAnimation(0,45,Animation.RELATIVE_TO_SELF, 0.5f,Animation.RELATIVE_TO_SELF, 0.5f);rotateAnimation.setInterpolator(new DecelerateInterpolator());rotateAnimation.setDuration(2000);rotateAnimation.setFillAfter(true);view.startAnimation(rotateAnimation); ScaleAnimation 缩放动画 fromXScale:X轴起始缩放值 fromYScale:Y轴起始缩放值 toXScale:X轴到达缩放值 toYScale:Y轴到达缩放值 缩放值可以是缩放倍数，也可以是缩放到具体尺寸 定义动画文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:fromXScale="0" android:toXScale="2" android:fromYScale="0" android:toYScale="3" android:duration="2000" android:pivotY="50%" android:pivotX="50%"&gt;&lt;/scale&gt; 加载动画并播放1234ScaleAnimation scale = (ScaleAnimation) AnimationUtils.loadAnimation(this,R.anim.anim_scale);view.startAnimation(scale); 代码创建动画123456ScaleAnimation scale = new ScaleAnimation(0, 2, 0, 2);ScaleAnimation scale = new ScaleAnimation(0, 2, 0, 2, 100, 100);ScaleAnimation scale = new ScaleAnimation(0, 2, 0, 2,Animation.RELATIVE_TO_PARENT, 0.5f,Animation.RELATIVE_TO_PARENT, 0.5f); AnimationSet 动画集合定义动画文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="2000"&gt; &lt;rotate android:pivotX="0" android:pivotY="0" android:fromDegrees="-180" android:toDegrees="0"/&gt; &lt;scale android:pivotX="50%" android:pivotY="50%" android:fromXScale="0" android:toXScale="1" android:fromYScale="0" android:toYScale="1"/&gt;&lt;/set&gt; 加载动画并播放1234Animation animation = AnimationUtils.loadAnimation(this,R.anim.anim_set);view.startAnimation(animation); 代码创建动画1234567891011121314//子动画是否共用差值器AnimationSet set = new AnimationSet(true);set.addAnimation(new RotateAnimation(-180,0));set.addAnimation(new ScaleAnimation(0,1,0,1,Animation.RELATIVE_TO_SELF, 0.5f,Animation.RELATIVE_TO_SELF,0.5f));set.setDuration(2000);set.setFillAfter(true);view.startAnimation(set); Interpolator Interpolator 被用来修饰动画效果，定义动画的变化率，可以使存在的动画效果accelerated(加速)，decelerated(减速),repeated(重复),bounced(弹跳)等。 常用的差值器 LinearIntepolator 匀速效果 DecelerateInterpolator 减速效果 Accelerateinterpolator 加速效果 CycleInterpolator 循环效果 BouncedInterpolator 弹跳效果 Property Animation 属性动画 属性动画的用处有很多很多，我就列几个常用的方式把；具体参考官网文档：https://developer.android.com/guide/topics/graphics/prop-animation.html 补间动画并不能改变view真实的位置，只是形式上的位置改变。而属性动画会将view的真实位置改变。 属性动画定义必须在 res/animator目录下 ValueAnimation valueType 常用三种取值： intType整数值、 floatType浮点值、 colorType颜色值、 定义动画文件123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animator xmlns:android="http://schemas.android.com/apk/res/android" android:valueFrom="2" android:valueTo="200" android:duration="2000" android:valueType="intType" android:interpolator="@android:interpolator/linear"&gt;&lt;/animator&gt; 加载动画 并添加 动画监听 属性动画 就是在 监听中去改变控件的属性的值 ，让控件 位置和形态的属性都发生真正的变化 123456789101112131415161718192021222324252627282930 ValueAnimator animator = (ValueAnimator) AnimatorInflater.loadAnimator(this,R.animator.animator_value); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //intType int value= (int) animation.getAnimatedValue(); image.setTranslationY(value); // image.setTranslationX(value); //floatType// float alpha = (float) animation.getAnimatedValue();// image.setAlpha(alpha); &#125; &#125;); 代码创建 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ValueAnimator valueAnimator = ValueAnimator.ofFloat(1f,0.5f,0f);PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat("alpha",1f,0.5f);PropertyValuesHolder widthHolder = PropertyValuesHolder.ofInt("width",1,200);PropertyValuesHolder rotateHolder = PropertyValuesHolder.ofFloat("rotate",0,180);ValueAnimator valueAnimator = ValueAnimator.ofPropertyValuesHolder(alphaHolder,widthHolder,rotateHolder);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123;// float value= (float) animation.getAnimatedValue();// image.setAlpha(value); float alpha= (float) animation.getAnimatedValue("alpha"); int width = (int) animation.getAnimatedValue("width"); float rotate = (float) animation.getAnimatedValue("rotate"); Log.e("MainActivity","alpha:"+alpha); Log.e("MainActivity","width:"+width); image.setAlpha(alpha); image.setMaxWidth(width); image.setMinimumWidth(width); image.setRotation(rotate); &#125;&#125;);valueAnimator.setDuration(2000);valueAnimator.start(); ObjectAnimator 大部分属性都和ValueAnimator相同，只多了对要控制改变的控件的属性的声明 propertyName：要控制的控件的属性名; 动画会直接修改制定属性名的属性 需要注意：设置了getter/setter方法的属性才能生效 定义动画文件123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:propertyName="rotation" android:valueFrom="0" android:valueTo="45" android:duration="2000" android:valueType="floatType"&gt; &lt;!-- rotation rotationY rotationX --&gt;&lt;/objectAnimator&gt; 加载动画并设置播放动画的对象123456ObjectAnimator object = (ObjectAnimator) AnimatorInflater.loadAnimator(this,R.animator.animator_object);object.setTarget(image);object.start(); 代码创建动画 凡是 有get/set方法的属性都可以设置值 12345678910// ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(image,"alpha",1f,0.2f);ObjectAnimator objectAnimator = ObjectAnimator.ofInt(view,"backgroundColor", Color.RED,Color.YELLOW,Color.BLUE,Color.GREEN);objectAnimator.setDuration(2000);objectAnimator.setInterpolator(new BounceInterpolator());objectAnimator.start(); 完整代码github地址：https://github.com/sky-mxc/AndroidDemo/tree/master/animation]]></content>
      <categories>
        <category>Android</category>
        <category>动画</category>
      </categories>
      <tags>
        <tag>Animatoin</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2F2016%2F10%2F03%2FContentProvider%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io ContentProvider 内容提供者，应用程序间的数据交互，是为存储和获取数据提供的统一接口。Contentprovider为应用间数据交互提供了安全的环境，它允许把自己的应用数据开放给其他应用进行 CRUD。怎么样进行操作可以自己规定，不用担心权限的问题。 当然如果不想被被人读取自己应用的数据就不需要这个内容提供者。ContentResolver来访问和操作我们的数据。ContentResolver 通过我们注册的uri就可以找到我们开放的数据。 关于uri 参考这篇文章：http://blog.csdn.net/dlutbrucezhang/article/details/8917303 创建一个ContentProvider 创建自己的内容提供程序 只需继承ContentProvider即可。这里就以insert 和 query 为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.skymxc.demo.contentprovider.util;import android.content.ContentProvider;import android.content.ContentUris;import android.content.ContentValues;import android.content.UriMatcher;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.net.Uri;import android.support.annotation.Nullable;import android.text.TextUtils;/** * Created by sky-mxc */public class StudentProvider extends ContentProvider &#123; private DBHelper dbHelper; private UriMatcher uriMatcher; //匹配结果是一张表 private static final int STUDENTS = 1; //匹配结果是一个条数据 private static final int STUDENT = 2; //一般是包名 避免重复 private static final String AUTHORITY = "com.skymxc.demo"; @Override public boolean onCreate() &#123; dbHelper = new DBHelper(getContext()); //初始化 uri匹配者 UriMatcher.NO_MATCH：匹配不上时返回 uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); //添加能够匹配的uri格式 参数1authorities 匹配住机。 参数2 匹配路径 参数3 code ： match success return this code； // 代表这个uri 操作的是一个表，匹配码是 STUDENTS uriMatcher.addURI(AUTHORITY,"student", STUDENTS); //代表这个uri 操作的是一条数据 匹配成功后返回 STUDENT uriMatcher.addURI(AUTHORITY,"student/#",STUDENT); return true; &#125; /** * 查询操作 * @param uri * @param projection 要查询的列 * @param condition 查询条件 * @param values 查询参数 * @param sortOrder 排序 * @return */ @Nullable @Override public Cursor query(Uri uri, String[] projection, String condition, String[] values, String sortOrder) &#123; Cursor cursor =null; SQLiteDatabase db= dbHelper.getDB(); //匹配这个uri 要查询一张表还是 某条数据 switch (uriMatcher.match(uri))&#123; case STUDENT: //查询某条数据 ContentUris :工具类 可以解析出id long id= ContentUris.parseId(uri); String where ="_id ="+id+" "; if (!TextUtils.isEmpty(condition))&#123; where+= " and "+condition; &#125; cursor= db.query(DBHelper.TABLE_NAME,projection,where,values,null,null,sortOrder); break; case STUDENTS: //查询一张表 cursor = db.query(DBHelper.TABLE_NAME,projection,condition,values,null,null,sortOrder); break; default: throw new IllegalArgumentException("match fail 。uri:"+uri+""); &#125; return cursor; &#125; @Nullable @Override public String getType(Uri uri) &#123; String type="unKnow"; switch (uriMatcher.match(uri))&#123; case STUDENT: type="vnd.android.cursor.item/student"; break; case STUDENTS: type= "vnd.android.cursor.dir/student"; break; &#125; return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; SQLiteDatabase db = dbHelper.getDB(); switch (uriMatcher.match(uri))&#123; case STUDENT: break; case STUDENTS: db.insert(DBHelper.TABLE_NAME,"_id",values); break; &#125; return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125;&#125; 创建完之后还需要在manifest文件中注册 才能被其他应用看到，通过 元素注册一个内容提供者 123456789101112&lt;!-- android:exported 设置此provider是否可以被其他应用使用。 android:readPermission 该provider的读权限的标识 android:writePermission 该provider的写权限标识 android:permission provider读写权限标识 android:grantUriPermissions 临时权限标识--&gt;&lt;provider android:authorities="com.skymxc.demo" android:name=".util.StudentProvider" android:exported="true"/&gt; 关于临时权限标识 grantUriPermissions :true时，意味着该provider下所有数据均可被临时使用；false时，则反之，但可以通过设置标签来指定哪些路径可以被临时使用。这么说可能还是不容易理解，我们举个例子，比如你开发了一个邮箱应用，其中含有附件需要第三方应用打开，但第三方应用又没有向你申请该附件的读权限，但如果你设置了此标签，则可以在start第三方应用时，传入FLAG_GRANT_READ_URI_PERMISSION或FLAG_GRANT_WRITE_URI_PERMISSION来让第三方应用临时具有读写该数据的权限。 到这里 一个简单的内容提供者就创建完成了 ContentResolver 可以看做是客户端 与ContentProvider 对应 ，ContentProvider 负责提供数据操作接口 ，ContentResolver 可以调用ContentProvider的数据接口对数据进行操作 为了测试上面定义的ContentProvider ，另创建一个Module 进行读取 123456789101112131415161718192021private void read() &#123; ContentResolver resolver= getContentResolver() ; String uriStr ="content://com.skymxc.demo/student"; Cursor cursor= resolver.query(Uri.parse(uriStr),new String[]&#123;"_id","name","age"&#125;,null,null,"age"); StringBuffer sb = new StringBuffer("============student==================\n"); while (cursor !=null &amp;&amp;cursor.moveToNext())&#123; long id = cursor.getLong(cursor.getColumnIndex("_id")); String name = cursor.getString(cursor.getColumnIndex("name")); int age = cursor.getInt(cursor.getColumnIndex("age")); sb.append("==="+id+"===\n"); sb.append("name:"+name+"\n"); sb.append("age:"+age+"\n"); &#125; sb.append("============================"); tv.setText(sb.toString()); if (cursor != null)&#123; cursor.close(); &#125;&#125; insert123456789101112private void insert() &#123; String name = etName.getText().toString(); String age = etAge .getText().toString(); ContentResolver resolver = getContentResolver(); String uriStr="content://com.skymxc.demo/student"; ContentValues cv = new ContentValues(); cv.put("name",name); cv.put("age",age); resolver.insert(Uri.parse(uriStr),cv);&#125; ContentResolver 还可以用来操作 短信,联系人，多媒体等 数据，这里写个读取短信的实例 读取短信的权限12&gt;&lt;uses-permission android:name="android.permission.READ_SMS"/&gt;&gt;` 12345678910111213141516171819/** * 短信查询 */private void querySms() &#123; String[] projection = new String[]&#123;"_id","address","person","body","type"&#125;; StringBuffer sb = new StringBuffer("短信数据=============\n"); ContentResolver resolver= getContentResolver(); Cursor cursor = resolver.query(Uri.parse("content://sms/"),projection,null,null,null); while (cursor != null &amp;&amp; cursor.moveToNext())&#123; sb.append("id:"+cursor.getInt(cursor.getColumnIndex("_id"))); sb.append("\naddress:"+cursor.getString(cursor.getColumnIndex("address"))); sb.append("\nperson:"+cursor.getString(cursor.getColumnIndex("person"))); sb.append("\nbody:"+cursor.getString(cursor.getColumnIndex("body"))); sb.append("\ntype:"+cursor.getString(cursor.getColumnIndex("type"))); sb.append("\n================================================="); &#125; tv.setText(sb.toString());&#125; ContentObserver 内容观察者，可以给某些数据注册观察者，当数据改变时做出有些操作 初始化观察者12345678private ContentObserver observer = new ContentObserver(new Handler()) &#123; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); Log.e("MainActivity","======数据改变了==="); &#125;&#125;;` 注册观察者123456789Uri uri = Uri.parse("content://"+StudentProvider.AUTHORITY+"/student");//为student 注册观察者/** * parameter1 观察的uri * parameter2 uri的后代是否连带 观察 * parameter3 observer */getContentResolver().registerContentObserver(uri,true,observer); 内容改变时 通知观察者 系统会首先查找 uri 扫描（手机上）所有的注册的observer 的uri 匹配之后执行 observer的onChange 方法 1234567891011121314151617181920@Nullable@Overridepublic Uri insert(Uri uri, ContentValues values) &#123; SQLiteDatabase db = dbHelper.getDB(); int line=0; switch (uriMatcher.match(uri))&#123; case STUDENT: break; case STUDENTS: line= (int) db.insert(DBHelper.TABLE_NAME,"_id",values); break; &#125; if (line&gt;0)&#123; getContext().getContentResolver().notifyChange(uri,null); &#125; return uri;&#125; 当在另一个应用插入数据时 change()调用1E/MainActivity: ======数据改变了===]]></content>
      <categories>
        <category>Android</category>
        <category>内容提供者</category>
      </categories>
      <tags>
        <tag>ContentProvider</tag>
        <tag>内容提供者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACTION_SEND]]></title>
    <url>%2F2016%2F10%2F01%2FACTION-SEND%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io 不使用第三方 SDK 实现简单分享 现在在Android系统中进行分享，主要有两种手段，一种是通过系统自带的来启动分享功能；第二种是通过第三方的SDK插件进行分享；今天先来看看系统自带的分享功能:Intent.ACTOIN_SEND; 分享文本 分享图片+文本 （QQ和微信不支持，只能将图片和文本分两次分享，目前来看只有新浪微博支持） 分享多图片 （和上面一样 ，目前只有新浪微博可以同时分享图片和文本） 分享图片+文本至微信朋友圈 检查是否有intent要启动的activity 分享存文本内容1234567891011121314151617private void share() &#123; /** * 简单分享 * 让用户去选择分享平台 * 只分享简单的文子 */ String context = etContext.getText().toString(); intent = new Intent(Intent.ACTION_SEND); intent.setType("text/plain"); intent.putExtra(Intent.EXTRA_TEXT,context); if(hasApplication(intent))&#123; //没有默认选项 可以自定义dialog标题 startActivity(Intent.createChooser(intent,"分享一下")); //系统默认主题 // startActivity(intent); &#125;&#125; 在分享之前可以先查看一下手机上是否有分享平台，如果没有就给出提示可以增加用户友好度，通过 PackageManager的queryIntentActivities()查看是否有匹配intent的Activity123456789101112/** * 判断是否存在intent要启动的Activity * @param intent * @return */private boolean hasApplication(Intent intent)&#123; //查询是否有该intent要启动的Activity List&lt;ResolveInfo&gt; resolveInfos= getPackageManager().queryIntentActivities(intent,0); log(resolveInfos.size()+""); return resolveInfos.size()&gt;0?true:false;&#125; 另外 使用 Intent.createChooser()可以避免出现默认程序的可能，还可以定义弹出框的标题 ，友好程度更好一些,下面看一下两者的区别 系统默认的主题( startActivity(intent))使用 Intent.createChooser() 分享文本+图片 图片和文本一起分享 目前我测试的只有微博好使 ，QQ和微信 都只能分享图片，不接受文本12345678910111213141516/** * 分享图片 和文本 * QQ 微信 不能图片和文本一起分享 * 微博可以实现图片和文本一起分享 */private void shareChooser() &#123; String context = etContext.getText().toString(); intent = new Intent(Intent.ACTION_SEND); intent.setType("image/*"); intent.putExtra(Intent.EXTRA_TEXT,context); intent.putExtra(Intent.EXTRA_STREAM,uri); if (hasApplication(intent))&#123; startActivity(Intent.createChooser(intent,"选择要分享到的平台吧")); &#125;&#125; 分享多张图片 和上面一样 我测试 只有微博能同时分享图片和文本 12345678910111213141516/** * 分享多个图片 * 目前来看 只有微博能同时分享文本和内容 */private void sharePhototMult() &#123; ArrayList&lt;Uri&gt; uris =new ArrayList&lt;&gt;(); uris.add(uri); uris.add(uri); intent = new Intent(Intent.ACTION_SEND_MULTIPLE); intent.setType("image/*"); intent.putExtra(Intent.EXTRA_TEXT,"分享内容测试"); intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris); if(hasApplication(intent))&#123; startActivity(Intent.createChooser(intent,"选择分享平台")); &#125;&#125; 分享 图片+文本到微信朋友圈 这个方式可以实现 图片+ 文本同时分享 123456789101112131415161718/** * 分享图片去微信朋友圈 */private void sharePhotoToWX() &#123; String wxPackage = "com.tencent.mm"; if (checkPackage(wxPackage))&#123; intent = new Intent(Intent.ACTION_SEND); intent.setClassName(wxPackage,"com.tencent.mm.ui.tools.ShareToTimeLineUI"); intent.setType("image/*"); intent.putExtra("Kdescription","朋友圈分享测试"); intent.putExtra(Intent.EXTRA_STREAM,uri); startActivity(intent); &#125;else&#123; Toast.makeText(this,"微信不存在",Toast.LENGTH_SHORT).show(); &#125;&#125; 检查是否有隐式intent要启动的activity 有时候使用 隐式分享 ，并不知道是否存在分享平台 ，就可以通过以下代码测试 12345678910111213/** * 判断是否存在intent要启动的Activity * @param intent * @return */private boolean hasApplication(Intent intent)&#123; //查询是否有该intent要启动的Activity List&lt;ResolveInfo&gt; resolveInfos= getPackageManager().queryIntentActivities(intent,0); log(resolveInfos.size()+""); return resolveInfos.size()&gt;0?true:false;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Intent.ACTION_SEND 实现简单的分享图片和文字</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2F2016%2F09%2F30%2Factivity%2F</url>
    <content type="text"><![CDATA[sky-mxc 总结 转载注明:https://sky-mxc.github.io/2016/09/30/activity Activity 什么是Activity 创建Activity 启动Activity 保存Activity状态 Activity的生命周期 acitivyt 是什么 引用官方的说法：是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上 创建Activity要创建Activity 必须继承自Activity或者Activity的子类。在Activity的各个生命阶段实现对应的方法； 其中重要的两个方法: onCreate() ,系统在创建Activity时调用此方法；在此方法实现视图绑定；一些 控件的初始化 onPuase(); 用户离开当前Activity调用的第一个方法 ， 创建完成后必须在Manifest文件中 声明此Activity 系统才会知道有这个Activity 1234567&lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=".ExampleActivity" /&gt; ... &lt;/application ... &gt; ...&lt;/manifest &gt; 如果有需要也可以为此Activity添加IntentFilter(IntentFilter稍后我会再做总结),以供外部程序来启动，一般同一应用中不会用到隐式启动。123456789101112&lt;activity android:name=".AActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.skymxc.action.x1" /&gt; &lt;action android:name="com.skymxc.action.x2" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="com.skymxc.catagory.c1" /&gt; &lt;category android:name="com.skymxc.catagory.c2" /&gt; &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 最简单的Activity 只绑定了一个视图12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 启动Activity 可以通过一个intent 来启动 一个Activity ,关于intent稍后会做总结 明确目标启动在明确的指导要启动的Activity的时候可以显示使用intent来启动 12Intent intent = new Intent(this, SignInActivity.class);startActivity(intent); 传递数据如果需要传递数据，可以在intent中放入数据123Intent intent = new Intent(Intent.ACTION_SEND);intent.putExtra("origin", "哈哈");startActivity(intent); 获取数据12Intent intent = getIntent();//获取启动此activity的intentString origin = intent.getStringExtra("origin"); 不明确启动目标在不明确要启动的Activity的时候 可以在intent中添加关于启动目标的描述和类型,系统会过滤所有的Activity的intentFilter来匹配 ；一般 在同一个应用中不必使用隐式Intent； 例如 我在为A Activity添加这样的IntentFilter： 123456789101112&lt;activity android:name=".AActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.skymxc.action.x1" /&gt; &lt;action android:name="com.skymxc.action.x2" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="com.skymxc.catagory.c1" /&gt; &lt;category android:name="com.skymxc.catagory.c2" /&gt; &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 要启动上面的Activity可以这样写 1234567891011121314Intent in = new Intent();////要执行的动作的描述 所有的action中 有一个匹配行in.setAction("com.skymxc.action.x2");//附加信息的描述 这里的描述只要在intentFilter中声明了就能匹配上，// 如果有一项未声明则匹配不上，如果intentFilter中没有可以不添加，会使用默认的categoryin.addCategory("com.skymxc.catagory.c2");//对数据进行描述 C中定义了协议为 filein.setDataAndType(Uri.parse("http://"),"audio/13");if (in.resolveActivity(getPackageManager())!=null)&#123; //启动 startActivity(in);&#125;else&#123; Toast.makeText(this,"系统中不存在可以执行此操作的程序",Toast.LENGTH_SHORT).show();&#125; 为某个结果启动一个Activity如果启动一个Activit只为获得某个结果 可以 使用 startActivityForResult() 来启动一个Activity ，在获得结果后会回调 方法：onActivityResult(); 去图库获取图片 第二个参数是请求码 在onActivityResult()中区分结果1234Intent intent1 = new Intent(Intent.ACTION_PICK);intent1.setData(MediaStore.Images.Media.EXTERNAL_CONTENT_URI);//为了结果去启动一个ActivitystartActivityForResult(intent1,50); onActivityResult()中获取到取得的图片1234567891011121314/** * * @param requestCode 启动时的 requestCode * @param resultCode 跳转的activity给的 * @param data 跳转的activity给的 返回的数据 */@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode== 50 &amp;&amp; resultCode ==RESULT_OK &amp;&amp; data != null)&#123; Uri uri = data.getData(); //返回是标识符指定图片所在的位置的统一资源标识符 img.setImageURI(uri); //设置给 ImageView &#125;&#125; 保存Activity的状态当用户 离开Activity去往另一个Activity时；Activity会被压入返回栈，如果内存不够就会被销毁 ，当Activity被销毁后其中的数据当然就没了，如果需要保留这些数据可调用 方法 onSaveInstanceState()方法 12345@Overridepublic void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) &#123; //存入数据 outState.putBoolean("checked",true);&#125; 当此Activity被创建时 就能取出数据了123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState!=null)&#123; boolean checked = savedInstanceState.getBoolean("checked"); &#125; setContentView(R.layout.activity_main);&#125; Activity的生命周期看一张图描述了整个Activity由生到死的一套回调方法 回调方法说明 先说一下上图的方法： onCreate() :创建Activity ，可以在这里进行初始一些视图和数据 onStart(): 启动Activity ，这里你就可以看到 这个activity了 onResume(): 调用这个方法前 只能看到Activity 并不能进行交互 ，执行完此方法才可以进行交互 ，整个Activity就彻底的运行起来了 onPause() :停止用户交互 你可以看到 但是 不能交互了 比如 启动另一个透明的Dialog Activity 你可以看到原本的Activity ，但是已经失去了焦点 ，无法交互 onStop() ：当前Activity被覆盖时调用 例如 当前activity1跳往到activity2 ，activity就会把activity1覆盖，这时就调用了此方法 onRestart(); 重新启动 onDestroy():activity再结束前调用的最后一个方法;这里可以进行一些释放资源的操作 三种阶段 完整生命周期： 从调用的第一个方法 onCreate() 到最后调用一个的方法onDestroy() ，在onCreate()方法中可以进行一些全局的配置，UI的引用，数据的初始化，也可以从savedInstanceState中读取 保存在设备中或者执行reCreate方法前保存的数据等前提savedInstanceSate不为null，在onDestroy(）方法中可以 释放资源等 可视周期：在执行onStart()和onStop(）之间 在这期间 你可以在屏幕上看到这个Activity但是 不能再前台跟用户交互 。只能看，可以理解为于禁用状态 前台周期：在执行onResume() 和 onPause() 之间，在这期间，用户就可以在前台和activity交互了。 关于这里提到的intent ，intentFilter 我会在之后总结。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seekbar]]></title>
    <url>%2F2016%2F09%2F30%2FSeekBar%2F</url>
    <content type="text"><![CDATA[SeekBar 可拖动进度条 sky-mxc 总结 转载注明:https://sky-mxc.github.io/2016/09/30/SeekBar 常用属性 常用方法 自定义样式 常用的属性 max 最大值 progress 进度值 secondaryProgress 第二进度条 progressDrawable 进度图片 thumb 拖拽按钮 thumbOffset 拖拽按钮位置补偿 maxHeight/maxWidth 最大宽高 minHeight/minWidth 最小宽高 可通过 maxHeight ，minHeight 控制 高度 常用方法 setProgress() 设置进度值 getProgress() 获取进度值 setSecondaryProgress() 设置第二进度值 getSecondaryProgress() 获取第二进度值 setSeekBarChangeListener() 设置seekbar拖动改变监听 自定义样式 自定义 背景 自定义进度样式 自定义滑块 自定义背景和进度样式 这里使用简单的shape图片 通过 progressDrawable 属性设置 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@android:id/background"&gt; &lt;shape&gt; &lt;solid android:color="#353b35"/&gt; &lt;corners android:radius="10dp"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:id="@android:id/progress"&gt; &lt;clip&gt; &lt;shape&gt; &lt;solid android:color="#10b410"/&gt; &lt;corners android:radius="10dp"/&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt;&lt;/layer-list&gt; 自定义滑块 通过 属性thumb 设置 这里也是通过shape图形绘制，滑块的高度 是可以自定义的 在这里就可以设置 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;!--按下--&gt; &lt;shape&gt; &lt;solid android:color="#b31395"/&gt; &lt;corners android:radius="10dp"/&gt; &lt;size android:height="40dp" android:width="20dp"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_focused="false"&gt; &lt;shape&gt; &lt;solid android:color="#362d35"/&gt; &lt;corners android:radius="10dp"/&gt; &lt;size android:height="40dp" android:width="20dp"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item &gt; &lt;shape&gt; &lt;solid android:color="#362d35"/&gt; &lt;corners android:radius="10dp"/&gt; &lt;size android:height="40dp" android:width="20dp"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; 高度通过 minHeight maxHeight 设置 1234567891011&lt;SeekBar android:id="@+id/seek_bar_0" android:layout_width="match_parent" android:layout_height="wrap_content" android:max="100" android:progress="20" android:layout_margin="10dp" android:maxHeight="20dp" android:minHeight="20dp" android:thumb="@drawable/selector_seek_thumb_bg" android:progressDrawable="@drawable/selector_seekbar_bg"/&gt; 实例图]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>SeekBar</tag>
        <tag>可拖动进度条</tag>
      </tags>
  </entry>
</search>
